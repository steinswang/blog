{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/bg.jpg","path":"img/bg.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","path":"js/jquery.autocomplete.min.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"fc82d21b7d4e8354f7e4f49dac9f3df769f79d82","modified":1534082372652},{"_id":"source/CNAME","hash":"c56f07d65fc8c6c7d83fc8019100cf09216768e6","modified":1533089251734},{"_id":"themes/3-hexo/.gitignore","hash":"5e85fe97e87211619c1db29fd3f3b0dbf16be4a7","modified":1534095722282},{"_id":"themes/3-hexo/README.md","hash":"794c03ffd0399d55d11b9dce610f8419c7106078","modified":1534095722282},{"_id":"themes/3-hexo/_config.yml","hash":"b5f684ea0d39b6f22d26eae0366fafc393ab81d1","modified":1534096337606},{"_id":"source/_posts/.DS_Store","hash":"ffca5efacd278752a3fb2721f701ed065998045d","modified":1534082372652},{"_id":"themes/3-hexo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1534095722278},{"_id":"themes/3-hexo/.git/config","hash":"01b66c1979dcfc0ab454bc7e595c4b0c367aae6f","modified":1534095722278},{"_id":"themes/3-hexo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1534095716674},{"_id":"themes/3-hexo/.git/index","hash":"111d4056658a103510a92e8ae6918bcb0aca166c","modified":1534095722286},{"_id":"themes/3-hexo/.git/packed-refs","hash":"8a7594a5b042c02227f3cd5bedcf675dfa986d33","modified":1534095722274},{"_id":"themes/3-hexo/layout/index.ejs","hash":"61842de9bda3f9a354d1f88d4289dfd0968320dd","modified":1534095722282},{"_id":"themes/3-hexo/layout/indexs.md","hash":"fd2cca7ed32ba7c6bff1b114462eddbd8e6d22f3","modified":1534164645128},{"_id":"themes/3-hexo/layout/post.ejs","hash":"810f046277fc49f523a72d1552eab1e39d3c299c","modified":1534095722282},{"_id":"source/_posts/Android/Contacts源码结构分析.md","hash":"e5a97bc3c25080485cf66d08ab89e9fc04a4f7d1","modified":1534673161956},{"_id":"source/_posts/Android/Linux常用压缩、解压对比.md","hash":"ad00f31513647a5ed6dea2cb6cc0a8e94ad73907","modified":1534678219749},{"_id":"source/_posts/Android/android2.3.1编译.md","hash":"ae49e0b1f41a23bd986159cbad705b0a586cd20e","modified":1534172904424},{"_id":"source/_posts/Android/gradle.md","hash":"2b3f6fb59f18776b46ced29d53928da4dacf37ee","modified":1534676039309},{"_id":"source/_posts/Android/不同系统chrome插件位置.md","hash":"0066cc22389836afced33fa5c697231418068561","modified":1534173258283},{"_id":"source/_posts/Android/为Nexus编译LineageOS.md","hash":"d8b1d9469a1e594fc4bdafa2dc1230b3c5dc77bd","modified":1533698824534},{"_id":"source/_posts/Android/合并重复联系人.md","hash":"f7f13fe658d623c63f0ec45278f51f04e609f342","modified":1534676401821},{"_id":"source/_posts/Android/多语言下，String子串可点击并实现跳转.md","hash":"f4e3796820e08a8b6c989ceba73c426cfd5d8dff","modified":1533089251734},{"_id":"source/_posts/Android/开机导入Sim卡联系人.md","hash":"c3edd67a95a82e872bb7948969053a3a3c36277d","modified":1533089251734},{"_id":"source/_posts/Android/联系人号码模糊查询.md","hash":"57086edb4762495a298ed47818f8eb3b87372781","modified":1534756740309},{"_id":"source/_posts/Android/跨进程通讯的4种方式.md","hash":"a30f0c281b8a4f4b7b196bae86ebda0a1fd1096a","modified":1533089251734},{"_id":"source/_posts/init/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1534082372652},{"_id":"source/_posts/init/blog-init.md","hash":"293266da5e64127a918ca6d7359e6ddffee356c1","modified":1534082372652},{"_id":"source/_posts/工具/.DS_Store","hash":"45b448be483388e2cc349366e249a2d531fbcea6","modified":1534082372652},{"_id":"source/_posts/工具/Hexo-GitHub-Pages搭建属于自己的blog.md","hash":"e18b3d9f28cb958ced95d98d70ddbb23c62955ec","modified":1533089251734},{"_id":"source/_posts/工具/工具软件-插件.md","hash":"df5f2be58924eca901f3a8fcaad5c12715fba5cd","modified":1533089251734},{"_id":"source/_posts/工具/工具软件keys.md","hash":"006adf560f28e1739a1a19369895eb08a8c3f8ac","modified":1533089251734},{"_id":"source/_posts/工具/快捷键.md","hash":"870265d63adbe730deb5cf381ebb69be9fc42252","modified":1533089251734},{"_id":"source/_posts/工具/正则表达式详解.md","hash":"e0b667a8ea1dd474b1cf7c90a13edc831bfbfbd0","modified":1534170111336},{"_id":"source/_posts/英语/Food-politics-in-America.md","hash":"3605c34cb6915cded4566fc8746a8415542ffedc","modified":1534141404200},{"_id":"themes/3-hexo/.git/hooks/applypatch-msg.sample","hash":"86b9655a9ebbde13ac8dd5795eb4d5b539edab0f","modified":1534095716670},{"_id":"themes/3-hexo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1534095716670},{"_id":"themes/3-hexo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1534095716670},{"_id":"themes/3-hexo/.git/hooks/pre-applypatch.sample","hash":"42fa41564917b44183a50c4d94bb03e1768ddad8","modified":1534095716670},{"_id":"themes/3-hexo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1534095716670},{"_id":"themes/3-hexo/.git/hooks/pre-push.sample","hash":"b4ad74c989616b7395dc6c9fce9871bb1e86dfb5","modified":1534095716670},{"_id":"themes/3-hexo/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1534095716674},{"_id":"themes/3-hexo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1534095716674},{"_id":"themes/3-hexo/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1534095716670},{"_id":"themes/3-hexo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1534095716674},{"_id":"themes/3-hexo/.git/logs/HEAD","hash":"79db9a12b43415a047210480843f746843b3792f","modified":1534095722278},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"864251708dac507bb041899d57e9a48759916476","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"5701b04252f113cc78dfde69bd6393fff6b1cce2","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"5507b4dfab2032345e012a0c5356f63b01395157","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"99ae7e411f8d24bed54a27be30bb71ef2041ff7b","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"a6714eed28ede8a50c186ef76798b410c2fb4f31","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"27ad82343ca09685b1a5adea2f3ead70a030a37e","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"7a31274da81c076021692ff7c80a1be3bbf6fa4c","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"7e6c50b6c24de864e0d6a106e6a8e423e312454a","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"866bb0d3964f2938dc5b5a22c24b05d32870820c","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"c2e5cef2377884cd79e5f686fe4f74b082744306","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"1bba114fd5685dadc595a4fdd9ac326c08d48244","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"5f5015bfc77c013f92395a4ac3464d28ab40a2a6","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"55042bba47352551e16add7ecb679b4a59da2b9f","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"da40cb48b6b1f24cbd7107f7c97b04f063e9c299","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"6406251dabda66ef686d4c15edbc3061b6d828b8","modified":1534095722282},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1534095722282},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"83e5569a58663f9322dda64d263a80153790ad68","modified":1534095722282},{"_id":"themes/3-hexo/source/css/style.styl","hash":"c7285882370f522c3bb17055cdf615cf92f48cd0","modified":1534095722282},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"f0d1fad4d14841cc3dd3b00c37e66ca9d2548020","modified":1533089251738},{"_id":"themes/3-hexo/source/img/bg.jpg","hash":"331f382a62f46ac8819c3b408b21af4f92118cf7","modified":1533089251738},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1534095722282},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1534095722282},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1534095722282},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"f0d1fad4d14841cc3dd3b00c37e66ca9d2548020","modified":1533089251738},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1534095722286},{"_id":"themes/3-hexo/source/js/script.js","hash":"311beeda0e450fc34943616c02da54e2229700a5","modified":1534095722286},{"_id":"themes/3-hexo/source/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1534095722286},{"_id":"themes/3-hexo/.git/objects/pack/pack-89e6c4803dab60e48b51715c0a122630ce39f181.idx","hash":"f55b67e072205e255529ea92652dc59646fbcb13","modified":1534095722254},{"_id":"themes/3-hexo/.git/refs/heads/master","hash":"8e0af13ee7441fc51351f60e99c0cc477bc1b072","modified":1534095722278},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"359f73329b9821f3ca3554d306a04d6766110a5a","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"cd0022ce7e6d6efb07a00e87477cdf791f7f6703","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/comments/gentie.ejs","hash":"1d6eacdadeb247e3b349ca7168f797beae8ff4c5","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"fad1fcafef7a15f8fa486e87a7c28d5bcd7e1b86","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"f8f9b49c7c7a00d16bd41bb72b90cca3d320d73e","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/autocomplete.styl","hash":"f6847a2c6d35dbd6d06dc591bd34ed2019784048","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"cc0a862b31359a85d12579e49d2eca58d128275c","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f6447a2ac407228e1d53e3455db2919ac0e9f094","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"4f687cbc74caf8a0887f5e89250284a9bce8b5c1","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"6c94d274b11553a982283b16770e0d54405a7bd5","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"0ba318911afbbbffbd2473b472aedf2d3900e978","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"c27f65e1ee2521b4eebf81242369a0825ce5cd6e","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"b600536ee237936c9f09609d96bb0dbb4adfb59b","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"65efbddd23a264e7d1e85f4073228526770e833c","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"4b996440bba8ec755aa70bc6d074d7dbba55ec0c","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"06d0b7a12ccc71cb693f5d07720602fb514c24eb","modified":1534095722282},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1534095722282},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1534095722282},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1534095722282},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1534095722282},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"57c7f100019d57b512aab509185cb0a6eb9aa4c8","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"69d184a682bcaeba2b180b437dc4431bc3be38aa","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1534095722282},{"_id":"themes/3-hexo/.git/logs/refs/heads/master","hash":"79db9a12b43415a047210480843f746843b3792f","modified":1534095722278},{"_id":"themes/3-hexo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1534095722274},{"_id":"themes/3-hexo/.git/logs/refs/remotes/origin/HEAD","hash":"79db9a12b43415a047210480843f746843b3792f","modified":1534095722274},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"b864356fbd31b5d694ccc46db97ea78455daf84d","modified":1534095722286},{"_id":"themes/3-hexo/.git/objects/pack/pack-89e6c4803dab60e48b51715c0a122630ce39f181.pack","hash":"9906db63e080d02effe4859aedecf5ec2adc10b5","modified":1534095722254},{"_id":"public/search.xml","hash":"bd16222c8737391dad213b8cb8d27986901d1f6a","modified":1534756767474},{"_id":"public/2018/08/13/android2.3.1-build/index.html","hash":"8b5fe492627d52f199a4ecf1ee9b0d97d15e1bf2","modified":1534756767486},{"_id":"public/2018/01/23/tool-softwares-and-plugins/index.html","hash":"81a9e54cfb8ed20adea79d71630bfcd0f8df3f10","modified":1534756767487},{"_id":"public/2018/01/23/tool-software-keys/index.html","hash":"8d1836f8eb24e367dddf76157129e33d8fd277a4","modified":1534756767487},{"_id":"public/2018/01/22/food-politics-in-America/index.html","hash":"cf63b1a0861535a5af0611ffdc9b20d4defe2d13","modified":1534756767487},{"_id":"public/2018/01/22/contacts-source-structure-analysis/index.html","hash":"9f2694f4aa576b900f3cbe9bb89e989b1511baf0","modified":1534756767487},{"_id":"public/2018/01/22/substring-jump/index.html","hash":"a684c50e30c55523d0f1e46f93c577d24620dbf9","modified":1534756767487},{"_id":"public/2018/01/16/merge-contacts/index.html","hash":"7d64693d72628f61651f7bbe427ce32cf764e940","modified":1534756767487},{"_id":"public/2018/01/15/import-Sim-card-contacts-when-boot/index.html","hash":"ad6aa117607326400c30f415b25577a95533f1ff","modified":1534756767487},{"_id":"public/2018/01/05/Build-LineageOS-for-Nexus-5/index.html","hash":"bb4bf75e05b9eefc6a3ea396d433f47d677a0774","modified":1534756767487},{"_id":"public/2018/01/03/Hexo-GitHub-Pages-Establish-blog/index.html","hash":"9d42054f0192ccd47245fd357dde839a3db44a30","modified":1534756767487},{"_id":"public/2018/01/01/contacts-phone-number-fuzzy-search/index.html","hash":"4b8aed32eee21428193ebaf8923a15de3ab17847","modified":1534756767487},{"_id":"public/2017/12/30/3-hexo-shortcuts/index.html","hash":"d7a5dab78b9c41ead55ad1de42e46f58884ac39f","modified":1534756767487},{"_id":"public/2017/12/23/blog-init/index.html","hash":"a2ea5912570f24e1fa725fc5bb30cb2065c98e3d","modified":1534756767487},{"_id":"public/2017/10/04/正则表达式详解/index.html","hash":"83d0eef5c4be50f92831cad7e22784b482916946","modified":1534756767487},{"_id":"public/2017/01/15/gradle-issue/index.html","hash":"d7e527ce3fe4dc3db0d08625a12a7aee92b87ec8","modified":1534756767487},{"_id":"public/2016/08/13/chrome-plugin-location/index.html","hash":"4284a581407864f584885b8e3a2c633673ac2b02","modified":1534756767487},{"_id":"public/2016/01/15/zip-unzip-compare/index.html","hash":"2630527c9b54c4aeb2fa2560d13f2488e20521a5","modified":1534756767487},{"_id":"public/2015/08/10/access-across-processes/index.html","hash":"370a49e47e6d4cbc934d1de20017e6a8295c49a0","modified":1534756767487},{"_id":"public/archives/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767487},{"_id":"public/archives/page/2/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767487},{"_id":"public/archives/2015/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/archives/2015/08/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/archives/2016/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/archives/2016/01/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/archives/2016/08/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/archives/2017/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/archives/2017/01/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/archives/2017/10/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/archives/2017/12/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/archives/2018/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/archives/2018/page/2/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/archives/2018/01/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/archives/2018/08/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/categories/Android/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/categories/工具/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/categories/init/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/categories/英语/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/page/2/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/tags/android/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/tags/contacts/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/tags/android2-3-1/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767488},{"_id":"public/tags/gradle/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767489},{"_id":"public/tags/面试/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767489},{"_id":"public/tags/压缩/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767489},{"_id":"public/tags/chrome/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767489},{"_id":"public/tags/chrome-plugin/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767489},{"_id":"public/tags/cm/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767489},{"_id":"public/tags/lineageos/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767489},{"_id":"public/tags/tools/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767489},{"_id":"public/tags/hexo/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767489},{"_id":"public/tags/blog/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767489},{"_id":"public/tags/keys/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767489},{"_id":"public/tags/3-hexo/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767489},{"_id":"public/tags/正则表达式/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767489},{"_id":"public/tags/english/index.html","hash":"558a0469327ec1405ed62bcde59c2d3791637a23","modified":1534756767489},{"_id":"public/CNAME","hash":"c56f07d65fc8c6c7d83fc8019100cf09216768e6","modified":1534756767492},{"_id":"public/img/alipay.jpg","hash":"f0d1fad4d14841cc3dd3b00c37e66ca9d2548020","modified":1534756767492},{"_id":"public/img/bg.jpg","hash":"331f382a62f46ac8819c3b408b21af4f92118cf7","modified":1534756767492},{"_id":"public/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1534756767492},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1534756767492},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1534756767492},{"_id":"public/img/weixin.jpg","hash":"f0d1fad4d14841cc3dd3b00c37e66ca9d2548020","modified":1534756767492},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1534756767492},{"_id":"public/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1534756767492},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1534756767492},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1534756767492},{"_id":"public/css/mobile.css","hash":"102f04bcf1923b67882e1bb545ae6f331c1ce7cd","modified":1534756767752},{"_id":"public/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1534756767752},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1534756767752},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1534756767752},{"_id":"public/css/hl_theme/atom-light.css","hash":"a3c8f3ee9a655594eff7ac545cb2e6914c1abcc2","modified":1534756767752},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1534756767752},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1534756767752},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1534756767752},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1534756767752},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1534756767752},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1534756767752},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1534756767752},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1534756767752},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1534756767752},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1534756767752},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1534756767752},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1534756767752},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1534756767753},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1534756767753},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1534756767753},{"_id":"public/css/style.css","hash":"5409cea3e90bd900b5bb8137c36ea542875642d6","modified":1534756767753},{"_id":"public/js/script.js","hash":"311beeda0e450fc34943616c02da54e2229700a5","modified":1534756767753},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1534756767753},{"_id":"public/js/gitalk.js","hash":"b864356fbd31b5d694ccc46db97ea78455daf84d","modified":1534756767753}],"Category":[{"name":"Android","_id":"cjl22jwhq0002rmujya8a31de"},{"name":"工具","_id":"cjl22jwhz000jrmujf2bhif0k"},{"name":"init","_id":"cjl22jwi3000zrmuj0rjgm8ni"},{"name":"英语","_id":"cjl22jwi8001jrmujja7h7ya7"}],"Data":[],"Page":[],"Post":[{"title":"Contacts源码结构分析","date":"2018-01-22T09:53:49.000Z","_content":"\n## 1.简介\n\n联系人模块主要记录用户的联系人数据，方便用户快捷的操作和使用，主要包括本机联系人和Sim卡联系人。\n\n本机联系人主要存储在手机内部存储空间，Android平台上是通过数据库进行存储，使用ContentProvider组件封装，提供复杂的字段用于表示联系人数据，并提供用户快捷的操作，比如增加，删除，修改，查询等等。\n\nSim卡联系人主要存储在Sim卡内部存储文件，包括adn、fdn、sdn。主要提供简单的字段用于表示联系人数据。并通过IccProvider提供的接口进行数据的增加、删除、修改、查询操作。\n\n## 2.软件架构\n联系人Contacts应用主要包括3个部分:\nContacts主要响应用户的请求和交互，数据显示。\nContactsProvider继承自Android四大组件之一的ContentProvider组件，封装了对底层数据库contact2.db的添删改查。\nSQLite在底层物理性地存储了联系人数据。\n\n\n主要交互流程如下图：\n\n![](https://user-images.githubusercontent.com/35097187/44019032-3b7392de-9f10-11e8-8567-d4189730b46e.png)\n\nContacts模块的主要7块功能：\n\n![](https://user-images.githubusercontent.com/35097187/44019045-3d496fe8-9f10-11e8-8077-89235449ccd4.png)\n\n## 3. 各功能模块分析\n### 3.1 联系人数据的显示\n#### 3.1.1 联系人列表显示 ####\n\n`简要说明：`\n\n```xml\n* PeopleActivity类负责联系人列表的显示。\n\n* PeopleActivity包含4个Fragment，每个Fragment包含一个ListView。\n\n* 各个Fragment中ListView的Adapter（BaseAdapter的子类）负责将数据填充到ListView。\n\n* 各个Fragment的Loader类（CursorLoader的子类）负责加载数据。\n\n* 实现LoadertManager接口负责管理这些CursorLoader。\n```\n\n![](https://user-images.githubusercontent.com/35097187/44019049-3dc1ee1e-9f10-11e8-89f3-14dac608ea42.png)\n\n**为什么使用Loader？**\n```xml\n1. Loaders确保所有的cursor操作是异步的，从而排除了UI线程中堵塞的可能性。\n2. 当通过LoaderManager来管理，Loaders还可以在activity实例中保持当前的cursor数据，也就是不需要重新查询（比如，当因为横竖屏切换需要重新启动activity时）。\n3. 当数据改变时，Loaders可以自动检测底层数据的更新和重新检索。\n```\n\n**数据加载流程概览：**\n\n![](https://user-images.githubusercontent.com/35097187/44019046-3d7130f0-9f10-11e8-945c-7a0eff02b65c.png)\n\n**流程具体分析：**\n\n先上图：\n![](https://user-images.githubusercontent.com/35097187/44019033-3ba1bba0-9f10-11e8-94f9-e41053c967b4.jpeg)\n\n进入Contacts应用，程序的主入口Activity是`PeopleActivity`。\n\n进入`onCreate`方法：\n\n`createViewsAndFragments(savedState);`\n\n此方法创建视图和Fragments，进入此方法：\n\n```java\nmFavoritesFragment = new ContactTileListFragment();\nmAllFragment = new DefaultContactBrowseListFragment();\nmGroupsFragment = new GroupBrowseListFragment();\n```\n\n发现创建了3个Fragment，分别是 收藏联系人列表、所有联系人列表、群组列表。\n\n进入`DefaultContactBrowseListFragment`：\n\n发现`DefaultContactBrowseListFragment`的祖父类是：\n\n`ContactEntryListFragment<T extends ContactEntryListAdapter>`\n\n首先分析此基类：\n\n发现此基类实现了`LoadManager`接口，实现了该接口3个重要的抽象方法：\n\n```java\npublic Loader<D> onCreateLoader(int id, Bundle args);//创建Loader\npublic void onLoadFinished(Loader<D> loader, D data);//数据加载完毕后的回调方法\npublic void onLoaderReset(Loader<D> loader);//数据重新加载\n```\n\n该类同时提供了重要的抽象方法：\n\n```java\nprotected abstract T createListAdapter();//创建适配器Adapter类。\n```\n\n这意味着,子类可以按需求创造自己的适配器Adapter类,完成各个子界面Listview的数据显示，如3.1节图1所示。\n\n然后回到`DefaultContactBrowseListFragment`类：\n\n在执行`onCreateView`之前，会执行父类的一些方法，顺序如下：\n\n```java\nonAttach()\nsetContext(activity);\nsetLoaderManager(super.getLoaderManager());\n```\n\n`setLoaderManager`中设置当前的LoaderManager实现类。 \n\n加载联系人列表数据的过程中，这个类是`ProfileandContactsLoader`。\n\n之后执行`onCreate`方法。\n\n进入`DefaultContactBrowseListFragment`的`onCreate(Bundle)`方法：\n\n```java\nmAdapter = createListAdapter();\n```\n\n发现在这里创建了`ListAdapter`：\n\n```java\nDefaultContactListAdapter adapter = \nnew DefaultContactListAdapter(getContext());\n```\n\n可以知道创建的`ListAdapter`类型是`DefaultContactListAdapter`并返回到`DefaultContactBrowseListFragment`类。\n\n执行完`onCreate`方法之后，\n\n执行`DefaultContactBrowseListFragment`的`onCreateView`方法。\n\n进入DefaultContactBrowseListFragment的onCreateView方法：\n\n```java\nmListView = (ListView)mView.findViewById(android.R.id.list);\nmListView.setAdapter(mAdapter);\n```\n\n首先获取了ListView用以填充联系人数据，然后设置了适配器，但是此时适配器中的数据是空的，直到后面才会加载数据更新UI。\n在`onCreateView`方法执行完之后，在UI可见之前回调执行`Activity`的`onStart`方法。\n\n进入`DefaultContactBrowseListFragment`的`onStart`方法：\n\n```java\nmContactsPrefs.registerChangeListener(mPreferencesChangeListener);\nstartLoading();\n```\n\n首先注册了一个`ContentObserv`e的子类监听数据变化。\n然后执行`startLoading`方法，**目测这应当就是开始加载数据的方法了！**\n\n进入`DefaultContactBrowseListFragment`的`startLoading`方法：\n\n```java\nint partitionCount = mAdapter.getPartitionCount();\nfor (int i = 0; i < partitionCount; i++) {\n……\nPartition partition = mAdapter.getPartition(i);\nstartLoadingDirectoryPartition(i);\n……}\n```\n\n`Partition`这个类持有一个`Cursor`对象，用来存储数据。\n`Adapter`持有的`Partition`，`Partition`类代表了当前需要加载的`Directory`，可以理解为一个联系人集合，比如说本地联系人、Google联系人……这里我们假设只加载本地联系人数据，所以`partitionCount=1`。\n\n从这里我们可以做出猜测：\n联系人数据不是想象中的分页（每次N条联系人数据）加载，也不是说一次性全部加载，而是一个账户一个账户加载联系人数据，加载完毕一个账户就在uI刷新并显示数据。\n\n进入`DefaultContactBrowseListFragment`的`startLoadingDirectoryPartition`方法：\n\n```java\nloadDirectoryPartition(partitionIndex, partition);\n```\n\n进入此方法：\n\n```java\ngetLoaderManager().restartLoader(partitionIndex, args, this);\n```\n\n这个方法是LoaderManager实现类的方法，参照文档解释：\n\n>这个方法会新建/重启一个当前LoaderManager中的Loader，将回调方法注册给他，并开始加载数据。也就是说会回调LoaderManager的onCreateLoader()方法。\n>Starts a new or restarts an existing android.content.Loader in this manager, registers the callbacks to it, and (if the activity/fragment is currently started) starts loading it\n\n进入`LoadManager`接口的实现类：`LoaderManagerImpl`的`restartLoader`方法内部：\n\n```java\nLoaderInfo info = mLoaders.get(id);\nCreate info=\ncreateAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks<Object>)callback);\n//进入createAndInstallLoader方法：\nLoaderInfo info = createLoader(id, args, callback);\ninstallLoader(info);\n//进入createLoader方法：\nLoaderInfo info = new LoaderInfo(id, args,  (LoaderManager.LoaderCallbacks<Object>)callback);\nLoader<Object> loader = callback.onCreateLoader(id, args);\n//关键方法出现了！LoadManager接口的抽象方法的onCreateLoader方法被回调了！\n//然后installLoader方法启动了这个Loader！\ninfo.start();\n```\n\n进入`ContactEntryListFragment`的`onCreateLoader`方法，位于`DefaultContactBrowseListFragment`的祖父类`ContactEntryListFragment`中：\n\n```java\nCursorLoader loader = createCursorLoader(mContext);//创建Loader\nmAdapter.configureLoader(loader, directoryId);//配置Loader\n```\n\n发现在此方法中，首先调用`createCursorLoader`方法创建了`Loader`。\n然后通过`configureLoader`方法配置`Loader`的`query`方法的查询参数，也就是配置SQL中select查询语句的参数。\n这也同时意味着，`ContactEntryListFragment`类的子类们可以重写`createCursorLoader`方法以提供适合自身的Loader，重写`configureLoader`方法为Loader配置合适的参数，适配各种自定义的查询获取数据。\n\n观察`createCursorLoader`方法在`DefaultContactBrowseListFragment`类中实现：\n\n```java\nreturn new ProfileAndContactsLoader(context);\n```\n\n直接返回了`DefaultContactBrowseListFragment`的数据加载器：`ProfileAndContactsLoader`\n这就是`DefaultContactBrowseListFragment`的Loader实现类（数据加载器）。\n\n然后再看一下`ProfileAndContactsLoader`类是如何加载数据的呢？\n发现它继承自`CursorLoader`，而`CursorLoader`又继承自`AsyncTaskLoader<D>`\n在关键的`LoadBackGround()`方法中：\n异步调用了ContentResolver的`query`方法：\n\n```java\nCursor cursor = getContext()\n.getContentResolver()\n.query(mUri, mProjection, mSelection,\n                    mSelectionArgs, mSortOrder, mCancellationSignal);\ncursor.registerContentObserver(mObserver);\n```\n\n通过这个Query方法，实现了对联系人数据的查询,返回Cursor数据。并绑定了数据监听器。\n\n\n那么问题来了\n\n```java\nquery(mUri, mProjection, mSelection,mSelectionArgs, mSortOrder, mCancellationSignal)\n```\n的这些参数那里指定的呢？\n`configureLoader`方法在`DefaultContactListAdapter`类中实现，实现了对`query`参数的配置：\n\n```java\nconfigureUri(loader, directoryId, filter);\nloader.setProjection(getProjection(false));\nconfigureSelection(loader, directoryId, filter);\nloader.setSortOrder(sortOrder);\n```\n\n可以看到，配置了Loader主要的几个参数：Uri，Projection，Selection，SortOrder。\n这些参数用于最后和ContactsProvider交互的方法Query方法中……\n\n最终查询`ContactsProvider2`的uri是：\n\n```xml\nUri：content://com.android.contacts/contacts?address_book_index_extras=true&directory=0\n```\n\n发现ContentProvider的服务类似一个网站，uri就是网址，而请求数据的方式类似使用Get方式获取数据。\n\n最后通过ContentProvider2构建的查询语句是这样的：\n\n```sql\nSELECT \n_id, display_name, agg_presence.mode AS contact_presence, \ncontacts_status_updates.status AS contact_status, photo_id, photo_thumb_uri, lookup, \nis_user_profile \nFROM view_contacts \nLEFT OUTER JOIN agg_presence ON (_id = agg_presence.presence_contact_id) LEFT OUTER JOIN \nstatus_updates contacts_status_updates ON\n(status_update_id=contacts_status_updates.status_update_data_id)\n```\n可以发现最后通过ContactsProvider2实现的查询，并不是直接查询相关的表（Contacts表、rawcontacts表，data表……），而是直接查询`view_contacts`视图，因为这样会有更加高的效率。\n这也就意味着如果想给联系人数据库新增一个字段供界面使用，仅修改对应的表结构是不行，还要修改对应的视图才能得到想要的效果。\n\n\n查询完毕后，回调`LoaderManager`的`onLoadFinished`方法，完成对UI界面的更新：\n\n```java\nonPartitionLoaded(loaderId, data);\n```\n\n接着进入`onPartitionLoaded`方法：\n\n```java\nmAdapter.changeCursor(partitionIndex, data);\n```\n\n进入这个`changeCursor`方法：\n\n```java\nmPartitions[partition].cursor = cursor;\nnotifyDataSetChanged();\n```\n\n发现在这里改变了`Adapter`的数据集`Cursor`，并发出通知数据已经改变，UI进行更新。\n\n至此，默认联系人数据的显示分析到此结束。\n\n其他`Fragment`的数据填充基本仍然类似此流程，所不同的只是各自的`Fragment`、`Adapter`、`CursorLoader`以及`CursorLoader`配置的参数（uri，projection,selection,args,order……）有所不同。\n\n可以参考下表：\n\n| Fragment | Adapter | CursorLoader |\n| :------: | :------: | :------: |\n|DefaultContactBrowseListFragment(默认联系人列表)|DefaultContactListAdapter|ProfileAndContactsLoader|\n|ContactTitleListFragment(收藏联系人列表)|ContactTileAdapter|ContactTileLoaderFactory StarredLoader|\n|ContactTitleFrequentFragment(常用联系人列表)|ContactTitleAdapter|ContactTileLoaderFactory FrequentLoader|\n|GroupBrowseListFragment(群组列表)|GroupBrowseLIstAdapter|GroupListLoader|\n|GroupDetailFragment(指定ID群组的联系人列表)|GroupMemberTileAdapter|GroupMemberLoader|\n|ContactDetailFragment(指定ID联系人信息)|ViewAdapter|ContactLoader| \n\n#### 3.1.2 联系人详细信息数据的显示 ####\n**关键类：**\n```java\nContactDetailActivity\n\nContactDetailFragment  \n\nContactLoaderFragment //不可见 负责加载联系人详细数据，集成LoadManager对象。\n\nContactLoader   //联系人详细信息Loader。\n\nContactDetailLayoutController     //布局控制类。\n```\n\n原理类似列表显示，如下简要说明： \n```xml\n* ContactLoaderFragment类创建了一个实现LoaderManager.LoaderCallbacks<Contact>接口的对象，数据类型指定为Contacts。负责创建、管理ContactLoader。\n \n* 得到当前用户选择的联系人URI，配置对应的ContactLoader。 \n\n* 后台数据查询完毕后，回调LoadManager的onLoadFinished()方法，并将数据以Contacts的数据类型返回，然后回调ContactDetailLoaderFragmentListener的onDetailsLoaded()方法。 \n\n* onDetailsLoaded()方法中，新开一个线程，通过ContactDetailLayoutController类的setContactData(Conatct)设置数据，刷新ContactDetailFragment。\n```\n\n### 3.2 联系人数据的编辑和存储\n\n#### 3.2.1 编辑界面相关####\n\n联系人数据所属的账号不同，加载的UI也是不同的，比如Sim卡联系人一般只有name，phone num，但是本地账号联系人可能就会有email，\n\naddress，website等信息…… \n\n联系人数据UI的加载是通过代码动态加载的，而不是xml文件写死的。\n\n那么问题来了， \n\n新建联系人的界面是如何设计？ \n\n![](https://user-images.githubusercontent.com/35097187/44019034-3bc9de0a-9f10-11e8-8f38-f764c64cc8e2.jpeg)\n\n先进入新建联系人界面：\n\n主界面`PeopleActivity`中点击新建联系人Button，触发`onOptionsItemSelected`方法中的\n\ncase R.id.menu_add_contact分支： \n\n执行`startActivity(intent);` \n\n`startActivity`启动Intent，Intent的Action设置为android.intent.action.INSERT \n\n找到匹配此Action的Activity：`ContactEditorActivity`\n\n`ContactEditorActivity`的布局文件：\n \n`ContactEditorActivity`的`onCreate()`方法中找到布局： \n\n`setContentView(R.layout.contact_editor_activity);`\n\n在xml文件中找到这个布局：\n\n```xml\n<FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n <fragment class=\"com.android.contacts.editor.ContactEditorFragment\"\n            android:id=\"@+id/contact_editor_fragment\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\" />\n</FrameLayout>\n```\n\n只包含一个Fragment：`ContactEditorFragment`。程序解析Xml文件到这里就会执行`ContactEditorFragment`类。\n\n进入`ContactEditorFragment`的`onCreateView`方法：\n\n```xml\n//展开布局 \nfinal View view\n= inflater.inflate(R.layout.contact_editor_fragment, container, false);    \n//找到布局中的一个线性布局\n//关键的布局是contact_editor_fragment中的一个iD为editors的线性布局！\nmContent = (LinearLayout) view.findViewById(R.id.editors);\n```\n\n找到`contact_editor_fragment`：\n\n```xml\n<ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:fillViewport=\"true\"\n    android:fadingEdge=\"none\"\n    android:background=\"@color/background_primary\"\n>\n    <LinearLayout android:id=\"@+id/editors\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\"\n    />\n</ScrollView>\n```\n\n于是确认`ContactEditorFragment`的根布局就是一个id为`editors`的LinearLayout。 \n想到上一步的语句：\n\n```xml\nmContent = (LinearLayout) view.findViewById(R.id.editors);\n```\n\n所以关键就在于，接下来在代码中为mContent这个线性布局动态添加地了什么UI，而这些UI才是真正显示的东西。\n\n`ContactEditorFragment`的`onCreateView`方法执行完毕之后，会调用`onActivityCreate()`方法：\n\n```java\nif (Intent.ACTION_INSERT.equals(mAction)) {\nfinal Account account = mIntentExtras == null ? null : (Account) \nmIntentExtbindEditorsForNewContactras.getParcelable(Intents.Insert.ACCOUNT);\nfinal String dataSet = mIntentExtras == null ? null :\n                        mIntentExtras.getString(Intents.Insert.DATA_SET);\nif (account != null) {\n// Account specified in Intent\ncreateContact(new AccountWithDataSet(account.name, account.type, dataSet));\n}\n```\n\n上面代码首先取出了当前Account信息，数据信息。封装为一个`AccountWithDataSet`对象，作为`createContact`方法的参数。之前我们分析过，编辑界面和账户是高度相关的，所以对UI的动态操作必然和Account对象相关。进入`createContact`方法。\n\n看一下`ContactEditorFragment`中的`createContact()`到底对界面干了什么！！ \n\n`createContact`方法中调用了`bindEditorsForNewContact(account, accountType)`: \n\n关键代码：\n```java\n……\nfinal RawContact rawContact = new RawContact();\nif (newAccount != null) {\n    rawContact.setAccount(newAccount);\n} else {\n    rawContact.setAccountToLocal();\n}\nfinal ValuesDelta valuesDelta = ValuesDelta.fromAfter(rawContact.getValues());\nfinal RawContactDelta insert = new RawContactDelta(valuesDelta);\n……\nmState.add(insert);\nbindEditors();\n```\n\n发现暂时还是没有对界面做什么事情，任然处于酝酿阶段……\n\n首先使用传入的Accout对象创建一个`RawContact`对象，然后使用`RawContact`对象构建了一个`RawContactDelta`对象insert，接着就将insert对象放入`RawContactDeltaList` 对象`mState`中。\n\n```xml\nRawContact类：raw contacts数据表内的一条数据，表示一个联系人某一特定帐户的信息。存储Data表中一些数据行（电话号码、Email、地址……）的集合及一些其他的信息。\n他的存储结构为： HashMap<String, ArrayList<ValuesDelta>>\n\nRawContactDelta类：包含RawContact对象（即一个联系人某一特定帐户的信息），并具有记录修改的功能。\n\nRawContactDeltaList类：内部的存储结构是ArrayList<RawContactDelta>，可以理解为 单个联系人所有账户的数据集合。\n```\n\n然后调用了`bindEditors()`法。 \n\n关键代码如下：\n```java\n……\nmContent.removeAllViews();\n……\nfinal BaseRawContactEditorView editor;\n……\neditor = (RawContactEditorView) inflater.inflate(R.layout.raw_contact_editor_view,mContent, false);\n//添加视图了……………………\nmContent.addView(editor);\n//为自定义视图BaseRawContactEditorView设置状态，必然是修改UI的操作！\neditor.setState(rawContactDelta, type, mViewIdGenerator, isEditingUserProfile());\n```\n\n可以看到，`mContent`这个LinearLayout添加的View是`editor`，而`editor`是一个自定义的视图`BaseRawContactEditorView`，布局是`R.layout.raw_contact_editor_view`。\n\n找到`raw_contact_editor_view`布局，发现该布局包含新建联系人页面所有的UI：\n\n![](https://user-images.githubusercontent.com/35097187/44019036-3bf3c4ae-9f10-11e8-81b0-dfa54fe8fad9.jpeg) \n\n```xml\n<com.android.contacts.editor.RawContactEditorView\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\"\n    android:paddingTop=\"@dimen/editor_padding_top\">\n<include\n用户账户相关UI\n        layout=\"@layout/editor_account_header_with_dropdown\" />\n    <LinearLayout\n        android:id=\"@+id/body\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\">\n        <LinearLayout\n            android:layout_height=\"wrap_content\"\n            android:layout_width=\"match_parent\"\n            android:orientation=\"horizontal\"\n            android:paddingTop=\"8dip\">\n            <LinearLayout\n                android:layout_height=\"wrap_content\"\n                android:layout_width=\"0dip\"\n                android:layout_weight=\"1\"\n                android:orientation=\"vertical\">\n                <include\n            Name相关的UI\n                    android:id=\"@+id/edit_name\"\n                    layout=\"@layout/structured_name_editor_view\" />\n                <include\n            拼音名\n                    android:id=\"@+id/edit_phonetic_name\"\n                    layout=\"@layout/phonetic_name_editor_view\" />\n            </LinearLayout>\n            <include\n            照片相关的UI\n                android:id=\"@+id/edit_photo\"\n                android:layout_marginRight=\"8dip\"\n                android:layout_marginEnd=\"8dip\"\n                layout=\"@layout/item_photo_editor\" />\n        </LinearLayout>\n        <LinearLayout\n            中间部分Item的显示在此处\n            android:id=\"@+id/sect_fields\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"vertical\"\n            android:layout_marginBottom=\"16dip\"/>\n            添加其他字段 按钮\n        <Button\n            android:id=\"@+id/button_add_field\"\n            android:text=\"@string/add_field\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_gravity=\"center\"\n            android:layout_marginBottom=\"32dip\"/>\n    </LinearLayout>\n</com.android.contacts.editor.RawContactEditorView>\n```\n\n1.那么问题来了：中间的那部分布局（电话、地址……）去哪儿了？\n\n搜索有可能包含这些内容的线性布局`sect_fields`，发现在`RawContactEditorView`类中初始化为`mFields`：\n\n`mFields = (ViewGroup)findViewById(R.id.sect_fields);`\n\n那么只需要看代码中对mFields添加了什么UI！\n\n2.回到之前的`bindEditors()`方法，`RawContactEditorView` 对象`editor`从xml中解析完成后，执行了`setState`方法：\n\n```java\neditor.setState(rawContactDelta, type, mViewIdGenerator, isEditingUserProfile());\n```\n\n1.`进入RawContactEditorView`类，找到`setState`方法：\n\n```java\npublic void  setState(RawContactDelta state, AccountType type, ViewIdGenerator vig,boolean isProfile)\n……\n// 遍历当前账户所有可能的item种类，如电话，姓名，地址……，并分别创建自定义视图KindSectionView\n   for (DataKind kind : type.getSortedDataKinds()) {\n……\n  final KindSectionView section = (KindSectionView)mInflater.inflate(\n                        R.layout.item_kind_section, mFields, false);\n                section.setEnabled(isEnabled());\n                section.setState(kind, state, false, vig);\n                mFields.addView(section);\n……\n}\n```\n\n发现遍历了当前账号类型中所有可能的数据类型（`DataKind`），\n\n创建了相关的自定义视图`KindSectionView`对象`section`，\n\n再将`section`对象添加到`mFields`中显示，\n\n这个mFields正是之前在`RawContactEditorView`类中初始化的线性布局：\n```java\nmFields = (ViewGroup)findViewById(R.id.sect_fields)。\n```\n\n到这里，基本可以确定，中间部分（也就是除了Name、Photo 和底部的添加字段Button之外的部分），就是通过这个`mFields`动态的根据当前账户类型添加编辑的`KindSectionView`条目来填充的。\n\n首先观察一下`KindSectionView`的布局文件`item_kind_section`：\n\n```xml\n<com.android.contacts.editor.KindSectionView\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\">\n    <include                   这是一个TextView，title\n        android:id=\"@+id/kind_title_layout\"\n        layout=\"@layout/edit_kind_title\" />\n      <LinearLayout            线性布局，用于添加EditText\n        android:id=\"@+id/kind_editors\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\" />\n    <include                   添加新条目的TextView，初始化状态不可见\n        android:id=\"@+id/add_field_footer\"\n        layout=\"@layout/edit_add_field\" />\n</com.android.contacts.editor.KindSectionView>\n```\n\n1.`KindSectionView`加载完xml文件之后，会执行`onFinishInflate`方法：\n\n```java\nmTitle = (TextView) findViewById(R.id.kind_title);\nmEditors = (ViewGroup) findViewById(R.id.kind_editors); \nmAddFieldFooter = findViewById(R.id.add_field_footer);\n```\n\n把Xml文件中三个主要的部分都得到了，接下来重点就是观察代码中对他们做了什么。\n\n在第12步中，加载完xml文件之后，执行`KindSectionView`的`setState`方法：\n\n```java\nsection.setState(kind, state, false, vig);\n```\n\n将`rawContactDelta`对象`state`传递给了`KindSectionView`类的`setState`方法：\n\n进入`KindSectionView`类的`setState`方法：\n\n```java\nmKind = kind;\nmState = state;\nrebuildFromState();\n```\n\n先进行局部变量的赋值\n\n1.然后进入到`rebuildFromState()`方法：\n```java\n  for (ValuesDelta entry : mState.getMimeEntries(mKind.mimeType)) {\n       //……遍历当前账户可能的键值对，比如电话、Email、地址……\n      createEditorView(entry);  //这个方法应当是创建EditText的方法！\n  }\n```\n\n在这个方法中，对`mState`集合中所有Mime类型的`ValuesDelta`集合（`ArrayList<ValuesDelta>`类型）进行遍历，而后将每一个 `ValuesDelta`对象 `entry`作为参数调用了`createEditorView(entry)`也就是创建各个种类的`EditText`方法，根据`entry`对象创建相应的`EditText`！\n\n简单说，就是创建`mState`中存在的类型的`EditText`。\n当然……这还都只是猜测，需要进入`createEditorView`方法确认。\n\n1.进入`createEditorView`方法：\n\n```java\nview = mInflater.inflate(layoutResId, mEditors, false);\nEditor editor = (Editor) view;\neditor.setValues(mKind, entry, mState, mReadOnly, mViewIdGenerator);\n```\n\n第13步初始化的`mEditors`对象（也就是那个被猜测应该是放`EditText`的线性布局）在这里被使用！\n\n1.联系上下文，实际上此时editor对象是`TextFieldsEditorView`类的对象，进入`TextFieldsEditorView`的`setValues`方法，看看他是如何根据entry对象创建`EditText`的：\n\n```java\npublic void setValues(DataKind kind, ValuesDelta entry, RawContactDelta state, boolean readOnly,ViewIdGenerator vig) {\nint fieldCount = kind.fieldList.size();  //获取所有可能的datakind的总数\nfor (int index = 0; index < fieldCount; index++)    //遍历所有可能的datakind，\n{ \nfinal EditText fieldView = new EditText(mContext);  //创建EditText对象，之后进行配置\nfieldView.setLayoutParams……\nfieldView.setTextAppearance(getContext(), android.R.style.TextAppearance_Medium);\nfieldView.setHint(field.titleRes);   //EditText的Hint\n……     \n\nfieldView.addTextChangedListener(new TextWatcher()  //注册TextChangedListener\n{\n\t@Override\n\tpublic void afterTextChanged(Editable s) {\n\t    // Trigger event for newly changed value\n\t    onFieldChanged(column, s.toString());\n\t}\n\tmFields.addView(fieldView);    //将EditText添加到当前的线性布局中！\n}\n```\n注释基本解释了如何通过一个`ValuesDelta`（理解为键值对集合）对象`entry`创建布局中的所有`EditText`。\n\n至此，联系人编辑界面的显示原理基本分析完成。\n\n\n数据存储相关\n\n### 3.3 Sim联系人数据的整合\nSim卡联系人数据的显示\n开机自动导入Sim卡联系人\ntelephony中IccProvider浅析\nSim卡联系人的手动导入导出\n\n### 3.4 SD卡备份/恢复联系人\n- SD卡备份/恢复联系人\n- 联系人数据导出到SD卡\n\n### 3.5 联系人搜索\n\n### 3.6 Google联系人同步\n\n### 3.7 其他零碎功能\n\n转自：https://blog.csdn.net/Kafka_88/article/details/50670406\n\n","source":"_posts/Android/Contacts源码结构分析.md","raw":"---\ntitle: Contacts源码结构分析\npermalink: contacts-source-structure-analysis\ncategories:\n  - Android\ntags:\n  - android\n  - contacts\ndate: 2018-01-22 17:53:49\n---\n\n## 1.简介\n\n联系人模块主要记录用户的联系人数据，方便用户快捷的操作和使用，主要包括本机联系人和Sim卡联系人。\n\n本机联系人主要存储在手机内部存储空间，Android平台上是通过数据库进行存储，使用ContentProvider组件封装，提供复杂的字段用于表示联系人数据，并提供用户快捷的操作，比如增加，删除，修改，查询等等。\n\nSim卡联系人主要存储在Sim卡内部存储文件，包括adn、fdn、sdn。主要提供简单的字段用于表示联系人数据。并通过IccProvider提供的接口进行数据的增加、删除、修改、查询操作。\n\n## 2.软件架构\n联系人Contacts应用主要包括3个部分:\nContacts主要响应用户的请求和交互，数据显示。\nContactsProvider继承自Android四大组件之一的ContentProvider组件，封装了对底层数据库contact2.db的添删改查。\nSQLite在底层物理性地存储了联系人数据。\n\n\n主要交互流程如下图：\n\n![](https://user-images.githubusercontent.com/35097187/44019032-3b7392de-9f10-11e8-8567-d4189730b46e.png)\n\nContacts模块的主要7块功能：\n\n![](https://user-images.githubusercontent.com/35097187/44019045-3d496fe8-9f10-11e8-8077-89235449ccd4.png)\n\n## 3. 各功能模块分析\n### 3.1 联系人数据的显示\n#### 3.1.1 联系人列表显示 ####\n\n`简要说明：`\n\n```xml\n* PeopleActivity类负责联系人列表的显示。\n\n* PeopleActivity包含4个Fragment，每个Fragment包含一个ListView。\n\n* 各个Fragment中ListView的Adapter（BaseAdapter的子类）负责将数据填充到ListView。\n\n* 各个Fragment的Loader类（CursorLoader的子类）负责加载数据。\n\n* 实现LoadertManager接口负责管理这些CursorLoader。\n```\n\n![](https://user-images.githubusercontent.com/35097187/44019049-3dc1ee1e-9f10-11e8-89f3-14dac608ea42.png)\n\n**为什么使用Loader？**\n```xml\n1. Loaders确保所有的cursor操作是异步的，从而排除了UI线程中堵塞的可能性。\n2. 当通过LoaderManager来管理，Loaders还可以在activity实例中保持当前的cursor数据，也就是不需要重新查询（比如，当因为横竖屏切换需要重新启动activity时）。\n3. 当数据改变时，Loaders可以自动检测底层数据的更新和重新检索。\n```\n\n**数据加载流程概览：**\n\n![](https://user-images.githubusercontent.com/35097187/44019046-3d7130f0-9f10-11e8-945c-7a0eff02b65c.png)\n\n**流程具体分析：**\n\n先上图：\n![](https://user-images.githubusercontent.com/35097187/44019033-3ba1bba0-9f10-11e8-94f9-e41053c967b4.jpeg)\n\n进入Contacts应用，程序的主入口Activity是`PeopleActivity`。\n\n进入`onCreate`方法：\n\n`createViewsAndFragments(savedState);`\n\n此方法创建视图和Fragments，进入此方法：\n\n```java\nmFavoritesFragment = new ContactTileListFragment();\nmAllFragment = new DefaultContactBrowseListFragment();\nmGroupsFragment = new GroupBrowseListFragment();\n```\n\n发现创建了3个Fragment，分别是 收藏联系人列表、所有联系人列表、群组列表。\n\n进入`DefaultContactBrowseListFragment`：\n\n发现`DefaultContactBrowseListFragment`的祖父类是：\n\n`ContactEntryListFragment<T extends ContactEntryListAdapter>`\n\n首先分析此基类：\n\n发现此基类实现了`LoadManager`接口，实现了该接口3个重要的抽象方法：\n\n```java\npublic Loader<D> onCreateLoader(int id, Bundle args);//创建Loader\npublic void onLoadFinished(Loader<D> loader, D data);//数据加载完毕后的回调方法\npublic void onLoaderReset(Loader<D> loader);//数据重新加载\n```\n\n该类同时提供了重要的抽象方法：\n\n```java\nprotected abstract T createListAdapter();//创建适配器Adapter类。\n```\n\n这意味着,子类可以按需求创造自己的适配器Adapter类,完成各个子界面Listview的数据显示，如3.1节图1所示。\n\n然后回到`DefaultContactBrowseListFragment`类：\n\n在执行`onCreateView`之前，会执行父类的一些方法，顺序如下：\n\n```java\nonAttach()\nsetContext(activity);\nsetLoaderManager(super.getLoaderManager());\n```\n\n`setLoaderManager`中设置当前的LoaderManager实现类。 \n\n加载联系人列表数据的过程中，这个类是`ProfileandContactsLoader`。\n\n之后执行`onCreate`方法。\n\n进入`DefaultContactBrowseListFragment`的`onCreate(Bundle)`方法：\n\n```java\nmAdapter = createListAdapter();\n```\n\n发现在这里创建了`ListAdapter`：\n\n```java\nDefaultContactListAdapter adapter = \nnew DefaultContactListAdapter(getContext());\n```\n\n可以知道创建的`ListAdapter`类型是`DefaultContactListAdapter`并返回到`DefaultContactBrowseListFragment`类。\n\n执行完`onCreate`方法之后，\n\n执行`DefaultContactBrowseListFragment`的`onCreateView`方法。\n\n进入DefaultContactBrowseListFragment的onCreateView方法：\n\n```java\nmListView = (ListView)mView.findViewById(android.R.id.list);\nmListView.setAdapter(mAdapter);\n```\n\n首先获取了ListView用以填充联系人数据，然后设置了适配器，但是此时适配器中的数据是空的，直到后面才会加载数据更新UI。\n在`onCreateView`方法执行完之后，在UI可见之前回调执行`Activity`的`onStart`方法。\n\n进入`DefaultContactBrowseListFragment`的`onStart`方法：\n\n```java\nmContactsPrefs.registerChangeListener(mPreferencesChangeListener);\nstartLoading();\n```\n\n首先注册了一个`ContentObserv`e的子类监听数据变化。\n然后执行`startLoading`方法，**目测这应当就是开始加载数据的方法了！**\n\n进入`DefaultContactBrowseListFragment`的`startLoading`方法：\n\n```java\nint partitionCount = mAdapter.getPartitionCount();\nfor (int i = 0; i < partitionCount; i++) {\n……\nPartition partition = mAdapter.getPartition(i);\nstartLoadingDirectoryPartition(i);\n……}\n```\n\n`Partition`这个类持有一个`Cursor`对象，用来存储数据。\n`Adapter`持有的`Partition`，`Partition`类代表了当前需要加载的`Directory`，可以理解为一个联系人集合，比如说本地联系人、Google联系人……这里我们假设只加载本地联系人数据，所以`partitionCount=1`。\n\n从这里我们可以做出猜测：\n联系人数据不是想象中的分页（每次N条联系人数据）加载，也不是说一次性全部加载，而是一个账户一个账户加载联系人数据，加载完毕一个账户就在uI刷新并显示数据。\n\n进入`DefaultContactBrowseListFragment`的`startLoadingDirectoryPartition`方法：\n\n```java\nloadDirectoryPartition(partitionIndex, partition);\n```\n\n进入此方法：\n\n```java\ngetLoaderManager().restartLoader(partitionIndex, args, this);\n```\n\n这个方法是LoaderManager实现类的方法，参照文档解释：\n\n>这个方法会新建/重启一个当前LoaderManager中的Loader，将回调方法注册给他，并开始加载数据。也就是说会回调LoaderManager的onCreateLoader()方法。\n>Starts a new or restarts an existing android.content.Loader in this manager, registers the callbacks to it, and (if the activity/fragment is currently started) starts loading it\n\n进入`LoadManager`接口的实现类：`LoaderManagerImpl`的`restartLoader`方法内部：\n\n```java\nLoaderInfo info = mLoaders.get(id);\nCreate info=\ncreateAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks<Object>)callback);\n//进入createAndInstallLoader方法：\nLoaderInfo info = createLoader(id, args, callback);\ninstallLoader(info);\n//进入createLoader方法：\nLoaderInfo info = new LoaderInfo(id, args,  (LoaderManager.LoaderCallbacks<Object>)callback);\nLoader<Object> loader = callback.onCreateLoader(id, args);\n//关键方法出现了！LoadManager接口的抽象方法的onCreateLoader方法被回调了！\n//然后installLoader方法启动了这个Loader！\ninfo.start();\n```\n\n进入`ContactEntryListFragment`的`onCreateLoader`方法，位于`DefaultContactBrowseListFragment`的祖父类`ContactEntryListFragment`中：\n\n```java\nCursorLoader loader = createCursorLoader(mContext);//创建Loader\nmAdapter.configureLoader(loader, directoryId);//配置Loader\n```\n\n发现在此方法中，首先调用`createCursorLoader`方法创建了`Loader`。\n然后通过`configureLoader`方法配置`Loader`的`query`方法的查询参数，也就是配置SQL中select查询语句的参数。\n这也同时意味着，`ContactEntryListFragment`类的子类们可以重写`createCursorLoader`方法以提供适合自身的Loader，重写`configureLoader`方法为Loader配置合适的参数，适配各种自定义的查询获取数据。\n\n观察`createCursorLoader`方法在`DefaultContactBrowseListFragment`类中实现：\n\n```java\nreturn new ProfileAndContactsLoader(context);\n```\n\n直接返回了`DefaultContactBrowseListFragment`的数据加载器：`ProfileAndContactsLoader`\n这就是`DefaultContactBrowseListFragment`的Loader实现类（数据加载器）。\n\n然后再看一下`ProfileAndContactsLoader`类是如何加载数据的呢？\n发现它继承自`CursorLoader`，而`CursorLoader`又继承自`AsyncTaskLoader<D>`\n在关键的`LoadBackGround()`方法中：\n异步调用了ContentResolver的`query`方法：\n\n```java\nCursor cursor = getContext()\n.getContentResolver()\n.query(mUri, mProjection, mSelection,\n                    mSelectionArgs, mSortOrder, mCancellationSignal);\ncursor.registerContentObserver(mObserver);\n```\n\n通过这个Query方法，实现了对联系人数据的查询,返回Cursor数据。并绑定了数据监听器。\n\n\n那么问题来了\n\n```java\nquery(mUri, mProjection, mSelection,mSelectionArgs, mSortOrder, mCancellationSignal)\n```\n的这些参数那里指定的呢？\n`configureLoader`方法在`DefaultContactListAdapter`类中实现，实现了对`query`参数的配置：\n\n```java\nconfigureUri(loader, directoryId, filter);\nloader.setProjection(getProjection(false));\nconfigureSelection(loader, directoryId, filter);\nloader.setSortOrder(sortOrder);\n```\n\n可以看到，配置了Loader主要的几个参数：Uri，Projection，Selection，SortOrder。\n这些参数用于最后和ContactsProvider交互的方法Query方法中……\n\n最终查询`ContactsProvider2`的uri是：\n\n```xml\nUri：content://com.android.contacts/contacts?address_book_index_extras=true&directory=0\n```\n\n发现ContentProvider的服务类似一个网站，uri就是网址，而请求数据的方式类似使用Get方式获取数据。\n\n最后通过ContentProvider2构建的查询语句是这样的：\n\n```sql\nSELECT \n_id, display_name, agg_presence.mode AS contact_presence, \ncontacts_status_updates.status AS contact_status, photo_id, photo_thumb_uri, lookup, \nis_user_profile \nFROM view_contacts \nLEFT OUTER JOIN agg_presence ON (_id = agg_presence.presence_contact_id) LEFT OUTER JOIN \nstatus_updates contacts_status_updates ON\n(status_update_id=contacts_status_updates.status_update_data_id)\n```\n可以发现最后通过ContactsProvider2实现的查询，并不是直接查询相关的表（Contacts表、rawcontacts表，data表……），而是直接查询`view_contacts`视图，因为这样会有更加高的效率。\n这也就意味着如果想给联系人数据库新增一个字段供界面使用，仅修改对应的表结构是不行，还要修改对应的视图才能得到想要的效果。\n\n\n查询完毕后，回调`LoaderManager`的`onLoadFinished`方法，完成对UI界面的更新：\n\n```java\nonPartitionLoaded(loaderId, data);\n```\n\n接着进入`onPartitionLoaded`方法：\n\n```java\nmAdapter.changeCursor(partitionIndex, data);\n```\n\n进入这个`changeCursor`方法：\n\n```java\nmPartitions[partition].cursor = cursor;\nnotifyDataSetChanged();\n```\n\n发现在这里改变了`Adapter`的数据集`Cursor`，并发出通知数据已经改变，UI进行更新。\n\n至此，默认联系人数据的显示分析到此结束。\n\n其他`Fragment`的数据填充基本仍然类似此流程，所不同的只是各自的`Fragment`、`Adapter`、`CursorLoader`以及`CursorLoader`配置的参数（uri，projection,selection,args,order……）有所不同。\n\n可以参考下表：\n\n| Fragment | Adapter | CursorLoader |\n| :------: | :------: | :------: |\n|DefaultContactBrowseListFragment(默认联系人列表)|DefaultContactListAdapter|ProfileAndContactsLoader|\n|ContactTitleListFragment(收藏联系人列表)|ContactTileAdapter|ContactTileLoaderFactory StarredLoader|\n|ContactTitleFrequentFragment(常用联系人列表)|ContactTitleAdapter|ContactTileLoaderFactory FrequentLoader|\n|GroupBrowseListFragment(群组列表)|GroupBrowseLIstAdapter|GroupListLoader|\n|GroupDetailFragment(指定ID群组的联系人列表)|GroupMemberTileAdapter|GroupMemberLoader|\n|ContactDetailFragment(指定ID联系人信息)|ViewAdapter|ContactLoader| \n\n#### 3.1.2 联系人详细信息数据的显示 ####\n**关键类：**\n```java\nContactDetailActivity\n\nContactDetailFragment  \n\nContactLoaderFragment //不可见 负责加载联系人详细数据，集成LoadManager对象。\n\nContactLoader   //联系人详细信息Loader。\n\nContactDetailLayoutController     //布局控制类。\n```\n\n原理类似列表显示，如下简要说明： \n```xml\n* ContactLoaderFragment类创建了一个实现LoaderManager.LoaderCallbacks<Contact>接口的对象，数据类型指定为Contacts。负责创建、管理ContactLoader。\n \n* 得到当前用户选择的联系人URI，配置对应的ContactLoader。 \n\n* 后台数据查询完毕后，回调LoadManager的onLoadFinished()方法，并将数据以Contacts的数据类型返回，然后回调ContactDetailLoaderFragmentListener的onDetailsLoaded()方法。 \n\n* onDetailsLoaded()方法中，新开一个线程，通过ContactDetailLayoutController类的setContactData(Conatct)设置数据，刷新ContactDetailFragment。\n```\n\n### 3.2 联系人数据的编辑和存储\n\n#### 3.2.1 编辑界面相关####\n\n联系人数据所属的账号不同，加载的UI也是不同的，比如Sim卡联系人一般只有name，phone num，但是本地账号联系人可能就会有email，\n\naddress，website等信息…… \n\n联系人数据UI的加载是通过代码动态加载的，而不是xml文件写死的。\n\n那么问题来了， \n\n新建联系人的界面是如何设计？ \n\n![](https://user-images.githubusercontent.com/35097187/44019034-3bc9de0a-9f10-11e8-8f38-f764c64cc8e2.jpeg)\n\n先进入新建联系人界面：\n\n主界面`PeopleActivity`中点击新建联系人Button，触发`onOptionsItemSelected`方法中的\n\ncase R.id.menu_add_contact分支： \n\n执行`startActivity(intent);` \n\n`startActivity`启动Intent，Intent的Action设置为android.intent.action.INSERT \n\n找到匹配此Action的Activity：`ContactEditorActivity`\n\n`ContactEditorActivity`的布局文件：\n \n`ContactEditorActivity`的`onCreate()`方法中找到布局： \n\n`setContentView(R.layout.contact_editor_activity);`\n\n在xml文件中找到这个布局：\n\n```xml\n<FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n <fragment class=\"com.android.contacts.editor.ContactEditorFragment\"\n            android:id=\"@+id/contact_editor_fragment\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\" />\n</FrameLayout>\n```\n\n只包含一个Fragment：`ContactEditorFragment`。程序解析Xml文件到这里就会执行`ContactEditorFragment`类。\n\n进入`ContactEditorFragment`的`onCreateView`方法：\n\n```xml\n//展开布局 \nfinal View view\n= inflater.inflate(R.layout.contact_editor_fragment, container, false);    \n//找到布局中的一个线性布局\n//关键的布局是contact_editor_fragment中的一个iD为editors的线性布局！\nmContent = (LinearLayout) view.findViewById(R.id.editors);\n```\n\n找到`contact_editor_fragment`：\n\n```xml\n<ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:fillViewport=\"true\"\n    android:fadingEdge=\"none\"\n    android:background=\"@color/background_primary\"\n>\n    <LinearLayout android:id=\"@+id/editors\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\"\n    />\n</ScrollView>\n```\n\n于是确认`ContactEditorFragment`的根布局就是一个id为`editors`的LinearLayout。 \n想到上一步的语句：\n\n```xml\nmContent = (LinearLayout) view.findViewById(R.id.editors);\n```\n\n所以关键就在于，接下来在代码中为mContent这个线性布局动态添加地了什么UI，而这些UI才是真正显示的东西。\n\n`ContactEditorFragment`的`onCreateView`方法执行完毕之后，会调用`onActivityCreate()`方法：\n\n```java\nif (Intent.ACTION_INSERT.equals(mAction)) {\nfinal Account account = mIntentExtras == null ? null : (Account) \nmIntentExtbindEditorsForNewContactras.getParcelable(Intents.Insert.ACCOUNT);\nfinal String dataSet = mIntentExtras == null ? null :\n                        mIntentExtras.getString(Intents.Insert.DATA_SET);\nif (account != null) {\n// Account specified in Intent\ncreateContact(new AccountWithDataSet(account.name, account.type, dataSet));\n}\n```\n\n上面代码首先取出了当前Account信息，数据信息。封装为一个`AccountWithDataSet`对象，作为`createContact`方法的参数。之前我们分析过，编辑界面和账户是高度相关的，所以对UI的动态操作必然和Account对象相关。进入`createContact`方法。\n\n看一下`ContactEditorFragment`中的`createContact()`到底对界面干了什么！！ \n\n`createContact`方法中调用了`bindEditorsForNewContact(account, accountType)`: \n\n关键代码：\n```java\n……\nfinal RawContact rawContact = new RawContact();\nif (newAccount != null) {\n    rawContact.setAccount(newAccount);\n} else {\n    rawContact.setAccountToLocal();\n}\nfinal ValuesDelta valuesDelta = ValuesDelta.fromAfter(rawContact.getValues());\nfinal RawContactDelta insert = new RawContactDelta(valuesDelta);\n……\nmState.add(insert);\nbindEditors();\n```\n\n发现暂时还是没有对界面做什么事情，任然处于酝酿阶段……\n\n首先使用传入的Accout对象创建一个`RawContact`对象，然后使用`RawContact`对象构建了一个`RawContactDelta`对象insert，接着就将insert对象放入`RawContactDeltaList` 对象`mState`中。\n\n```xml\nRawContact类：raw contacts数据表内的一条数据，表示一个联系人某一特定帐户的信息。存储Data表中一些数据行（电话号码、Email、地址……）的集合及一些其他的信息。\n他的存储结构为： HashMap<String, ArrayList<ValuesDelta>>\n\nRawContactDelta类：包含RawContact对象（即一个联系人某一特定帐户的信息），并具有记录修改的功能。\n\nRawContactDeltaList类：内部的存储结构是ArrayList<RawContactDelta>，可以理解为 单个联系人所有账户的数据集合。\n```\n\n然后调用了`bindEditors()`法。 \n\n关键代码如下：\n```java\n……\nmContent.removeAllViews();\n……\nfinal BaseRawContactEditorView editor;\n……\neditor = (RawContactEditorView) inflater.inflate(R.layout.raw_contact_editor_view,mContent, false);\n//添加视图了……………………\nmContent.addView(editor);\n//为自定义视图BaseRawContactEditorView设置状态，必然是修改UI的操作！\neditor.setState(rawContactDelta, type, mViewIdGenerator, isEditingUserProfile());\n```\n\n可以看到，`mContent`这个LinearLayout添加的View是`editor`，而`editor`是一个自定义的视图`BaseRawContactEditorView`，布局是`R.layout.raw_contact_editor_view`。\n\n找到`raw_contact_editor_view`布局，发现该布局包含新建联系人页面所有的UI：\n\n![](https://user-images.githubusercontent.com/35097187/44019036-3bf3c4ae-9f10-11e8-81b0-dfa54fe8fad9.jpeg) \n\n```xml\n<com.android.contacts.editor.RawContactEditorView\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\"\n    android:paddingTop=\"@dimen/editor_padding_top\">\n<include\n用户账户相关UI\n        layout=\"@layout/editor_account_header_with_dropdown\" />\n    <LinearLayout\n        android:id=\"@+id/body\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\">\n        <LinearLayout\n            android:layout_height=\"wrap_content\"\n            android:layout_width=\"match_parent\"\n            android:orientation=\"horizontal\"\n            android:paddingTop=\"8dip\">\n            <LinearLayout\n                android:layout_height=\"wrap_content\"\n                android:layout_width=\"0dip\"\n                android:layout_weight=\"1\"\n                android:orientation=\"vertical\">\n                <include\n            Name相关的UI\n                    android:id=\"@+id/edit_name\"\n                    layout=\"@layout/structured_name_editor_view\" />\n                <include\n            拼音名\n                    android:id=\"@+id/edit_phonetic_name\"\n                    layout=\"@layout/phonetic_name_editor_view\" />\n            </LinearLayout>\n            <include\n            照片相关的UI\n                android:id=\"@+id/edit_photo\"\n                android:layout_marginRight=\"8dip\"\n                android:layout_marginEnd=\"8dip\"\n                layout=\"@layout/item_photo_editor\" />\n        </LinearLayout>\n        <LinearLayout\n            中间部分Item的显示在此处\n            android:id=\"@+id/sect_fields\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"vertical\"\n            android:layout_marginBottom=\"16dip\"/>\n            添加其他字段 按钮\n        <Button\n            android:id=\"@+id/button_add_field\"\n            android:text=\"@string/add_field\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_gravity=\"center\"\n            android:layout_marginBottom=\"32dip\"/>\n    </LinearLayout>\n</com.android.contacts.editor.RawContactEditorView>\n```\n\n1.那么问题来了：中间的那部分布局（电话、地址……）去哪儿了？\n\n搜索有可能包含这些内容的线性布局`sect_fields`，发现在`RawContactEditorView`类中初始化为`mFields`：\n\n`mFields = (ViewGroup)findViewById(R.id.sect_fields);`\n\n那么只需要看代码中对mFields添加了什么UI！\n\n2.回到之前的`bindEditors()`方法，`RawContactEditorView` 对象`editor`从xml中解析完成后，执行了`setState`方法：\n\n```java\neditor.setState(rawContactDelta, type, mViewIdGenerator, isEditingUserProfile());\n```\n\n1.`进入RawContactEditorView`类，找到`setState`方法：\n\n```java\npublic void  setState(RawContactDelta state, AccountType type, ViewIdGenerator vig,boolean isProfile)\n……\n// 遍历当前账户所有可能的item种类，如电话，姓名，地址……，并分别创建自定义视图KindSectionView\n   for (DataKind kind : type.getSortedDataKinds()) {\n……\n  final KindSectionView section = (KindSectionView)mInflater.inflate(\n                        R.layout.item_kind_section, mFields, false);\n                section.setEnabled(isEnabled());\n                section.setState(kind, state, false, vig);\n                mFields.addView(section);\n……\n}\n```\n\n发现遍历了当前账号类型中所有可能的数据类型（`DataKind`），\n\n创建了相关的自定义视图`KindSectionView`对象`section`，\n\n再将`section`对象添加到`mFields`中显示，\n\n这个mFields正是之前在`RawContactEditorView`类中初始化的线性布局：\n```java\nmFields = (ViewGroup)findViewById(R.id.sect_fields)。\n```\n\n到这里，基本可以确定，中间部分（也就是除了Name、Photo 和底部的添加字段Button之外的部分），就是通过这个`mFields`动态的根据当前账户类型添加编辑的`KindSectionView`条目来填充的。\n\n首先观察一下`KindSectionView`的布局文件`item_kind_section`：\n\n```xml\n<com.android.contacts.editor.KindSectionView\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\">\n    <include                   这是一个TextView，title\n        android:id=\"@+id/kind_title_layout\"\n        layout=\"@layout/edit_kind_title\" />\n      <LinearLayout            线性布局，用于添加EditText\n        android:id=\"@+id/kind_editors\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\" />\n    <include                   添加新条目的TextView，初始化状态不可见\n        android:id=\"@+id/add_field_footer\"\n        layout=\"@layout/edit_add_field\" />\n</com.android.contacts.editor.KindSectionView>\n```\n\n1.`KindSectionView`加载完xml文件之后，会执行`onFinishInflate`方法：\n\n```java\nmTitle = (TextView) findViewById(R.id.kind_title);\nmEditors = (ViewGroup) findViewById(R.id.kind_editors); \nmAddFieldFooter = findViewById(R.id.add_field_footer);\n```\n\n把Xml文件中三个主要的部分都得到了，接下来重点就是观察代码中对他们做了什么。\n\n在第12步中，加载完xml文件之后，执行`KindSectionView`的`setState`方法：\n\n```java\nsection.setState(kind, state, false, vig);\n```\n\n将`rawContactDelta`对象`state`传递给了`KindSectionView`类的`setState`方法：\n\n进入`KindSectionView`类的`setState`方法：\n\n```java\nmKind = kind;\nmState = state;\nrebuildFromState();\n```\n\n先进行局部变量的赋值\n\n1.然后进入到`rebuildFromState()`方法：\n```java\n  for (ValuesDelta entry : mState.getMimeEntries(mKind.mimeType)) {\n       //……遍历当前账户可能的键值对，比如电话、Email、地址……\n      createEditorView(entry);  //这个方法应当是创建EditText的方法！\n  }\n```\n\n在这个方法中，对`mState`集合中所有Mime类型的`ValuesDelta`集合（`ArrayList<ValuesDelta>`类型）进行遍历，而后将每一个 `ValuesDelta`对象 `entry`作为参数调用了`createEditorView(entry)`也就是创建各个种类的`EditText`方法，根据`entry`对象创建相应的`EditText`！\n\n简单说，就是创建`mState`中存在的类型的`EditText`。\n当然……这还都只是猜测，需要进入`createEditorView`方法确认。\n\n1.进入`createEditorView`方法：\n\n```java\nview = mInflater.inflate(layoutResId, mEditors, false);\nEditor editor = (Editor) view;\neditor.setValues(mKind, entry, mState, mReadOnly, mViewIdGenerator);\n```\n\n第13步初始化的`mEditors`对象（也就是那个被猜测应该是放`EditText`的线性布局）在这里被使用！\n\n1.联系上下文，实际上此时editor对象是`TextFieldsEditorView`类的对象，进入`TextFieldsEditorView`的`setValues`方法，看看他是如何根据entry对象创建`EditText`的：\n\n```java\npublic void setValues(DataKind kind, ValuesDelta entry, RawContactDelta state, boolean readOnly,ViewIdGenerator vig) {\nint fieldCount = kind.fieldList.size();  //获取所有可能的datakind的总数\nfor (int index = 0; index < fieldCount; index++)    //遍历所有可能的datakind，\n{ \nfinal EditText fieldView = new EditText(mContext);  //创建EditText对象，之后进行配置\nfieldView.setLayoutParams……\nfieldView.setTextAppearance(getContext(), android.R.style.TextAppearance_Medium);\nfieldView.setHint(field.titleRes);   //EditText的Hint\n……     \n\nfieldView.addTextChangedListener(new TextWatcher()  //注册TextChangedListener\n{\n\t@Override\n\tpublic void afterTextChanged(Editable s) {\n\t    // Trigger event for newly changed value\n\t    onFieldChanged(column, s.toString());\n\t}\n\tmFields.addView(fieldView);    //将EditText添加到当前的线性布局中！\n}\n```\n注释基本解释了如何通过一个`ValuesDelta`（理解为键值对集合）对象`entry`创建布局中的所有`EditText`。\n\n至此，联系人编辑界面的显示原理基本分析完成。\n\n\n数据存储相关\n\n### 3.3 Sim联系人数据的整合\nSim卡联系人数据的显示\n开机自动导入Sim卡联系人\ntelephony中IccProvider浅析\nSim卡联系人的手动导入导出\n\n### 3.4 SD卡备份/恢复联系人\n- SD卡备份/恢复联系人\n- 联系人数据导出到SD卡\n\n### 3.5 联系人搜索\n\n### 3.6 Google联系人同步\n\n### 3.7 其他零碎功能\n\n转自：https://blog.csdn.net/Kafka_88/article/details/50670406\n\n","slug":"contacts-source-structure-analysis","published":1,"updated":"2018-08-19T10:06:01.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwhm0000rmujkaoaj1pk","content":"<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h2><p>联系人模块主要记录用户的联系人数据，方便用户快捷的操作和使用，主要包括本机联系人和Sim卡联系人。</p>\n<p>本机联系人主要存储在手机内部存储空间，Android平台上是通过数据库进行存储，使用ContentProvider组件封装，提供复杂的字段用于表示联系人数据，并提供用户快捷的操作，比如增加，删除，修改，查询等等。</p>\n<p>Sim卡联系人主要存储在Sim卡内部存储文件，包括adn、fdn、sdn。主要提供简单的字段用于表示联系人数据。并通过IccProvider提供的接口进行数据的增加、删除、修改、查询操作。</p>\n<h2 id=\"2-软件架构\"><a href=\"#2-软件架构\" class=\"headerlink\" title=\"2.软件架构\"></a>2.软件架构</h2><p>联系人Contacts应用主要包括3个部分:<br>Contacts主要响应用户的请求和交互，数据显示。<br>ContactsProvider继承自Android四大组件之一的ContentProvider组件，封装了对底层数据库contact2.db的添删改查。<br>SQLite在底层物理性地存储了联系人数据。</p>\n<p>主要交互流程如下图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019032-3b7392de-9f10-11e8-8567-d4189730b46e.png\" alt=\"\"></p>\n<p>Contacts模块的主要7块功能：</p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019045-3d496fe8-9f10-11e8-8077-89235449ccd4.png\" alt=\"\"></p>\n<h2 id=\"3-各功能模块分析\"><a href=\"#3-各功能模块分析\" class=\"headerlink\" title=\"3. 各功能模块分析\"></a>3. 各功能模块分析</h2><h3 id=\"3-1-联系人数据的显示\"><a href=\"#3-1-联系人数据的显示\" class=\"headerlink\" title=\"3.1 联系人数据的显示\"></a>3.1 联系人数据的显示</h3><h4 id=\"3-1-1-联系人列表显示\"><a href=\"#3-1-1-联系人列表显示\" class=\"headerlink\" title=\"3.1.1 联系人列表显示\"></a>3.1.1 联系人列表显示</h4><p><code>简要说明：</code></p>\n<pre><code class=\"xml\">* PeopleActivity类负责联系人列表的显示。\n\n* PeopleActivity包含4个Fragment，每个Fragment包含一个ListView。\n\n* 各个Fragment中ListView的Adapter（BaseAdapter的子类）负责将数据填充到ListView。\n\n* 各个Fragment的Loader类（CursorLoader的子类）负责加载数据。\n\n* 实现LoadertManager接口负责管理这些CursorLoader。\n</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019049-3dc1ee1e-9f10-11e8-89f3-14dac608ea42.png\" alt=\"\"></p>\n<p><strong>为什么使用Loader？</strong></p>\n<pre><code class=\"xml\">1. Loaders确保所有的cursor操作是异步的，从而排除了UI线程中堵塞的可能性。\n2. 当通过LoaderManager来管理，Loaders还可以在activity实例中保持当前的cursor数据，也就是不需要重新查询（比如，当因为横竖屏切换需要重新启动activity时）。\n3. 当数据改变时，Loaders可以自动检测底层数据的更新和重新检索。\n</code></pre>\n<p><strong>数据加载流程概览：</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019046-3d7130f0-9f10-11e8-945c-7a0eff02b65c.png\" alt=\"\"></p>\n<p><strong>流程具体分析：</strong></p>\n<p>先上图：<br><img src=\"https://user-images.githubusercontent.com/35097187/44019033-3ba1bba0-9f10-11e8-94f9-e41053c967b4.jpeg\" alt=\"\"></p>\n<p>进入Contacts应用，程序的主入口Activity是<code>PeopleActivity</code>。</p>\n<p>进入<code>onCreate</code>方法：</p>\n<p><code>createViewsAndFragments(savedState);</code></p>\n<p>此方法创建视图和Fragments，进入此方法：</p>\n<pre><code class=\"java\">mFavoritesFragment = new ContactTileListFragment();\nmAllFragment = new DefaultContactBrowseListFragment();\nmGroupsFragment = new GroupBrowseListFragment();\n</code></pre>\n<p>发现创建了3个Fragment，分别是 收藏联系人列表、所有联系人列表、群组列表。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>：</p>\n<p>发现<code>DefaultContactBrowseListFragment</code>的祖父类是：</p>\n<p><code>ContactEntryListFragment&lt;T extends ContactEntryListAdapter&gt;</code></p>\n<p>首先分析此基类：</p>\n<p>发现此基类实现了<code>LoadManager</code>接口，实现了该接口3个重要的抽象方法：</p>\n<pre><code class=\"java\">public Loader&lt;D&gt; onCreateLoader(int id, Bundle args);//创建Loader\npublic void onLoadFinished(Loader&lt;D&gt; loader, D data);//数据加载完毕后的回调方法\npublic void onLoaderReset(Loader&lt;D&gt; loader);//数据重新加载\n</code></pre>\n<p>该类同时提供了重要的抽象方法：</p>\n<pre><code class=\"java\">protected abstract T createListAdapter();//创建适配器Adapter类。\n</code></pre>\n<p>这意味着,子类可以按需求创造自己的适配器Adapter类,完成各个子界面Listview的数据显示，如3.1节图1所示。</p>\n<p>然后回到<code>DefaultContactBrowseListFragment</code>类：</p>\n<p>在执行<code>onCreateView</code>之前，会执行父类的一些方法，顺序如下：</p>\n<pre><code class=\"java\">onAttach()\nsetContext(activity);\nsetLoaderManager(super.getLoaderManager());\n</code></pre>\n<p><code>setLoaderManager</code>中设置当前的LoaderManager实现类。 </p>\n<p>加载联系人列表数据的过程中，这个类是<code>ProfileandContactsLoader</code>。</p>\n<p>之后执行<code>onCreate</code>方法。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>onCreate(Bundle)</code>方法：</p>\n<pre><code class=\"java\">mAdapter = createListAdapter();\n</code></pre>\n<p>发现在这里创建了<code>ListAdapter</code>：</p>\n<pre><code class=\"java\">DefaultContactListAdapter adapter = \nnew DefaultContactListAdapter(getContext());\n</code></pre>\n<p>可以知道创建的<code>ListAdapter</code>类型是<code>DefaultContactListAdapter</code>并返回到<code>DefaultContactBrowseListFragment</code>类。</p>\n<p>执行完<code>onCreate</code>方法之后，</p>\n<p>执行<code>DefaultContactBrowseListFragment</code>的<code>onCreateView</code>方法。</p>\n<p>进入DefaultContactBrowseListFragment的onCreateView方法：</p>\n<pre><code class=\"java\">mListView = (ListView)mView.findViewById(android.R.id.list);\nmListView.setAdapter(mAdapter);\n</code></pre>\n<p>首先获取了ListView用以填充联系人数据，然后设置了适配器，但是此时适配器中的数据是空的，直到后面才会加载数据更新UI。<br>在<code>onCreateView</code>方法执行完之后，在UI可见之前回调执行<code>Activity</code>的<code>onStart</code>方法。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>onStart</code>方法：</p>\n<pre><code class=\"java\">mContactsPrefs.registerChangeListener(mPreferencesChangeListener);\nstartLoading();\n</code></pre>\n<p>首先注册了一个<code>ContentObserv</code>e的子类监听数据变化。<br>然后执行<code>startLoading</code>方法，<strong>目测这应当就是开始加载数据的方法了！</strong></p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>startLoading</code>方法：</p>\n<pre><code class=\"java\">int partitionCount = mAdapter.getPartitionCount();\nfor (int i = 0; i &lt; partitionCount; i++) {\n……\nPartition partition = mAdapter.getPartition(i);\nstartLoadingDirectoryPartition(i);\n……}\n</code></pre>\n<p><code>Partition</code>这个类持有一个<code>Cursor</code>对象，用来存储数据。<br><code>Adapter</code>持有的<code>Partition</code>，<code>Partition</code>类代表了当前需要加载的<code>Directory</code>，可以理解为一个联系人集合，比如说本地联系人、Google联系人……这里我们假设只加载本地联系人数据，所以<code>partitionCount=1</code>。</p>\n<p>从这里我们可以做出猜测：<br>联系人数据不是想象中的分页（每次N条联系人数据）加载，也不是说一次性全部加载，而是一个账户一个账户加载联系人数据，加载完毕一个账户就在uI刷新并显示数据。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>startLoadingDirectoryPartition</code>方法：</p>\n<pre><code class=\"java\">loadDirectoryPartition(partitionIndex, partition);\n</code></pre>\n<p>进入此方法：</p>\n<pre><code class=\"java\">getLoaderManager().restartLoader(partitionIndex, args, this);\n</code></pre>\n<p>这个方法是LoaderManager实现类的方法，参照文档解释：</p>\n<blockquote>\n<p>这个方法会新建/重启一个当前LoaderManager中的Loader，将回调方法注册给他，并开始加载数据。也就是说会回调LoaderManager的onCreateLoader()方法。<br>Starts a new or restarts an existing android.content.Loader in this manager, registers the callbacks to it, and (if the activity/fragment is currently started) starts loading it</p>\n</blockquote>\n<p>进入<code>LoadManager</code>接口的实现类：<code>LoaderManagerImpl</code>的<code>restartLoader</code>方法内部：</p>\n<pre><code class=\"java\">LoaderInfo info = mLoaders.get(id);\nCreate info=\ncreateAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);\n//进入createAndInstallLoader方法：\nLoaderInfo info = createLoader(id, args, callback);\ninstallLoader(info);\n//进入createLoader方法：\nLoaderInfo info = new LoaderInfo(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);\nLoader&lt;Object&gt; loader = callback.onCreateLoader(id, args);\n//关键方法出现了！LoadManager接口的抽象方法的onCreateLoader方法被回调了！\n//然后installLoader方法启动了这个Loader！\ninfo.start();\n</code></pre>\n<p>进入<code>ContactEntryListFragment</code>的<code>onCreateLoader</code>方法，位于<code>DefaultContactBrowseListFragment</code>的祖父类<code>ContactEntryListFragment</code>中：</p>\n<pre><code class=\"java\">CursorLoader loader = createCursorLoader(mContext);//创建Loader\nmAdapter.configureLoader(loader, directoryId);//配置Loader\n</code></pre>\n<p>发现在此方法中，首先调用<code>createCursorLoader</code>方法创建了<code>Loader</code>。<br>然后通过<code>configureLoader</code>方法配置<code>Loader</code>的<code>query</code>方法的查询参数，也就是配置SQL中select查询语句的参数。<br>这也同时意味着，<code>ContactEntryListFragment</code>类的子类们可以重写<code>createCursorLoader</code>方法以提供适合自身的Loader，重写<code>configureLoader</code>方法为Loader配置合适的参数，适配各种自定义的查询获取数据。</p>\n<p>观察<code>createCursorLoader</code>方法在<code>DefaultContactBrowseListFragment</code>类中实现：</p>\n<pre><code class=\"java\">return new ProfileAndContactsLoader(context);\n</code></pre>\n<p>直接返回了<code>DefaultContactBrowseListFragment</code>的数据加载器：<code>ProfileAndContactsLoader</code><br>这就是<code>DefaultContactBrowseListFragment</code>的Loader实现类（数据加载器）。</p>\n<p>然后再看一下<code>ProfileAndContactsLoader</code>类是如何加载数据的呢？<br>发现它继承自<code>CursorLoader</code>，而<code>CursorLoader</code>又继承自<code>AsyncTaskLoader&lt;D&gt;</code><br>在关键的<code>LoadBackGround()</code>方法中：<br>异步调用了ContentResolver的<code>query</code>方法：</p>\n<pre><code class=\"java\">Cursor cursor = getContext()\n.getContentResolver()\n.query(mUri, mProjection, mSelection,\n                    mSelectionArgs, mSortOrder, mCancellationSignal);\ncursor.registerContentObserver(mObserver);\n</code></pre>\n<p>通过这个Query方法，实现了对联系人数据的查询,返回Cursor数据。并绑定了数据监听器。</p>\n<p>那么问题来了</p>\n<pre><code class=\"java\">query(mUri, mProjection, mSelection,mSelectionArgs, mSortOrder, mCancellationSignal)\n</code></pre>\n<p>的这些参数那里指定的呢？<br><code>configureLoader</code>方法在<code>DefaultContactListAdapter</code>类中实现，实现了对<code>query</code>参数的配置：</p>\n<pre><code class=\"java\">configureUri(loader, directoryId, filter);\nloader.setProjection(getProjection(false));\nconfigureSelection(loader, directoryId, filter);\nloader.setSortOrder(sortOrder);\n</code></pre>\n<p>可以看到，配置了Loader主要的几个参数：Uri，Projection，Selection，SortOrder。<br>这些参数用于最后和ContactsProvider交互的方法Query方法中……</p>\n<p>最终查询<code>ContactsProvider2</code>的uri是：</p>\n<pre><code class=\"xml\">Uri：content://com.android.contacts/contacts?address_book_index_extras=true&amp;directory=0\n</code></pre>\n<p>发现ContentProvider的服务类似一个网站，uri就是网址，而请求数据的方式类似使用Get方式获取数据。</p>\n<p>最后通过ContentProvider2构建的查询语句是这样的：</p>\n<pre><code class=\"sql\">SELECT \n_id, display_name, agg_presence.mode AS contact_presence, \ncontacts_status_updates.status AS contact_status, photo_id, photo_thumb_uri, lookup, \nis_user_profile \nFROM view_contacts \nLEFT OUTER JOIN agg_presence ON (_id = agg_presence.presence_contact_id) LEFT OUTER JOIN \nstatus_updates contacts_status_updates ON\n(status_update_id=contacts_status_updates.status_update_data_id)\n</code></pre>\n<p>可以发现最后通过ContactsProvider2实现的查询，并不是直接查询相关的表（Contacts表、rawcontacts表，data表……），而是直接查询<code>view_contacts</code>视图，因为这样会有更加高的效率。<br>这也就意味着如果想给联系人数据库新增一个字段供界面使用，仅修改对应的表结构是不行，还要修改对应的视图才能得到想要的效果。</p>\n<p>查询完毕后，回调<code>LoaderManager</code>的<code>onLoadFinished</code>方法，完成对UI界面的更新：</p>\n<pre><code class=\"java\">onPartitionLoaded(loaderId, data);\n</code></pre>\n<p>接着进入<code>onPartitionLoaded</code>方法：</p>\n<pre><code class=\"java\">mAdapter.changeCursor(partitionIndex, data);\n</code></pre>\n<p>进入这个<code>changeCursor</code>方法：</p>\n<pre><code class=\"java\">mPartitions[partition].cursor = cursor;\nnotifyDataSetChanged();\n</code></pre>\n<p>发现在这里改变了<code>Adapter</code>的数据集<code>Cursor</code>，并发出通知数据已经改变，UI进行更新。</p>\n<p>至此，默认联系人数据的显示分析到此结束。</p>\n<p>其他<code>Fragment</code>的数据填充基本仍然类似此流程，所不同的只是各自的<code>Fragment</code>、<code>Adapter</code>、<code>CursorLoader</code>以及<code>CursorLoader</code>配置的参数（uri，projection,selection,args,order……）有所不同。</p>\n<p>可以参考下表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Fragment</th>\n<th style=\"text-align:center\">Adapter</th>\n<th style=\"text-align:center\">CursorLoader</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">DefaultContactBrowseListFragment(默认联系人列表)</td>\n<td style=\"text-align:center\">DefaultContactListAdapter</td>\n<td style=\"text-align:center\">ProfileAndContactsLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ContactTitleListFragment(收藏联系人列表)</td>\n<td style=\"text-align:center\">ContactTileAdapter</td>\n<td style=\"text-align:center\">ContactTileLoaderFactory StarredLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ContactTitleFrequentFragment(常用联系人列表)</td>\n<td style=\"text-align:center\">ContactTitleAdapter</td>\n<td style=\"text-align:center\">ContactTileLoaderFactory FrequentLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GroupBrowseListFragment(群组列表)</td>\n<td style=\"text-align:center\">GroupBrowseLIstAdapter</td>\n<td style=\"text-align:center\">GroupListLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GroupDetailFragment(指定ID群组的联系人列表)</td>\n<td style=\"text-align:center\">GroupMemberTileAdapter</td>\n<td style=\"text-align:center\">GroupMemberLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ContactDetailFragment(指定ID联系人信息)</td>\n<td style=\"text-align:center\">ViewAdapter</td>\n<td style=\"text-align:center\">ContactLoader</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-1-2-联系人详细信息数据的显示\"><a href=\"#3-1-2-联系人详细信息数据的显示\" class=\"headerlink\" title=\"3.1.2 联系人详细信息数据的显示\"></a>3.1.2 联系人详细信息数据的显示</h4><p><strong>关键类：</strong></p>\n<pre><code class=\"java\">ContactDetailActivity\n\nContactDetailFragment  \n\nContactLoaderFragment //不可见 负责加载联系人详细数据，集成LoadManager对象。\n\nContactLoader   //联系人详细信息Loader。\n\nContactDetailLayoutController     //布局控制类。\n</code></pre>\n<p>原理类似列表显示，如下简要说明： </p>\n<pre><code class=\"xml\">* ContactLoaderFragment类创建了一个实现LoaderManager.LoaderCallbacks&lt;Contact&gt;接口的对象，数据类型指定为Contacts。负责创建、管理ContactLoader。\n\n* 得到当前用户选择的联系人URI，配置对应的ContactLoader。 \n\n* 后台数据查询完毕后，回调LoadManager的onLoadFinished()方法，并将数据以Contacts的数据类型返回，然后回调ContactDetailLoaderFragmentListener的onDetailsLoaded()方法。 \n\n* onDetailsLoaded()方法中，新开一个线程，通过ContactDetailLayoutController类的setContactData(Conatct)设置数据，刷新ContactDetailFragment。\n</code></pre>\n<h3 id=\"3-2-联系人数据的编辑和存储\"><a href=\"#3-2-联系人数据的编辑和存储\" class=\"headerlink\" title=\"3.2 联系人数据的编辑和存储\"></a>3.2 联系人数据的编辑和存储</h3><h4 id=\"3-2-1-编辑界面相关\"><a href=\"#3-2-1-编辑界面相关\" class=\"headerlink\" title=\"3.2.1 编辑界面相关\"></a>3.2.1 编辑界面相关</h4><p>联系人数据所属的账号不同，加载的UI也是不同的，比如Sim卡联系人一般只有name，phone num，但是本地账号联系人可能就会有email，</p>\n<p>address，website等信息…… </p>\n<p>联系人数据UI的加载是通过代码动态加载的，而不是xml文件写死的。</p>\n<p>那么问题来了， </p>\n<p>新建联系人的界面是如何设计？ </p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019034-3bc9de0a-9f10-11e8-8f38-f764c64cc8e2.jpeg\" alt=\"\"></p>\n<p>先进入新建联系人界面：</p>\n<p>主界面<code>PeopleActivity</code>中点击新建联系人Button，触发<code>onOptionsItemSelected</code>方法中的</p>\n<p>case R.id.menu_add_contact分支： </p>\n<p>执行<code>startActivity(intent);</code> </p>\n<p><code>startActivity</code>启动Intent，Intent的Action设置为android.intent.action.INSERT </p>\n<p>找到匹配此Action的Activity：<code>ContactEditorActivity</code></p>\n<p><code>ContactEditorActivity</code>的布局文件：</p>\n<p><code>ContactEditorActivity</code>的<code>onCreate()</code>方法中找到布局： </p>\n<p><code>setContentView(R.layout.contact_editor_activity);</code></p>\n<p>在xml文件中找到这个布局：</p>\n<pre><code class=\"xml\">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n &lt;fragment class=&quot;com.android.contacts.editor.ContactEditorFragment&quot;\n            android:id=&quot;@+id/contact_editor_fragment&quot;\n            android:layout_width=&quot;match_parent&quot;\n            android:layout_height=&quot;match_parent&quot; /&gt;\n&lt;/FrameLayout&gt;\n</code></pre>\n<p>只包含一个Fragment：<code>ContactEditorFragment</code>。程序解析Xml文件到这里就会执行<code>ContactEditorFragment</code>类。</p>\n<p>进入<code>ContactEditorFragment</code>的<code>onCreateView</code>方法：</p>\n<pre><code class=\"xml\">//展开布局 \nfinal View view\n= inflater.inflate(R.layout.contact_editor_fragment, container, false);    \n//找到布局中的一个线性布局\n//关键的布局是contact_editor_fragment中的一个iD为editors的线性布局！\nmContent = (LinearLayout) view.findViewById(R.id.editors);\n</code></pre>\n<p>找到<code>contact_editor_fragment</code>：</p>\n<pre><code class=\"xml\">&lt;ScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:fillViewport=&quot;true&quot;\n    android:fadingEdge=&quot;none&quot;\n    android:background=&quot;@color/background_primary&quot;\n&gt;\n    &lt;LinearLayout android:id=&quot;@+id/editors&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:orientation=&quot;vertical&quot;\n    /&gt;\n&lt;/ScrollView&gt;\n</code></pre>\n<p>于是确认<code>ContactEditorFragment</code>的根布局就是一个id为<code>editors</code>的LinearLayout。<br>想到上一步的语句：</p>\n<pre><code class=\"xml\">mContent = (LinearLayout) view.findViewById(R.id.editors);\n</code></pre>\n<p>所以关键就在于，接下来在代码中为mContent这个线性布局动态添加地了什么UI，而这些UI才是真正显示的东西。</p>\n<p><code>ContactEditorFragment</code>的<code>onCreateView</code>方法执行完毕之后，会调用<code>onActivityCreate()</code>方法：</p>\n<pre><code class=\"java\">if (Intent.ACTION_INSERT.equals(mAction)) {\nfinal Account account = mIntentExtras == null ? null : (Account) \nmIntentExtbindEditorsForNewContactras.getParcelable(Intents.Insert.ACCOUNT);\nfinal String dataSet = mIntentExtras == null ? null :\n                        mIntentExtras.getString(Intents.Insert.DATA_SET);\nif (account != null) {\n// Account specified in Intent\ncreateContact(new AccountWithDataSet(account.name, account.type, dataSet));\n}\n</code></pre>\n<p>上面代码首先取出了当前Account信息，数据信息。封装为一个<code>AccountWithDataSet</code>对象，作为<code>createContact</code>方法的参数。之前我们分析过，编辑界面和账户是高度相关的，所以对UI的动态操作必然和Account对象相关。进入<code>createContact</code>方法。</p>\n<p>看一下<code>ContactEditorFragment</code>中的<code>createContact()</code>到底对界面干了什么！！ </p>\n<p><code>createContact</code>方法中调用了<code>bindEditorsForNewContact(account, accountType)</code>: </p>\n<p>关键代码：</p>\n<pre><code class=\"java\">……\nfinal RawContact rawContact = new RawContact();\nif (newAccount != null) {\n    rawContact.setAccount(newAccount);\n} else {\n    rawContact.setAccountToLocal();\n}\nfinal ValuesDelta valuesDelta = ValuesDelta.fromAfter(rawContact.getValues());\nfinal RawContactDelta insert = new RawContactDelta(valuesDelta);\n……\nmState.add(insert);\nbindEditors();\n</code></pre>\n<p>发现暂时还是没有对界面做什么事情，任然处于酝酿阶段……</p>\n<p>首先使用传入的Accout对象创建一个<code>RawContact</code>对象，然后使用<code>RawContact</code>对象构建了一个<code>RawContactDelta</code>对象insert，接着就将insert对象放入<code>RawContactDeltaList</code> 对象<code>mState</code>中。</p>\n<pre><code class=\"xml\">RawContact类：raw contacts数据表内的一条数据，表示一个联系人某一特定帐户的信息。存储Data表中一些数据行（电话号码、Email、地址……）的集合及一些其他的信息。\n他的存储结构为： HashMap&lt;String, ArrayList&lt;ValuesDelta&gt;&gt;\n\nRawContactDelta类：包含RawContact对象（即一个联系人某一特定帐户的信息），并具有记录修改的功能。\n\nRawContactDeltaList类：内部的存储结构是ArrayList&lt;RawContactDelta&gt;，可以理解为 单个联系人所有账户的数据集合。\n</code></pre>\n<p>然后调用了<code>bindEditors()</code>法。 </p>\n<p>关键代码如下：</p>\n<pre><code class=\"java\">……\nmContent.removeAllViews();\n……\nfinal BaseRawContactEditorView editor;\n……\neditor = (RawContactEditorView) inflater.inflate(R.layout.raw_contact_editor_view,mContent, false);\n//添加视图了……………………\nmContent.addView(editor);\n//为自定义视图BaseRawContactEditorView设置状态，必然是修改UI的操作！\neditor.setState(rawContactDelta, type, mViewIdGenerator, isEditingUserProfile());\n</code></pre>\n<p>可以看到，<code>mContent</code>这个LinearLayout添加的View是<code>editor</code>，而<code>editor</code>是一个自定义的视图<code>BaseRawContactEditorView</code>，布局是<code>R.layout.raw_contact_editor_view</code>。</p>\n<p>找到<code>raw_contact_editor_view</code>布局，发现该布局包含新建联系人页面所有的UI：</p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019036-3bf3c4ae-9f10-11e8-81b0-dfa54fe8fad9.jpeg\" alt=\"\"> </p>\n<pre><code class=\"xml\">&lt;com.android.contacts.editor.RawContactEditorView\n    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:orientation=&quot;vertical&quot;\n    android:paddingTop=&quot;@dimen/editor_padding_top&quot;&gt;\n&lt;include\n用户账户相关UI\n        layout=&quot;@layout/editor_account_header_with_dropdown&quot; /&gt;\n    &lt;LinearLayout\n        android:id=&quot;@+id/body&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:orientation=&quot;vertical&quot;&gt;\n        &lt;LinearLayout\n            android:layout_height=&quot;wrap_content&quot;\n            android:layout_width=&quot;match_parent&quot;\n            android:orientation=&quot;horizontal&quot;\n            android:paddingTop=&quot;8dip&quot;&gt;\n            &lt;LinearLayout\n                android:layout_height=&quot;wrap_content&quot;\n                android:layout_width=&quot;0dip&quot;\n                android:layout_weight=&quot;1&quot;\n                android:orientation=&quot;vertical&quot;&gt;\n                &lt;include\n            Name相关的UI\n                    android:id=&quot;@+id/edit_name&quot;\n                    layout=&quot;@layout/structured_name_editor_view&quot; /&gt;\n                &lt;include\n            拼音名\n                    android:id=&quot;@+id/edit_phonetic_name&quot;\n                    layout=&quot;@layout/phonetic_name_editor_view&quot; /&gt;\n            &lt;/LinearLayout&gt;\n            &lt;include\n            照片相关的UI\n                android:id=&quot;@+id/edit_photo&quot;\n                android:layout_marginRight=&quot;8dip&quot;\n                android:layout_marginEnd=&quot;8dip&quot;\n                layout=&quot;@layout/item_photo_editor&quot; /&gt;\n        &lt;/LinearLayout&gt;\n        &lt;LinearLayout\n            中间部分Item的显示在此处\n            android:id=&quot;@+id/sect_fields&quot;\n            android:layout_width=&quot;match_parent&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:orientation=&quot;vertical&quot;\n            android:layout_marginBottom=&quot;16dip&quot;/&gt;\n            添加其他字段 按钮\n        &lt;Button\n            android:id=&quot;@+id/button_add_field&quot;\n            android:text=&quot;@string/add_field&quot;\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:layout_gravity=&quot;center&quot;\n            android:layout_marginBottom=&quot;32dip&quot;/&gt;\n    &lt;/LinearLayout&gt;\n&lt;/com.android.contacts.editor.RawContactEditorView&gt;\n</code></pre>\n<p>1.那么问题来了：中间的那部分布局（电话、地址……）去哪儿了？</p>\n<p>搜索有可能包含这些内容的线性布局<code>sect_fields</code>，发现在<code>RawContactEditorView</code>类中初始化为<code>mFields</code>：</p>\n<p><code>mFields = (ViewGroup)findViewById(R.id.sect_fields);</code></p>\n<p>那么只需要看代码中对mFields添加了什么UI！</p>\n<p>2.回到之前的<code>bindEditors()</code>方法，<code>RawContactEditorView</code> 对象<code>editor</code>从xml中解析完成后，执行了<code>setState</code>方法：</p>\n<pre><code class=\"java\">editor.setState(rawContactDelta, type, mViewIdGenerator, isEditingUserProfile());\n</code></pre>\n<p>1.<code>进入RawContactEditorView</code>类，找到<code>setState</code>方法：</p>\n<pre><code class=\"java\">public void  setState(RawContactDelta state, AccountType type, ViewIdGenerator vig,boolean isProfile)\n……\n// 遍历当前账户所有可能的item种类，如电话，姓名，地址……，并分别创建自定义视图KindSectionView\n   for (DataKind kind : type.getSortedDataKinds()) {\n……\n  final KindSectionView section = (KindSectionView)mInflater.inflate(\n                        R.layout.item_kind_section, mFields, false);\n                section.setEnabled(isEnabled());\n                section.setState(kind, state, false, vig);\n                mFields.addView(section);\n……\n}\n</code></pre>\n<p>发现遍历了当前账号类型中所有可能的数据类型（<code>DataKind</code>），</p>\n<p>创建了相关的自定义视图<code>KindSectionView</code>对象<code>section</code>，</p>\n<p>再将<code>section</code>对象添加到<code>mFields</code>中显示，</p>\n<p>这个mFields正是之前在<code>RawContactEditorView</code>类中初始化的线性布局：</p>\n<pre><code class=\"java\">mFields = (ViewGroup)findViewById(R.id.sect_fields)。\n</code></pre>\n<p>到这里，基本可以确定，中间部分（也就是除了Name、Photo 和底部的添加字段Button之外的部分），就是通过这个<code>mFields</code>动态的根据当前账户类型添加编辑的<code>KindSectionView</code>条目来填充的。</p>\n<p>首先观察一下<code>KindSectionView</code>的布局文件<code>item_kind_section</code>：</p>\n<pre><code class=\"xml\">&lt;com.android.contacts.editor.KindSectionView\n    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n    &lt;include                   这是一个TextView，title\n        android:id=&quot;@+id/kind_title_layout&quot;\n        layout=&quot;@layout/edit_kind_title&quot; /&gt;\n      &lt;LinearLayout            线性布局，用于添加EditText\n        android:id=&quot;@+id/kind_editors&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:orientation=&quot;vertical&quot; /&gt;\n    &lt;include                   添加新条目的TextView，初始化状态不可见\n        android:id=&quot;@+id/add_field_footer&quot;\n        layout=&quot;@layout/edit_add_field&quot; /&gt;\n&lt;/com.android.contacts.editor.KindSectionView&gt;\n</code></pre>\n<p>1.<code>KindSectionView</code>加载完xml文件之后，会执行<code>onFinishInflate</code>方法：</p>\n<pre><code class=\"java\">mTitle = (TextView) findViewById(R.id.kind_title);\nmEditors = (ViewGroup) findViewById(R.id.kind_editors); \nmAddFieldFooter = findViewById(R.id.add_field_footer);\n</code></pre>\n<p>把Xml文件中三个主要的部分都得到了，接下来重点就是观察代码中对他们做了什么。</p>\n<p>在第12步中，加载完xml文件之后，执行<code>KindSectionView</code>的<code>setState</code>方法：</p>\n<pre><code class=\"java\">section.setState(kind, state, false, vig);\n</code></pre>\n<p>将<code>rawContactDelta</code>对象<code>state</code>传递给了<code>KindSectionView</code>类的<code>setState</code>方法：</p>\n<p>进入<code>KindSectionView</code>类的<code>setState</code>方法：</p>\n<pre><code class=\"java\">mKind = kind;\nmState = state;\nrebuildFromState();\n</code></pre>\n<p>先进行局部变量的赋值</p>\n<p>1.然后进入到<code>rebuildFromState()</code>方法：</p>\n<pre><code class=\"java\">  for (ValuesDelta entry : mState.getMimeEntries(mKind.mimeType)) {\n       //……遍历当前账户可能的键值对，比如电话、Email、地址……\n      createEditorView(entry);  //这个方法应当是创建EditText的方法！\n  }\n</code></pre>\n<p>在这个方法中，对<code>mState</code>集合中所有Mime类型的<code>ValuesDelta</code>集合（<code>ArrayList&lt;ValuesDelta&gt;</code>类型）进行遍历，而后将每一个 <code>ValuesDelta</code>对象 <code>entry</code>作为参数调用了<code>createEditorView(entry)</code>也就是创建各个种类的<code>EditText</code>方法，根据<code>entry</code>对象创建相应的<code>EditText</code>！</p>\n<p>简单说，就是创建<code>mState</code>中存在的类型的<code>EditText</code>。<br>当然……这还都只是猜测，需要进入<code>createEditorView</code>方法确认。</p>\n<p>1.进入<code>createEditorView</code>方法：</p>\n<pre><code class=\"java\">view = mInflater.inflate(layoutResId, mEditors, false);\nEditor editor = (Editor) view;\neditor.setValues(mKind, entry, mState, mReadOnly, mViewIdGenerator);\n</code></pre>\n<p>第13步初始化的<code>mEditors</code>对象（也就是那个被猜测应该是放<code>EditText</code>的线性布局）在这里被使用！</p>\n<p>1.联系上下文，实际上此时editor对象是<code>TextFieldsEditorView</code>类的对象，进入<code>TextFieldsEditorView</code>的<code>setValues</code>方法，看看他是如何根据entry对象创建<code>EditText</code>的：</p>\n<pre><code class=\"java\">public void setValues(DataKind kind, ValuesDelta entry, RawContactDelta state, boolean readOnly,ViewIdGenerator vig) {\nint fieldCount = kind.fieldList.size();  //获取所有可能的datakind的总数\nfor (int index = 0; index &lt; fieldCount; index++)    //遍历所有可能的datakind，\n{ \nfinal EditText fieldView = new EditText(mContext);  //创建EditText对象，之后进行配置\nfieldView.setLayoutParams……\nfieldView.setTextAppearance(getContext(), android.R.style.TextAppearance_Medium);\nfieldView.setHint(field.titleRes);   //EditText的Hint\n……     \n\nfieldView.addTextChangedListener(new TextWatcher()  //注册TextChangedListener\n{\n    @Override\n    public void afterTextChanged(Editable s) {\n        // Trigger event for newly changed value\n        onFieldChanged(column, s.toString());\n    }\n    mFields.addView(fieldView);    //将EditText添加到当前的线性布局中！\n}\n</code></pre>\n<p>注释基本解释了如何通过一个<code>ValuesDelta</code>（理解为键值对集合）对象<code>entry</code>创建布局中的所有<code>EditText</code>。</p>\n<p>至此，联系人编辑界面的显示原理基本分析完成。</p>\n<p>数据存储相关</p>\n<h3 id=\"3-3-Sim联系人数据的整合\"><a href=\"#3-3-Sim联系人数据的整合\" class=\"headerlink\" title=\"3.3 Sim联系人数据的整合\"></a>3.3 Sim联系人数据的整合</h3><p>Sim卡联系人数据的显示<br>开机自动导入Sim卡联系人<br>telephony中IccProvider浅析<br>Sim卡联系人的手动导入导出</p>\n<h3 id=\"3-4-SD卡备份-恢复联系人\"><a href=\"#3-4-SD卡备份-恢复联系人\" class=\"headerlink\" title=\"3.4 SD卡备份/恢复联系人\"></a>3.4 SD卡备份/恢复联系人</h3><ul>\n<li>SD卡备份/恢复联系人</li>\n<li>联系人数据导出到SD卡</li>\n</ul>\n<h3 id=\"3-5-联系人搜索\"><a href=\"#3-5-联系人搜索\" class=\"headerlink\" title=\"3.5 联系人搜索\"></a>3.5 联系人搜索</h3><h3 id=\"3-6-Google联系人同步\"><a href=\"#3-6-Google联系人同步\" class=\"headerlink\" title=\"3.6 Google联系人同步\"></a>3.6 Google联系人同步</h3><h3 id=\"3-7-其他零碎功能\"><a href=\"#3-7-其他零碎功能\" class=\"headerlink\" title=\"3.7 其他零碎功能\"></a>3.7 其他零碎功能</h3><p>转自：<a href=\"https://blog.csdn.net/Kafka_88/article/details/50670406\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Kafka_88/article/details/50670406</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h2><p>联系人模块主要记录用户的联系人数据，方便用户快捷的操作和使用，主要包括本机联系人和Sim卡联系人。</p>\n<p>本机联系人主要存储在手机内部存储空间，Android平台上是通过数据库进行存储，使用ContentProvider组件封装，提供复杂的字段用于表示联系人数据，并提供用户快捷的操作，比如增加，删除，修改，查询等等。</p>\n<p>Sim卡联系人主要存储在Sim卡内部存储文件，包括adn、fdn、sdn。主要提供简单的字段用于表示联系人数据。并通过IccProvider提供的接口进行数据的增加、删除、修改、查询操作。</p>\n<h2 id=\"2-软件架构\"><a href=\"#2-软件架构\" class=\"headerlink\" title=\"2.软件架构\"></a>2.软件架构</h2><p>联系人Contacts应用主要包括3个部分:<br>Contacts主要响应用户的请求和交互，数据显示。<br>ContactsProvider继承自Android四大组件之一的ContentProvider组件，封装了对底层数据库contact2.db的添删改查。<br>SQLite在底层物理性地存储了联系人数据。</p>\n<p>主要交互流程如下图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019032-3b7392de-9f10-11e8-8567-d4189730b46e.png\" alt=\"\"></p>\n<p>Contacts模块的主要7块功能：</p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019045-3d496fe8-9f10-11e8-8077-89235449ccd4.png\" alt=\"\"></p>\n<h2 id=\"3-各功能模块分析\"><a href=\"#3-各功能模块分析\" class=\"headerlink\" title=\"3. 各功能模块分析\"></a>3. 各功能模块分析</h2><h3 id=\"3-1-联系人数据的显示\"><a href=\"#3-1-联系人数据的显示\" class=\"headerlink\" title=\"3.1 联系人数据的显示\"></a>3.1 联系人数据的显示</h3><h4 id=\"3-1-1-联系人列表显示\"><a href=\"#3-1-1-联系人列表显示\" class=\"headerlink\" title=\"3.1.1 联系人列表显示\"></a>3.1.1 联系人列表显示</h4><p><code>简要说明：</code></p>\n<pre><code class=\"xml\">* PeopleActivity类负责联系人列表的显示。\n\n* PeopleActivity包含4个Fragment，每个Fragment包含一个ListView。\n\n* 各个Fragment中ListView的Adapter（BaseAdapter的子类）负责将数据填充到ListView。\n\n* 各个Fragment的Loader类（CursorLoader的子类）负责加载数据。\n\n* 实现LoadertManager接口负责管理这些CursorLoader。\n</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019049-3dc1ee1e-9f10-11e8-89f3-14dac608ea42.png\" alt=\"\"></p>\n<p><strong>为什么使用Loader？</strong></p>\n<pre><code class=\"xml\">1. Loaders确保所有的cursor操作是异步的，从而排除了UI线程中堵塞的可能性。\n2. 当通过LoaderManager来管理，Loaders还可以在activity实例中保持当前的cursor数据，也就是不需要重新查询（比如，当因为横竖屏切换需要重新启动activity时）。\n3. 当数据改变时，Loaders可以自动检测底层数据的更新和重新检索。\n</code></pre>\n<p><strong>数据加载流程概览：</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019046-3d7130f0-9f10-11e8-945c-7a0eff02b65c.png\" alt=\"\"></p>\n<p><strong>流程具体分析：</strong></p>\n<p>先上图：<br><img src=\"https://user-images.githubusercontent.com/35097187/44019033-3ba1bba0-9f10-11e8-94f9-e41053c967b4.jpeg\" alt=\"\"></p>\n<p>进入Contacts应用，程序的主入口Activity是<code>PeopleActivity</code>。</p>\n<p>进入<code>onCreate</code>方法：</p>\n<p><code>createViewsAndFragments(savedState);</code></p>\n<p>此方法创建视图和Fragments，进入此方法：</p>\n<pre><code class=\"java\">mFavoritesFragment = new ContactTileListFragment();\nmAllFragment = new DefaultContactBrowseListFragment();\nmGroupsFragment = new GroupBrowseListFragment();\n</code></pre>\n<p>发现创建了3个Fragment，分别是 收藏联系人列表、所有联系人列表、群组列表。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>：</p>\n<p>发现<code>DefaultContactBrowseListFragment</code>的祖父类是：</p>\n<p><code>ContactEntryListFragment&lt;T extends ContactEntryListAdapter&gt;</code></p>\n<p>首先分析此基类：</p>\n<p>发现此基类实现了<code>LoadManager</code>接口，实现了该接口3个重要的抽象方法：</p>\n<pre><code class=\"java\">public Loader&lt;D&gt; onCreateLoader(int id, Bundle args);//创建Loader\npublic void onLoadFinished(Loader&lt;D&gt; loader, D data);//数据加载完毕后的回调方法\npublic void onLoaderReset(Loader&lt;D&gt; loader);//数据重新加载\n</code></pre>\n<p>该类同时提供了重要的抽象方法：</p>\n<pre><code class=\"java\">protected abstract T createListAdapter();//创建适配器Adapter类。\n</code></pre>\n<p>这意味着,子类可以按需求创造自己的适配器Adapter类,完成各个子界面Listview的数据显示，如3.1节图1所示。</p>\n<p>然后回到<code>DefaultContactBrowseListFragment</code>类：</p>\n<p>在执行<code>onCreateView</code>之前，会执行父类的一些方法，顺序如下：</p>\n<pre><code class=\"java\">onAttach()\nsetContext(activity);\nsetLoaderManager(super.getLoaderManager());\n</code></pre>\n<p><code>setLoaderManager</code>中设置当前的LoaderManager实现类。 </p>\n<p>加载联系人列表数据的过程中，这个类是<code>ProfileandContactsLoader</code>。</p>\n<p>之后执行<code>onCreate</code>方法。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>onCreate(Bundle)</code>方法：</p>\n<pre><code class=\"java\">mAdapter = createListAdapter();\n</code></pre>\n<p>发现在这里创建了<code>ListAdapter</code>：</p>\n<pre><code class=\"java\">DefaultContactListAdapter adapter = \nnew DefaultContactListAdapter(getContext());\n</code></pre>\n<p>可以知道创建的<code>ListAdapter</code>类型是<code>DefaultContactListAdapter</code>并返回到<code>DefaultContactBrowseListFragment</code>类。</p>\n<p>执行完<code>onCreate</code>方法之后，</p>\n<p>执行<code>DefaultContactBrowseListFragment</code>的<code>onCreateView</code>方法。</p>\n<p>进入DefaultContactBrowseListFragment的onCreateView方法：</p>\n<pre><code class=\"java\">mListView = (ListView)mView.findViewById(android.R.id.list);\nmListView.setAdapter(mAdapter);\n</code></pre>\n<p>首先获取了ListView用以填充联系人数据，然后设置了适配器，但是此时适配器中的数据是空的，直到后面才会加载数据更新UI。<br>在<code>onCreateView</code>方法执行完之后，在UI可见之前回调执行<code>Activity</code>的<code>onStart</code>方法。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>onStart</code>方法：</p>\n<pre><code class=\"java\">mContactsPrefs.registerChangeListener(mPreferencesChangeListener);\nstartLoading();\n</code></pre>\n<p>首先注册了一个<code>ContentObserv</code>e的子类监听数据变化。<br>然后执行<code>startLoading</code>方法，<strong>目测这应当就是开始加载数据的方法了！</strong></p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>startLoading</code>方法：</p>\n<pre><code class=\"java\">int partitionCount = mAdapter.getPartitionCount();\nfor (int i = 0; i &lt; partitionCount; i++) {\n……\nPartition partition = mAdapter.getPartition(i);\nstartLoadingDirectoryPartition(i);\n……}\n</code></pre>\n<p><code>Partition</code>这个类持有一个<code>Cursor</code>对象，用来存储数据。<br><code>Adapter</code>持有的<code>Partition</code>，<code>Partition</code>类代表了当前需要加载的<code>Directory</code>，可以理解为一个联系人集合，比如说本地联系人、Google联系人……这里我们假设只加载本地联系人数据，所以<code>partitionCount=1</code>。</p>\n<p>从这里我们可以做出猜测：<br>联系人数据不是想象中的分页（每次N条联系人数据）加载，也不是说一次性全部加载，而是一个账户一个账户加载联系人数据，加载完毕一个账户就在uI刷新并显示数据。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>startLoadingDirectoryPartition</code>方法：</p>\n<pre><code class=\"java\">loadDirectoryPartition(partitionIndex, partition);\n</code></pre>\n<p>进入此方法：</p>\n<pre><code class=\"java\">getLoaderManager().restartLoader(partitionIndex, args, this);\n</code></pre>\n<p>这个方法是LoaderManager实现类的方法，参照文档解释：</p>\n<blockquote>\n<p>这个方法会新建/重启一个当前LoaderManager中的Loader，将回调方法注册给他，并开始加载数据。也就是说会回调LoaderManager的onCreateLoader()方法。<br>Starts a new or restarts an existing android.content.Loader in this manager, registers the callbacks to it, and (if the activity/fragment is currently started) starts loading it</p>\n</blockquote>\n<p>进入<code>LoadManager</code>接口的实现类：<code>LoaderManagerImpl</code>的<code>restartLoader</code>方法内部：</p>\n<pre><code class=\"java\">LoaderInfo info = mLoaders.get(id);\nCreate info=\ncreateAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);\n//进入createAndInstallLoader方法：\nLoaderInfo info = createLoader(id, args, callback);\ninstallLoader(info);\n//进入createLoader方法：\nLoaderInfo info = new LoaderInfo(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);\nLoader&lt;Object&gt; loader = callback.onCreateLoader(id, args);\n//关键方法出现了！LoadManager接口的抽象方法的onCreateLoader方法被回调了！\n//然后installLoader方法启动了这个Loader！\ninfo.start();\n</code></pre>\n<p>进入<code>ContactEntryListFragment</code>的<code>onCreateLoader</code>方法，位于<code>DefaultContactBrowseListFragment</code>的祖父类<code>ContactEntryListFragment</code>中：</p>\n<pre><code class=\"java\">CursorLoader loader = createCursorLoader(mContext);//创建Loader\nmAdapter.configureLoader(loader, directoryId);//配置Loader\n</code></pre>\n<p>发现在此方法中，首先调用<code>createCursorLoader</code>方法创建了<code>Loader</code>。<br>然后通过<code>configureLoader</code>方法配置<code>Loader</code>的<code>query</code>方法的查询参数，也就是配置SQL中select查询语句的参数。<br>这也同时意味着，<code>ContactEntryListFragment</code>类的子类们可以重写<code>createCursorLoader</code>方法以提供适合自身的Loader，重写<code>configureLoader</code>方法为Loader配置合适的参数，适配各种自定义的查询获取数据。</p>\n<p>观察<code>createCursorLoader</code>方法在<code>DefaultContactBrowseListFragment</code>类中实现：</p>\n<pre><code class=\"java\">return new ProfileAndContactsLoader(context);\n</code></pre>\n<p>直接返回了<code>DefaultContactBrowseListFragment</code>的数据加载器：<code>ProfileAndContactsLoader</code><br>这就是<code>DefaultContactBrowseListFragment</code>的Loader实现类（数据加载器）。</p>\n<p>然后再看一下<code>ProfileAndContactsLoader</code>类是如何加载数据的呢？<br>发现它继承自<code>CursorLoader</code>，而<code>CursorLoader</code>又继承自<code>AsyncTaskLoader&lt;D&gt;</code><br>在关键的<code>LoadBackGround()</code>方法中：<br>异步调用了ContentResolver的<code>query</code>方法：</p>\n<pre><code class=\"java\">Cursor cursor = getContext()\n.getContentResolver()\n.query(mUri, mProjection, mSelection,\n                    mSelectionArgs, mSortOrder, mCancellationSignal);\ncursor.registerContentObserver(mObserver);\n</code></pre>\n<p>通过这个Query方法，实现了对联系人数据的查询,返回Cursor数据。并绑定了数据监听器。</p>\n<p>那么问题来了</p>\n<pre><code class=\"java\">query(mUri, mProjection, mSelection,mSelectionArgs, mSortOrder, mCancellationSignal)\n</code></pre>\n<p>的这些参数那里指定的呢？<br><code>configureLoader</code>方法在<code>DefaultContactListAdapter</code>类中实现，实现了对<code>query</code>参数的配置：</p>\n<pre><code class=\"java\">configureUri(loader, directoryId, filter);\nloader.setProjection(getProjection(false));\nconfigureSelection(loader, directoryId, filter);\nloader.setSortOrder(sortOrder);\n</code></pre>\n<p>可以看到，配置了Loader主要的几个参数：Uri，Projection，Selection，SortOrder。<br>这些参数用于最后和ContactsProvider交互的方法Query方法中……</p>\n<p>最终查询<code>ContactsProvider2</code>的uri是：</p>\n<pre><code class=\"xml\">Uri：content://com.android.contacts/contacts?address_book_index_extras=true&amp;directory=0\n</code></pre>\n<p>发现ContentProvider的服务类似一个网站，uri就是网址，而请求数据的方式类似使用Get方式获取数据。</p>\n<p>最后通过ContentProvider2构建的查询语句是这样的：</p>\n<pre><code class=\"sql\">SELECT \n_id, display_name, agg_presence.mode AS contact_presence, \ncontacts_status_updates.status AS contact_status, photo_id, photo_thumb_uri, lookup, \nis_user_profile \nFROM view_contacts \nLEFT OUTER JOIN agg_presence ON (_id = agg_presence.presence_contact_id) LEFT OUTER JOIN \nstatus_updates contacts_status_updates ON\n(status_update_id=contacts_status_updates.status_update_data_id)\n</code></pre>\n<p>可以发现最后通过ContactsProvider2实现的查询，并不是直接查询相关的表（Contacts表、rawcontacts表，data表……），而是直接查询<code>view_contacts</code>视图，因为这样会有更加高的效率。<br>这也就意味着如果想给联系人数据库新增一个字段供界面使用，仅修改对应的表结构是不行，还要修改对应的视图才能得到想要的效果。</p>\n<p>查询完毕后，回调<code>LoaderManager</code>的<code>onLoadFinished</code>方法，完成对UI界面的更新：</p>\n<pre><code class=\"java\">onPartitionLoaded(loaderId, data);\n</code></pre>\n<p>接着进入<code>onPartitionLoaded</code>方法：</p>\n<pre><code class=\"java\">mAdapter.changeCursor(partitionIndex, data);\n</code></pre>\n<p>进入这个<code>changeCursor</code>方法：</p>\n<pre><code class=\"java\">mPartitions[partition].cursor = cursor;\nnotifyDataSetChanged();\n</code></pre>\n<p>发现在这里改变了<code>Adapter</code>的数据集<code>Cursor</code>，并发出通知数据已经改变，UI进行更新。</p>\n<p>至此，默认联系人数据的显示分析到此结束。</p>\n<p>其他<code>Fragment</code>的数据填充基本仍然类似此流程，所不同的只是各自的<code>Fragment</code>、<code>Adapter</code>、<code>CursorLoader</code>以及<code>CursorLoader</code>配置的参数（uri，projection,selection,args,order……）有所不同。</p>\n<p>可以参考下表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Fragment</th>\n<th style=\"text-align:center\">Adapter</th>\n<th style=\"text-align:center\">CursorLoader</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">DefaultContactBrowseListFragment(默认联系人列表)</td>\n<td style=\"text-align:center\">DefaultContactListAdapter</td>\n<td style=\"text-align:center\">ProfileAndContactsLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ContactTitleListFragment(收藏联系人列表)</td>\n<td style=\"text-align:center\">ContactTileAdapter</td>\n<td style=\"text-align:center\">ContactTileLoaderFactory StarredLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ContactTitleFrequentFragment(常用联系人列表)</td>\n<td style=\"text-align:center\">ContactTitleAdapter</td>\n<td style=\"text-align:center\">ContactTileLoaderFactory FrequentLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GroupBrowseListFragment(群组列表)</td>\n<td style=\"text-align:center\">GroupBrowseLIstAdapter</td>\n<td style=\"text-align:center\">GroupListLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GroupDetailFragment(指定ID群组的联系人列表)</td>\n<td style=\"text-align:center\">GroupMemberTileAdapter</td>\n<td style=\"text-align:center\">GroupMemberLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ContactDetailFragment(指定ID联系人信息)</td>\n<td style=\"text-align:center\">ViewAdapter</td>\n<td style=\"text-align:center\">ContactLoader</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-1-2-联系人详细信息数据的显示\"><a href=\"#3-1-2-联系人详细信息数据的显示\" class=\"headerlink\" title=\"3.1.2 联系人详细信息数据的显示\"></a>3.1.2 联系人详细信息数据的显示</h4><p><strong>关键类：</strong></p>\n<pre><code class=\"java\">ContactDetailActivity\n\nContactDetailFragment  \n\nContactLoaderFragment //不可见 负责加载联系人详细数据，集成LoadManager对象。\n\nContactLoader   //联系人详细信息Loader。\n\nContactDetailLayoutController     //布局控制类。\n</code></pre>\n<p>原理类似列表显示，如下简要说明： </p>\n<pre><code class=\"xml\">* ContactLoaderFragment类创建了一个实现LoaderManager.LoaderCallbacks&lt;Contact&gt;接口的对象，数据类型指定为Contacts。负责创建、管理ContactLoader。\n\n* 得到当前用户选择的联系人URI，配置对应的ContactLoader。 \n\n* 后台数据查询完毕后，回调LoadManager的onLoadFinished()方法，并将数据以Contacts的数据类型返回，然后回调ContactDetailLoaderFragmentListener的onDetailsLoaded()方法。 \n\n* onDetailsLoaded()方法中，新开一个线程，通过ContactDetailLayoutController类的setContactData(Conatct)设置数据，刷新ContactDetailFragment。\n</code></pre>\n<h3 id=\"3-2-联系人数据的编辑和存储\"><a href=\"#3-2-联系人数据的编辑和存储\" class=\"headerlink\" title=\"3.2 联系人数据的编辑和存储\"></a>3.2 联系人数据的编辑和存储</h3><h4 id=\"3-2-1-编辑界面相关\"><a href=\"#3-2-1-编辑界面相关\" class=\"headerlink\" title=\"3.2.1 编辑界面相关\"></a>3.2.1 编辑界面相关</h4><p>联系人数据所属的账号不同，加载的UI也是不同的，比如Sim卡联系人一般只有name，phone num，但是本地账号联系人可能就会有email，</p>\n<p>address，website等信息…… </p>\n<p>联系人数据UI的加载是通过代码动态加载的，而不是xml文件写死的。</p>\n<p>那么问题来了， </p>\n<p>新建联系人的界面是如何设计？ </p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019034-3bc9de0a-9f10-11e8-8f38-f764c64cc8e2.jpeg\" alt=\"\"></p>\n<p>先进入新建联系人界面：</p>\n<p>主界面<code>PeopleActivity</code>中点击新建联系人Button，触发<code>onOptionsItemSelected</code>方法中的</p>\n<p>case R.id.menu_add_contact分支： </p>\n<p>执行<code>startActivity(intent);</code> </p>\n<p><code>startActivity</code>启动Intent，Intent的Action设置为android.intent.action.INSERT </p>\n<p>找到匹配此Action的Activity：<code>ContactEditorActivity</code></p>\n<p><code>ContactEditorActivity</code>的布局文件：</p>\n<p><code>ContactEditorActivity</code>的<code>onCreate()</code>方法中找到布局： </p>\n<p><code>setContentView(R.layout.contact_editor_activity);</code></p>\n<p>在xml文件中找到这个布局：</p>\n<pre><code class=\"xml\">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n &lt;fragment class=&quot;com.android.contacts.editor.ContactEditorFragment&quot;\n            android:id=&quot;@+id/contact_editor_fragment&quot;\n            android:layout_width=&quot;match_parent&quot;\n            android:layout_height=&quot;match_parent&quot; /&gt;\n&lt;/FrameLayout&gt;\n</code></pre>\n<p>只包含一个Fragment：<code>ContactEditorFragment</code>。程序解析Xml文件到这里就会执行<code>ContactEditorFragment</code>类。</p>\n<p>进入<code>ContactEditorFragment</code>的<code>onCreateView</code>方法：</p>\n<pre><code class=\"xml\">//展开布局 \nfinal View view\n= inflater.inflate(R.layout.contact_editor_fragment, container, false);    \n//找到布局中的一个线性布局\n//关键的布局是contact_editor_fragment中的一个iD为editors的线性布局！\nmContent = (LinearLayout) view.findViewById(R.id.editors);\n</code></pre>\n<p>找到<code>contact_editor_fragment</code>：</p>\n<pre><code class=\"xml\">&lt;ScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:fillViewport=&quot;true&quot;\n    android:fadingEdge=&quot;none&quot;\n    android:background=&quot;@color/background_primary&quot;\n&gt;\n    &lt;LinearLayout android:id=&quot;@+id/editors&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:orientation=&quot;vertical&quot;\n    /&gt;\n&lt;/ScrollView&gt;\n</code></pre>\n<p>于是确认<code>ContactEditorFragment</code>的根布局就是一个id为<code>editors</code>的LinearLayout。<br>想到上一步的语句：</p>\n<pre><code class=\"xml\">mContent = (LinearLayout) view.findViewById(R.id.editors);\n</code></pre>\n<p>所以关键就在于，接下来在代码中为mContent这个线性布局动态添加地了什么UI，而这些UI才是真正显示的东西。</p>\n<p><code>ContactEditorFragment</code>的<code>onCreateView</code>方法执行完毕之后，会调用<code>onActivityCreate()</code>方法：</p>\n<pre><code class=\"java\">if (Intent.ACTION_INSERT.equals(mAction)) {\nfinal Account account = mIntentExtras == null ? null : (Account) \nmIntentExtbindEditorsForNewContactras.getParcelable(Intents.Insert.ACCOUNT);\nfinal String dataSet = mIntentExtras == null ? null :\n                        mIntentExtras.getString(Intents.Insert.DATA_SET);\nif (account != null) {\n// Account specified in Intent\ncreateContact(new AccountWithDataSet(account.name, account.type, dataSet));\n}\n</code></pre>\n<p>上面代码首先取出了当前Account信息，数据信息。封装为一个<code>AccountWithDataSet</code>对象，作为<code>createContact</code>方法的参数。之前我们分析过，编辑界面和账户是高度相关的，所以对UI的动态操作必然和Account对象相关。进入<code>createContact</code>方法。</p>\n<p>看一下<code>ContactEditorFragment</code>中的<code>createContact()</code>到底对界面干了什么！！ </p>\n<p><code>createContact</code>方法中调用了<code>bindEditorsForNewContact(account, accountType)</code>: </p>\n<p>关键代码：</p>\n<pre><code class=\"java\">……\nfinal RawContact rawContact = new RawContact();\nif (newAccount != null) {\n    rawContact.setAccount(newAccount);\n} else {\n    rawContact.setAccountToLocal();\n}\nfinal ValuesDelta valuesDelta = ValuesDelta.fromAfter(rawContact.getValues());\nfinal RawContactDelta insert = new RawContactDelta(valuesDelta);\n……\nmState.add(insert);\nbindEditors();\n</code></pre>\n<p>发现暂时还是没有对界面做什么事情，任然处于酝酿阶段……</p>\n<p>首先使用传入的Accout对象创建一个<code>RawContact</code>对象，然后使用<code>RawContact</code>对象构建了一个<code>RawContactDelta</code>对象insert，接着就将insert对象放入<code>RawContactDeltaList</code> 对象<code>mState</code>中。</p>\n<pre><code class=\"xml\">RawContact类：raw contacts数据表内的一条数据，表示一个联系人某一特定帐户的信息。存储Data表中一些数据行（电话号码、Email、地址……）的集合及一些其他的信息。\n他的存储结构为： HashMap&lt;String, ArrayList&lt;ValuesDelta&gt;&gt;\n\nRawContactDelta类：包含RawContact对象（即一个联系人某一特定帐户的信息），并具有记录修改的功能。\n\nRawContactDeltaList类：内部的存储结构是ArrayList&lt;RawContactDelta&gt;，可以理解为 单个联系人所有账户的数据集合。\n</code></pre>\n<p>然后调用了<code>bindEditors()</code>法。 </p>\n<p>关键代码如下：</p>\n<pre><code class=\"java\">……\nmContent.removeAllViews();\n……\nfinal BaseRawContactEditorView editor;\n……\neditor = (RawContactEditorView) inflater.inflate(R.layout.raw_contact_editor_view,mContent, false);\n//添加视图了……………………\nmContent.addView(editor);\n//为自定义视图BaseRawContactEditorView设置状态，必然是修改UI的操作！\neditor.setState(rawContactDelta, type, mViewIdGenerator, isEditingUserProfile());\n</code></pre>\n<p>可以看到，<code>mContent</code>这个LinearLayout添加的View是<code>editor</code>，而<code>editor</code>是一个自定义的视图<code>BaseRawContactEditorView</code>，布局是<code>R.layout.raw_contact_editor_view</code>。</p>\n<p>找到<code>raw_contact_editor_view</code>布局，发现该布局包含新建联系人页面所有的UI：</p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019036-3bf3c4ae-9f10-11e8-81b0-dfa54fe8fad9.jpeg\" alt=\"\"> </p>\n<pre><code class=\"xml\">&lt;com.android.contacts.editor.RawContactEditorView\n    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:orientation=&quot;vertical&quot;\n    android:paddingTop=&quot;@dimen/editor_padding_top&quot;&gt;\n&lt;include\n用户账户相关UI\n        layout=&quot;@layout/editor_account_header_with_dropdown&quot; /&gt;\n    &lt;LinearLayout\n        android:id=&quot;@+id/body&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:orientation=&quot;vertical&quot;&gt;\n        &lt;LinearLayout\n            android:layout_height=&quot;wrap_content&quot;\n            android:layout_width=&quot;match_parent&quot;\n            android:orientation=&quot;horizontal&quot;\n            android:paddingTop=&quot;8dip&quot;&gt;\n            &lt;LinearLayout\n                android:layout_height=&quot;wrap_content&quot;\n                android:layout_width=&quot;0dip&quot;\n                android:layout_weight=&quot;1&quot;\n                android:orientation=&quot;vertical&quot;&gt;\n                &lt;include\n            Name相关的UI\n                    android:id=&quot;@+id/edit_name&quot;\n                    layout=&quot;@layout/structured_name_editor_view&quot; /&gt;\n                &lt;include\n            拼音名\n                    android:id=&quot;@+id/edit_phonetic_name&quot;\n                    layout=&quot;@layout/phonetic_name_editor_view&quot; /&gt;\n            &lt;/LinearLayout&gt;\n            &lt;include\n            照片相关的UI\n                android:id=&quot;@+id/edit_photo&quot;\n                android:layout_marginRight=&quot;8dip&quot;\n                android:layout_marginEnd=&quot;8dip&quot;\n                layout=&quot;@layout/item_photo_editor&quot; /&gt;\n        &lt;/LinearLayout&gt;\n        &lt;LinearLayout\n            中间部分Item的显示在此处\n            android:id=&quot;@+id/sect_fields&quot;\n            android:layout_width=&quot;match_parent&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:orientation=&quot;vertical&quot;\n            android:layout_marginBottom=&quot;16dip&quot;/&gt;\n            添加其他字段 按钮\n        &lt;Button\n            android:id=&quot;@+id/button_add_field&quot;\n            android:text=&quot;@string/add_field&quot;\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:layout_gravity=&quot;center&quot;\n            android:layout_marginBottom=&quot;32dip&quot;/&gt;\n    &lt;/LinearLayout&gt;\n&lt;/com.android.contacts.editor.RawContactEditorView&gt;\n</code></pre>\n<p>1.那么问题来了：中间的那部分布局（电话、地址……）去哪儿了？</p>\n<p>搜索有可能包含这些内容的线性布局<code>sect_fields</code>，发现在<code>RawContactEditorView</code>类中初始化为<code>mFields</code>：</p>\n<p><code>mFields = (ViewGroup)findViewById(R.id.sect_fields);</code></p>\n<p>那么只需要看代码中对mFields添加了什么UI！</p>\n<p>2.回到之前的<code>bindEditors()</code>方法，<code>RawContactEditorView</code> 对象<code>editor</code>从xml中解析完成后，执行了<code>setState</code>方法：</p>\n<pre><code class=\"java\">editor.setState(rawContactDelta, type, mViewIdGenerator, isEditingUserProfile());\n</code></pre>\n<p>1.<code>进入RawContactEditorView</code>类，找到<code>setState</code>方法：</p>\n<pre><code class=\"java\">public void  setState(RawContactDelta state, AccountType type, ViewIdGenerator vig,boolean isProfile)\n……\n// 遍历当前账户所有可能的item种类，如电话，姓名，地址……，并分别创建自定义视图KindSectionView\n   for (DataKind kind : type.getSortedDataKinds()) {\n……\n  final KindSectionView section = (KindSectionView)mInflater.inflate(\n                        R.layout.item_kind_section, mFields, false);\n                section.setEnabled(isEnabled());\n                section.setState(kind, state, false, vig);\n                mFields.addView(section);\n……\n}\n</code></pre>\n<p>发现遍历了当前账号类型中所有可能的数据类型（<code>DataKind</code>），</p>\n<p>创建了相关的自定义视图<code>KindSectionView</code>对象<code>section</code>，</p>\n<p>再将<code>section</code>对象添加到<code>mFields</code>中显示，</p>\n<p>这个mFields正是之前在<code>RawContactEditorView</code>类中初始化的线性布局：</p>\n<pre><code class=\"java\">mFields = (ViewGroup)findViewById(R.id.sect_fields)。\n</code></pre>\n<p>到这里，基本可以确定，中间部分（也就是除了Name、Photo 和底部的添加字段Button之外的部分），就是通过这个<code>mFields</code>动态的根据当前账户类型添加编辑的<code>KindSectionView</code>条目来填充的。</p>\n<p>首先观察一下<code>KindSectionView</code>的布局文件<code>item_kind_section</code>：</p>\n<pre><code class=\"xml\">&lt;com.android.contacts.editor.KindSectionView\n    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n    &lt;include                   这是一个TextView，title\n        android:id=&quot;@+id/kind_title_layout&quot;\n        layout=&quot;@layout/edit_kind_title&quot; /&gt;\n      &lt;LinearLayout            线性布局，用于添加EditText\n        android:id=&quot;@+id/kind_editors&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:orientation=&quot;vertical&quot; /&gt;\n    &lt;include                   添加新条目的TextView，初始化状态不可见\n        android:id=&quot;@+id/add_field_footer&quot;\n        layout=&quot;@layout/edit_add_field&quot; /&gt;\n&lt;/com.android.contacts.editor.KindSectionView&gt;\n</code></pre>\n<p>1.<code>KindSectionView</code>加载完xml文件之后，会执行<code>onFinishInflate</code>方法：</p>\n<pre><code class=\"java\">mTitle = (TextView) findViewById(R.id.kind_title);\nmEditors = (ViewGroup) findViewById(R.id.kind_editors); \nmAddFieldFooter = findViewById(R.id.add_field_footer);\n</code></pre>\n<p>把Xml文件中三个主要的部分都得到了，接下来重点就是观察代码中对他们做了什么。</p>\n<p>在第12步中，加载完xml文件之后，执行<code>KindSectionView</code>的<code>setState</code>方法：</p>\n<pre><code class=\"java\">section.setState(kind, state, false, vig);\n</code></pre>\n<p>将<code>rawContactDelta</code>对象<code>state</code>传递给了<code>KindSectionView</code>类的<code>setState</code>方法：</p>\n<p>进入<code>KindSectionView</code>类的<code>setState</code>方法：</p>\n<pre><code class=\"java\">mKind = kind;\nmState = state;\nrebuildFromState();\n</code></pre>\n<p>先进行局部变量的赋值</p>\n<p>1.然后进入到<code>rebuildFromState()</code>方法：</p>\n<pre><code class=\"java\">  for (ValuesDelta entry : mState.getMimeEntries(mKind.mimeType)) {\n       //……遍历当前账户可能的键值对，比如电话、Email、地址……\n      createEditorView(entry);  //这个方法应当是创建EditText的方法！\n  }\n</code></pre>\n<p>在这个方法中，对<code>mState</code>集合中所有Mime类型的<code>ValuesDelta</code>集合（<code>ArrayList&lt;ValuesDelta&gt;</code>类型）进行遍历，而后将每一个 <code>ValuesDelta</code>对象 <code>entry</code>作为参数调用了<code>createEditorView(entry)</code>也就是创建各个种类的<code>EditText</code>方法，根据<code>entry</code>对象创建相应的<code>EditText</code>！</p>\n<p>简单说，就是创建<code>mState</code>中存在的类型的<code>EditText</code>。<br>当然……这还都只是猜测，需要进入<code>createEditorView</code>方法确认。</p>\n<p>1.进入<code>createEditorView</code>方法：</p>\n<pre><code class=\"java\">view = mInflater.inflate(layoutResId, mEditors, false);\nEditor editor = (Editor) view;\neditor.setValues(mKind, entry, mState, mReadOnly, mViewIdGenerator);\n</code></pre>\n<p>第13步初始化的<code>mEditors</code>对象（也就是那个被猜测应该是放<code>EditText</code>的线性布局）在这里被使用！</p>\n<p>1.联系上下文，实际上此时editor对象是<code>TextFieldsEditorView</code>类的对象，进入<code>TextFieldsEditorView</code>的<code>setValues</code>方法，看看他是如何根据entry对象创建<code>EditText</code>的：</p>\n<pre><code class=\"java\">public void setValues(DataKind kind, ValuesDelta entry, RawContactDelta state, boolean readOnly,ViewIdGenerator vig) {\nint fieldCount = kind.fieldList.size();  //获取所有可能的datakind的总数\nfor (int index = 0; index &lt; fieldCount; index++)    //遍历所有可能的datakind，\n{ \nfinal EditText fieldView = new EditText(mContext);  //创建EditText对象，之后进行配置\nfieldView.setLayoutParams……\nfieldView.setTextAppearance(getContext(), android.R.style.TextAppearance_Medium);\nfieldView.setHint(field.titleRes);   //EditText的Hint\n……     \n\nfieldView.addTextChangedListener(new TextWatcher()  //注册TextChangedListener\n{\n    @Override\n    public void afterTextChanged(Editable s) {\n        // Trigger event for newly changed value\n        onFieldChanged(column, s.toString());\n    }\n    mFields.addView(fieldView);    //将EditText添加到当前的线性布局中！\n}\n</code></pre>\n<p>注释基本解释了如何通过一个<code>ValuesDelta</code>（理解为键值对集合）对象<code>entry</code>创建布局中的所有<code>EditText</code>。</p>\n<p>至此，联系人编辑界面的显示原理基本分析完成。</p>\n<p>数据存储相关</p>\n<h3 id=\"3-3-Sim联系人数据的整合\"><a href=\"#3-3-Sim联系人数据的整合\" class=\"headerlink\" title=\"3.3 Sim联系人数据的整合\"></a>3.3 Sim联系人数据的整合</h3><p>Sim卡联系人数据的显示<br>开机自动导入Sim卡联系人<br>telephony中IccProvider浅析<br>Sim卡联系人的手动导入导出</p>\n<h3 id=\"3-4-SD卡备份-恢复联系人\"><a href=\"#3-4-SD卡备份-恢复联系人\" class=\"headerlink\" title=\"3.4 SD卡备份/恢复联系人\"></a>3.4 SD卡备份/恢复联系人</h3><ul>\n<li>SD卡备份/恢复联系人</li>\n<li>联系人数据导出到SD卡</li>\n</ul>\n<h3 id=\"3-5-联系人搜索\"><a href=\"#3-5-联系人搜索\" class=\"headerlink\" title=\"3.5 联系人搜索\"></a>3.5 联系人搜索</h3><h3 id=\"3-6-Google联系人同步\"><a href=\"#3-6-Google联系人同步\" class=\"headerlink\" title=\"3.6 Google联系人同步\"></a>3.6 Google联系人同步</h3><h3 id=\"3-7-其他零碎功能\"><a href=\"#3-7-其他零碎功能\" class=\"headerlink\" title=\"3.7 其他零碎功能\"></a>3.7 其他零碎功能</h3><p>转自：<a href=\"https://blog.csdn.net/Kafka_88/article/details/50670406\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Kafka_88/article/details/50670406</a></p>\n"},{"title":"android2.3.1编译","date":"2018-08-13T06:35:48.000Z","_content":"\n##前言\n\n&ensp;&ensp;&ensp;&ensp;一直想系统的把android的内容重新捋一遍，今天京东优惠，66入了`《Android系统源代码情景分析》`，这书是基于android2.3.1来说明的，为了和方便真机编译与调试，入了nexus s. 好了话不多说，直接上 命令以及error的fix工作.\n\n## android2.3.1编译\n\n我的环境:\n\n系统环境为`ubuntu 14.04`\n\njdk使用 `jdk1.6.0_45`\n\n```bash\nrepo init -u https://android.googlesource.com/platform/manifest -b android-2.3.1_r1\nrepo sync -j4\n```\n\n**gcc downgrade:**\n\n```bash\nsudo apt-get install g++-4.4-multilib\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.4 20 --slave /usr/bin/g++ g++ /usr/bin/g++-4.4\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 20 --slave /usr/bin/g++ g++ /usr/bin/g++-4.8\nsudo update-alternatives --config gcc\n```\n\n`去google aosp 官网下载对应的driver sh 脚本， 运行生成vendor`\n\n```bash\n$ source build/envsetup.sh\n$ lunch\n$ full_crespo-userdebug\n$ make (这边千万别使用-j, 会引起多线程编译build error)\n```\n\n**以下是build时产生的error以及处理：**\n\n`error:Can't locate Switch.pm in @INC`\n\n```bash\nsudo apt-get install libswitch-perl\n```\n\n`dalvik/vm/native/dalvik_system_Zygote.c:191: error: storage size of ‘rlim’ isn’t known`\n\nFix:\n\n```bash\ndiff --git a/vm/native/dalvik_system_Zygote.c b/vm/native/dalvik_system_Zygote.c\nindex bcc2313..112563a 100644\n--- a/vm/native/dalvik_system_Zygote.c\n+++ b/vm/native/dalvik_system_Zygote.c\n@@ -21,6 +21,7 @@\n #include \"native/InternalNativePriv.h\"\n \n #include <signal.h>\n+#include <sys/resource.h>\n #include <sys/types.h>\n #include <sys/wait.h>\n #include <grp.h>\n```\n\n`/usr/include/zlib.h:34: fatal error: zconf.h: No such file or directory`\n\nFix:\n\n```bash\nsudo ln -s /usr/include/x86_64-linux-gnu/zconf.h /usr/include\n```\n\n*编译成功后:*\n\n去twrp 下载对应的recovery 的 image.\n\n```bash\nfastboot flash recovery twrp.img\nadb reboot bootloader\n```\n\n从bootloader 进入recovery模式，进行双清后，重新进入bootloader，使用一下命令进行刷机.\n\n```bash\nadb reboot bootloader\nfastboot -w flashall\n```\n\n","source":"_posts/Android/android2.3.1编译.md","raw":"---\ntitle: android2.3.1编译\npermalink: android2.3.1-build\ncategories:\n  - Android\ntags:\n  - android2.3.1\ndate: 2018-08-13 14:35:48\n---\n\n##前言\n\n&ensp;&ensp;&ensp;&ensp;一直想系统的把android的内容重新捋一遍，今天京东优惠，66入了`《Android系统源代码情景分析》`，这书是基于android2.3.1来说明的，为了和方便真机编译与调试，入了nexus s. 好了话不多说，直接上 命令以及error的fix工作.\n\n## android2.3.1编译\n\n我的环境:\n\n系统环境为`ubuntu 14.04`\n\njdk使用 `jdk1.6.0_45`\n\n```bash\nrepo init -u https://android.googlesource.com/platform/manifest -b android-2.3.1_r1\nrepo sync -j4\n```\n\n**gcc downgrade:**\n\n```bash\nsudo apt-get install g++-4.4-multilib\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.4 20 --slave /usr/bin/g++ g++ /usr/bin/g++-4.4\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 20 --slave /usr/bin/g++ g++ /usr/bin/g++-4.8\nsudo update-alternatives --config gcc\n```\n\n`去google aosp 官网下载对应的driver sh 脚本， 运行生成vendor`\n\n```bash\n$ source build/envsetup.sh\n$ lunch\n$ full_crespo-userdebug\n$ make (这边千万别使用-j, 会引起多线程编译build error)\n```\n\n**以下是build时产生的error以及处理：**\n\n`error:Can't locate Switch.pm in @INC`\n\n```bash\nsudo apt-get install libswitch-perl\n```\n\n`dalvik/vm/native/dalvik_system_Zygote.c:191: error: storage size of ‘rlim’ isn’t known`\n\nFix:\n\n```bash\ndiff --git a/vm/native/dalvik_system_Zygote.c b/vm/native/dalvik_system_Zygote.c\nindex bcc2313..112563a 100644\n--- a/vm/native/dalvik_system_Zygote.c\n+++ b/vm/native/dalvik_system_Zygote.c\n@@ -21,6 +21,7 @@\n #include \"native/InternalNativePriv.h\"\n \n #include <signal.h>\n+#include <sys/resource.h>\n #include <sys/types.h>\n #include <sys/wait.h>\n #include <grp.h>\n```\n\n`/usr/include/zlib.h:34: fatal error: zconf.h: No such file or directory`\n\nFix:\n\n```bash\nsudo ln -s /usr/include/x86_64-linux-gnu/zconf.h /usr/include\n```\n\n*编译成功后:*\n\n去twrp 下载对应的recovery 的 image.\n\n```bash\nfastboot flash recovery twrp.img\nadb reboot bootloader\n```\n\n从bootloader 进入recovery模式，进行双清后，重新进入bootloader，使用一下命令进行刷机.\n\n```bash\nadb reboot bootloader\nfastboot -w flashall\n```\n\n","slug":"android2.3.1-build","published":1,"updated":"2018-08-13T15:08:24.424Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwhp0001rmujf21lx0cz","content":"<p>##前言</p>\n<p>&ensp;&ensp;&ensp;&ensp;一直想系统的把android的内容重新捋一遍，今天京东优惠，66入了<code>《Android系统源代码情景分析》</code>，这书是基于android2.3.1来说明的，为了和方便真机编译与调试，入了nexus s. 好了话不多说，直接上 命令以及error的fix工作.</p>\n<h2 id=\"android2-3-1编译\"><a href=\"#android2-3-1编译\" class=\"headerlink\" title=\"android2.3.1编译\"></a>android2.3.1编译</h2><p>我的环境:</p>\n<p>系统环境为<code>ubuntu 14.04</code></p>\n<p>jdk使用 <code>jdk1.6.0_45</code></p>\n<pre><code class=\"bash\">repo init -u https://android.googlesource.com/platform/manifest -b android-2.3.1_r1\nrepo sync -j4\n</code></pre>\n<p><strong>gcc downgrade:</strong></p>\n<pre><code class=\"bash\">sudo apt-get install g++-4.4-multilib\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.4 20 --slave /usr/bin/g++ g++ /usr/bin/g++-4.4\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 20 --slave /usr/bin/g++ g++ /usr/bin/g++-4.8\nsudo update-alternatives --config gcc\n</code></pre>\n<p><code>去google aosp 官网下载对应的driver sh 脚本， 运行生成vendor</code></p>\n<pre><code class=\"bash\">$ source build/envsetup.sh\n$ lunch\n$ full_crespo-userdebug\n$ make (这边千万别使用-j, 会引起多线程编译build error)\n</code></pre>\n<p><strong>以下是build时产生的error以及处理：</strong></p>\n<p><code>error:Can&#39;t locate Switch.pm in @INC</code></p>\n<pre><code class=\"bash\">sudo apt-get install libswitch-perl\n</code></pre>\n<p><code>dalvik/vm/native/dalvik_system_Zygote.c:191: error: storage size of ‘rlim’ isn’t known</code></p>\n<p>Fix:</p>\n<pre><code class=\"bash\">diff --git a/vm/native/dalvik_system_Zygote.c b/vm/native/dalvik_system_Zygote.c\nindex bcc2313..112563a 100644\n--- a/vm/native/dalvik_system_Zygote.c\n+++ b/vm/native/dalvik_system_Zygote.c\n@@ -21,6 +21,7 @@\n #include &quot;native/InternalNativePriv.h&quot;\n\n #include &lt;signal.h&gt;\n+#include &lt;sys/resource.h&gt;\n #include &lt;sys/types.h&gt;\n #include &lt;sys/wait.h&gt;\n #include &lt;grp.h&gt;\n</code></pre>\n<p><code>/usr/include/zlib.h:34: fatal error: zconf.h: No such file or directory</code></p>\n<p>Fix:</p>\n<pre><code class=\"bash\">sudo ln -s /usr/include/x86_64-linux-gnu/zconf.h /usr/include\n</code></pre>\n<p><em>编译成功后:</em></p>\n<p>去twrp 下载对应的recovery 的 image.</p>\n<pre><code class=\"bash\">fastboot flash recovery twrp.img\nadb reboot bootloader\n</code></pre>\n<p>从bootloader 进入recovery模式，进行双清后，重新进入bootloader，使用一下命令进行刷机.</p>\n<pre><code class=\"bash\">adb reboot bootloader\nfastboot -w flashall\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>##前言</p>\n<p>&ensp;&ensp;&ensp;&ensp;一直想系统的把android的内容重新捋一遍，今天京东优惠，66入了<code>《Android系统源代码情景分析》</code>，这书是基于android2.3.1来说明的，为了和方便真机编译与调试，入了nexus s. 好了话不多说，直接上 命令以及error的fix工作.</p>\n<h2 id=\"android2-3-1编译\"><a href=\"#android2-3-1编译\" class=\"headerlink\" title=\"android2.3.1编译\"></a>android2.3.1编译</h2><p>我的环境:</p>\n<p>系统环境为<code>ubuntu 14.04</code></p>\n<p>jdk使用 <code>jdk1.6.0_45</code></p>\n<pre><code class=\"bash\">repo init -u https://android.googlesource.com/platform/manifest -b android-2.3.1_r1\nrepo sync -j4\n</code></pre>\n<p><strong>gcc downgrade:</strong></p>\n<pre><code class=\"bash\">sudo apt-get install g++-4.4-multilib\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.4 20 --slave /usr/bin/g++ g++ /usr/bin/g++-4.4\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 20 --slave /usr/bin/g++ g++ /usr/bin/g++-4.8\nsudo update-alternatives --config gcc\n</code></pre>\n<p><code>去google aosp 官网下载对应的driver sh 脚本， 运行生成vendor</code></p>\n<pre><code class=\"bash\">$ source build/envsetup.sh\n$ lunch\n$ full_crespo-userdebug\n$ make (这边千万别使用-j, 会引起多线程编译build error)\n</code></pre>\n<p><strong>以下是build时产生的error以及处理：</strong></p>\n<p><code>error:Can&#39;t locate Switch.pm in @INC</code></p>\n<pre><code class=\"bash\">sudo apt-get install libswitch-perl\n</code></pre>\n<p><code>dalvik/vm/native/dalvik_system_Zygote.c:191: error: storage size of ‘rlim’ isn’t known</code></p>\n<p>Fix:</p>\n<pre><code class=\"bash\">diff --git a/vm/native/dalvik_system_Zygote.c b/vm/native/dalvik_system_Zygote.c\nindex bcc2313..112563a 100644\n--- a/vm/native/dalvik_system_Zygote.c\n+++ b/vm/native/dalvik_system_Zygote.c\n@@ -21,6 +21,7 @@\n #include &quot;native/InternalNativePriv.h&quot;\n\n #include &lt;signal.h&gt;\n+#include &lt;sys/resource.h&gt;\n #include &lt;sys/types.h&gt;\n #include &lt;sys/wait.h&gt;\n #include &lt;grp.h&gt;\n</code></pre>\n<p><code>/usr/include/zlib.h:34: fatal error: zconf.h: No such file or directory</code></p>\n<p>Fix:</p>\n<pre><code class=\"bash\">sudo ln -s /usr/include/x86_64-linux-gnu/zconf.h /usr/include\n</code></pre>\n<p><em>编译成功后:</em></p>\n<p>去twrp 下载对应的recovery 的 image.</p>\n<pre><code class=\"bash\">fastboot flash recovery twrp.img\nadb reboot bootloader\n</code></pre>\n<p>从bootloader 进入recovery模式，进行双清后，重新进入bootloader，使用一下命令进行刷机.</p>\n<pre><code class=\"bash\">adb reboot bootloader\nfastboot -w flashall\n</code></pre>\n"},{"title":"gradle问题","date":"2017-01-15T14:54:34.000Z","_content":"## gradle 常见脚本\n\n`编译出来的apk重命名`:\n```xml\nandroid.applicationVariants.all { variant ->\n    variant.outputs.each { output ->\n        def outputFile = output.outputFile\n        if (outputFile != null && outputFile.name.endsWith('.apk')) {\n            def fileName = outputFile.name.replace(\".apk\", \"-${defaultConfig.versionCode}.apk\")\n            output.outputFile = new File(outputFile.parent, fileName)\n        }\n    }\n}\n```\n\n`productFlavors`:多版本编译apk(eg.大陆版/欧美版/台湾版)\n```xml\nproductFlavors {\n    generic {\n        buildConfigField \"boolean\", \"MOBILE\", \"false\"\n        buildConfigField \"String\", \"UPDATE_URL\", \"/api/xxx\"\n    }\n    china {\n        buildConfigField \"boolean\", \"MOBILE\", \"true\"\n        buildConfigField \"String\", \"UPDATE_URL\", \"/api/yyy\"\n     \n    }\n    link {\n        buildConfigField \"boolean\", \"MOBILE\", \"false\"\n        buildConfigField \"String\", \"UPDATE_URL\", \"/api/zzz\"\n    }\n}\n```\n\n`signingConfigs`:\n```xml\nsigningConfigs {\n    debug_key {\n        keyAlias 'androiddebugkey'\n        keyPassword 'android'\n        storePassword 'android'\n        storeFile file('keys/debug.keystore')\n\n    }\n    HMS_release_key {\n        keyAlias 'platform'\n        keyPassword 'android'\n        storePassword 'android'\n        storeFile file('keys/release.keystore')\n    }\n}\n```\n\n`buildTypes`: depends: `signingConfigs`\n```xml\nbuildTypes {\n    release {\n        minifyEnabled false\n        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        signingConfig signingConfigs.release_key\n        buildConfigField \"boolean\", \"DEBUG_MODE\", \"false\"\n    }\n    debug {\n        minifyEnabled = false\n        signingConfig signingConfigs.debug_key\n        buildConfigField \"boolean\", \"DEBUG_MODE\", \"true\"\n    }\n}\n```\n## 使用国内repositories镜像\n\nvim /home/XXX/.gradle/init.gradle\n\n```xml\nallprojects{\n    repositories {\n        def ALIYUN_REPOSITORY_URL = 'http://maven.aliyun.com/nexus/content/groups/public'\n        def ALIYUN_JCENTER_URL = 'http://maven.aliyun.com/nexus/content/repositories/jcenter'\n        all { ArtifactRepository repo ->\n            if(repo instanceof MavenArtifactRepository){\n                def url = repo.url.toString()\n                if (url.startsWith('https://repo1.maven.org/maven2')) {\n                    project.logger.lifecycle \"Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL.\"\n                    remove repo\n                }\n                if (url.startsWith('https://jcenter.bintray.com/')) {\n                    project.logger.lifecycle \"Repository ${repo.url} replaced by $ALIYUN_JCENTER_URL.\"\n                    remove repo\n                }\n            }\n        }\n        maven {\n                url ALIYUN_REPOSITORY_URL\n            url ALIYUN_JCENTER_URL\n        }\n    }\n}\n```\n\n## 项目打包发布\n\n1. Android 项目打包\n\n`gradlew assemble`\n\n2. Desktop/HTML 项目打包\n\n`gradlew dist`\n\nDesktop: \n\n执行这个命令，将在项目的 `build/libs/` 文件夹下创建一个可运行的 jar 包。这个 jar 包中包含了所有需要的代码和资源，可以脱离整个项目，只要有 JDK 或 JRE 环境即可运行。运行这个 JAR 文件的命令： `java -jar jar-file-name.jar`。\n\n```xml\ntask dist(type: FatCapsule) {\n\tapplicationClass mainClass\n\tarchiveName project.name + \".jar\"\n\tcapsuleManifest {\n\t\tsystemProperties['log4j.configuration'] = 'log4j.xml'\n\t\tjvmArgs = ['-Xms768m', '-Xmx1g']\n\t\tminJavaVersion = '1.6.0'\n\t}\n}\n```\n\nHTML: \n\n执行这个命令，将会把整个应用编译为一个静态的 WEB 应用，将在项目的 html/build/dist/ 文件夹下生产 JavaScript、HTML、asset 文件，这些文件组成的静态 WEB 应用可以脱离 Java 环境，部署在任何支持 HTML 和 JavaScript 的 WEB 服务器上，并通过任何支持 WebGL 的浏览器上访问并运行。\n\n注意： 执行打包命令后，在 html/build/dist/ 目录下会生成一个 `WEB-INF` 文件夹，这个文件夹占用了较大的空间，对于一般的 WEB 服务器没有用，可以删掉。\n\n3. library 编译Jar包\n\n`gradlew makeJar`\n\n```xml\ntask makeJar(type: Copy) {\n    delete 'libs/libmedia.jar'\n    from('build/intermediates/bundles/default/')\n    into('libs/')\n    include('classes.jar')\n    rename ('classes.jar', 'libmedia.jar')\n}\nmakeJar.dependsOn(build)\n```","source":"_posts/Android/gradle.md","raw":"---\ntitle: gradle问题\npermalink: gradle-issue\ncategories:\n  - Android\ntags:\n  - gradle\n  - 面试\ndate: 2017-01-15 22:54:34\n---\n## gradle 常见脚本\n\n`编译出来的apk重命名`:\n```xml\nandroid.applicationVariants.all { variant ->\n    variant.outputs.each { output ->\n        def outputFile = output.outputFile\n        if (outputFile != null && outputFile.name.endsWith('.apk')) {\n            def fileName = outputFile.name.replace(\".apk\", \"-${defaultConfig.versionCode}.apk\")\n            output.outputFile = new File(outputFile.parent, fileName)\n        }\n    }\n}\n```\n\n`productFlavors`:多版本编译apk(eg.大陆版/欧美版/台湾版)\n```xml\nproductFlavors {\n    generic {\n        buildConfigField \"boolean\", \"MOBILE\", \"false\"\n        buildConfigField \"String\", \"UPDATE_URL\", \"/api/xxx\"\n    }\n    china {\n        buildConfigField \"boolean\", \"MOBILE\", \"true\"\n        buildConfigField \"String\", \"UPDATE_URL\", \"/api/yyy\"\n     \n    }\n    link {\n        buildConfigField \"boolean\", \"MOBILE\", \"false\"\n        buildConfigField \"String\", \"UPDATE_URL\", \"/api/zzz\"\n    }\n}\n```\n\n`signingConfigs`:\n```xml\nsigningConfigs {\n    debug_key {\n        keyAlias 'androiddebugkey'\n        keyPassword 'android'\n        storePassword 'android'\n        storeFile file('keys/debug.keystore')\n\n    }\n    HMS_release_key {\n        keyAlias 'platform'\n        keyPassword 'android'\n        storePassword 'android'\n        storeFile file('keys/release.keystore')\n    }\n}\n```\n\n`buildTypes`: depends: `signingConfigs`\n```xml\nbuildTypes {\n    release {\n        minifyEnabled false\n        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        signingConfig signingConfigs.release_key\n        buildConfigField \"boolean\", \"DEBUG_MODE\", \"false\"\n    }\n    debug {\n        minifyEnabled = false\n        signingConfig signingConfigs.debug_key\n        buildConfigField \"boolean\", \"DEBUG_MODE\", \"true\"\n    }\n}\n```\n## 使用国内repositories镜像\n\nvim /home/XXX/.gradle/init.gradle\n\n```xml\nallprojects{\n    repositories {\n        def ALIYUN_REPOSITORY_URL = 'http://maven.aliyun.com/nexus/content/groups/public'\n        def ALIYUN_JCENTER_URL = 'http://maven.aliyun.com/nexus/content/repositories/jcenter'\n        all { ArtifactRepository repo ->\n            if(repo instanceof MavenArtifactRepository){\n                def url = repo.url.toString()\n                if (url.startsWith('https://repo1.maven.org/maven2')) {\n                    project.logger.lifecycle \"Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL.\"\n                    remove repo\n                }\n                if (url.startsWith('https://jcenter.bintray.com/')) {\n                    project.logger.lifecycle \"Repository ${repo.url} replaced by $ALIYUN_JCENTER_URL.\"\n                    remove repo\n                }\n            }\n        }\n        maven {\n                url ALIYUN_REPOSITORY_URL\n            url ALIYUN_JCENTER_URL\n        }\n    }\n}\n```\n\n## 项目打包发布\n\n1. Android 项目打包\n\n`gradlew assemble`\n\n2. Desktop/HTML 项目打包\n\n`gradlew dist`\n\nDesktop: \n\n执行这个命令，将在项目的 `build/libs/` 文件夹下创建一个可运行的 jar 包。这个 jar 包中包含了所有需要的代码和资源，可以脱离整个项目，只要有 JDK 或 JRE 环境即可运行。运行这个 JAR 文件的命令： `java -jar jar-file-name.jar`。\n\n```xml\ntask dist(type: FatCapsule) {\n\tapplicationClass mainClass\n\tarchiveName project.name + \".jar\"\n\tcapsuleManifest {\n\t\tsystemProperties['log4j.configuration'] = 'log4j.xml'\n\t\tjvmArgs = ['-Xms768m', '-Xmx1g']\n\t\tminJavaVersion = '1.6.0'\n\t}\n}\n```\n\nHTML: \n\n执行这个命令，将会把整个应用编译为一个静态的 WEB 应用，将在项目的 html/build/dist/ 文件夹下生产 JavaScript、HTML、asset 文件，这些文件组成的静态 WEB 应用可以脱离 Java 环境，部署在任何支持 HTML 和 JavaScript 的 WEB 服务器上，并通过任何支持 WebGL 的浏览器上访问并运行。\n\n注意： 执行打包命令后，在 html/build/dist/ 目录下会生成一个 `WEB-INF` 文件夹，这个文件夹占用了较大的空间，对于一般的 WEB 服务器没有用，可以删掉。\n\n3. library 编译Jar包\n\n`gradlew makeJar`\n\n```xml\ntask makeJar(type: Copy) {\n    delete 'libs/libmedia.jar'\n    from('build/intermediates/bundles/default/')\n    into('libs/')\n    include('classes.jar')\n    rename ('classes.jar', 'libmedia.jar')\n}\nmakeJar.dependsOn(build)\n```","slug":"gradle-issue","published":1,"updated":"2018-08-19T10:53:59.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwhr0004rmujao0rcmwa","content":"<h2 id=\"gradle-常见脚本\"><a href=\"#gradle-常见脚本\" class=\"headerlink\" title=\"gradle 常见脚本\"></a>gradle 常见脚本</h2><p><code>编译出来的apk重命名</code>:</p>\n<pre><code class=\"xml\">android.applicationVariants.all { variant -&gt;\n    variant.outputs.each { output -&gt;\n        def outputFile = output.outputFile\n        if (outputFile != null &amp;&amp; outputFile.name.endsWith(&#39;.apk&#39;)) {\n            def fileName = outputFile.name.replace(&quot;.apk&quot;, &quot;-${defaultConfig.versionCode}.apk&quot;)\n            output.outputFile = new File(outputFile.parent, fileName)\n        }\n    }\n}\n</code></pre>\n<p><code>productFlavors</code>:多版本编译apk(eg.大陆版/欧美版/台湾版)</p>\n<pre><code class=\"xml\">productFlavors {\n    generic {\n        buildConfigField &quot;boolean&quot;, &quot;MOBILE&quot;, &quot;false&quot;\n        buildConfigField &quot;String&quot;, &quot;UPDATE_URL&quot;, &quot;/api/xxx&quot;\n    }\n    china {\n        buildConfigField &quot;boolean&quot;, &quot;MOBILE&quot;, &quot;true&quot;\n        buildConfigField &quot;String&quot;, &quot;UPDATE_URL&quot;, &quot;/api/yyy&quot;\n\n    }\n    link {\n        buildConfigField &quot;boolean&quot;, &quot;MOBILE&quot;, &quot;false&quot;\n        buildConfigField &quot;String&quot;, &quot;UPDATE_URL&quot;, &quot;/api/zzz&quot;\n    }\n}\n</code></pre>\n<p><code>signingConfigs</code>:</p>\n<pre><code class=\"xml\">signingConfigs {\n    debug_key {\n        keyAlias &#39;androiddebugkey&#39;\n        keyPassword &#39;android&#39;\n        storePassword &#39;android&#39;\n        storeFile file(&#39;keys/debug.keystore&#39;)\n\n    }\n    HMS_release_key {\n        keyAlias &#39;platform&#39;\n        keyPassword &#39;android&#39;\n        storePassword &#39;android&#39;\n        storeFile file(&#39;keys/release.keystore&#39;)\n    }\n}\n</code></pre>\n<p><code>buildTypes</code>: depends: <code>signingConfigs</code></p>\n<pre><code class=\"xml\">buildTypes {\n    release {\n        minifyEnabled false\n        proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;\n        signingConfig signingConfigs.release_key\n        buildConfigField &quot;boolean&quot;, &quot;DEBUG_MODE&quot;, &quot;false&quot;\n    }\n    debug {\n        minifyEnabled = false\n        signingConfig signingConfigs.debug_key\n        buildConfigField &quot;boolean&quot;, &quot;DEBUG_MODE&quot;, &quot;true&quot;\n    }\n}\n</code></pre>\n<h2 id=\"使用国内repositories镜像\"><a href=\"#使用国内repositories镜像\" class=\"headerlink\" title=\"使用国内repositories镜像\"></a>使用国内repositories镜像</h2><p>vim /home/XXX/.gradle/init.gradle</p>\n<pre><code class=\"xml\">allprojects{\n    repositories {\n        def ALIYUN_REPOSITORY_URL = &#39;http://maven.aliyun.com/nexus/content/groups/public&#39;\n        def ALIYUN_JCENTER_URL = &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;\n        all { ArtifactRepository repo -&gt;\n            if(repo instanceof MavenArtifactRepository){\n                def url = repo.url.toString()\n                if (url.startsWith(&#39;https://repo1.maven.org/maven2&#39;)) {\n                    project.logger.lifecycle &quot;Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL.&quot;\n                    remove repo\n                }\n                if (url.startsWith(&#39;https://jcenter.bintray.com/&#39;)) {\n                    project.logger.lifecycle &quot;Repository ${repo.url} replaced by $ALIYUN_JCENTER_URL.&quot;\n                    remove repo\n                }\n            }\n        }\n        maven {\n                url ALIYUN_REPOSITORY_URL\n            url ALIYUN_JCENTER_URL\n        }\n    }\n}\n</code></pre>\n<h2 id=\"项目打包发布\"><a href=\"#项目打包发布\" class=\"headerlink\" title=\"项目打包发布\"></a>项目打包发布</h2><ol>\n<li>Android 项目打包</li>\n</ol>\n<p><code>gradlew assemble</code></p>\n<ol>\n<li>Desktop/HTML 项目打包</li>\n</ol>\n<p><code>gradlew dist</code></p>\n<p>Desktop: </p>\n<p>执行这个命令，将在项目的 <code>build/libs/</code> 文件夹下创建一个可运行的 jar 包。这个 jar 包中包含了所有需要的代码和资源，可以脱离整个项目，只要有 JDK 或 JRE 环境即可运行。运行这个 JAR 文件的命令： <code>java -jar jar-file-name.jar</code>。</p>\n<pre><code class=\"xml\">task dist(type: FatCapsule) {\n    applicationClass mainClass\n    archiveName project.name + &quot;.jar&quot;\n    capsuleManifest {\n        systemProperties[&#39;log4j.configuration&#39;] = &#39;log4j.xml&#39;\n        jvmArgs = [&#39;-Xms768m&#39;, &#39;-Xmx1g&#39;]\n        minJavaVersion = &#39;1.6.0&#39;\n    }\n}\n</code></pre>\n<p>HTML: </p>\n<p>执行这个命令，将会把整个应用编译为一个静态的 WEB 应用，将在项目的 html/build/dist/ 文件夹下生产 JavaScript、HTML、asset 文件，这些文件组成的静态 WEB 应用可以脱离 Java 环境，部署在任何支持 HTML 和 JavaScript 的 WEB 服务器上，并通过任何支持 WebGL 的浏览器上访问并运行。</p>\n<p>注意： 执行打包命令后，在 html/build/dist/ 目录下会生成一个 <code>WEB-INF</code> 文件夹，这个文件夹占用了较大的空间，对于一般的 WEB 服务器没有用，可以删掉。</p>\n<ol>\n<li>library 编译Jar包</li>\n</ol>\n<p><code>gradlew makeJar</code></p>\n<pre><code class=\"xml\">task makeJar(type: Copy) {\n    delete &#39;libs/libmedia.jar&#39;\n    from(&#39;build/intermediates/bundles/default/&#39;)\n    into(&#39;libs/&#39;)\n    include(&#39;classes.jar&#39;)\n    rename (&#39;classes.jar&#39;, &#39;libmedia.jar&#39;)\n}\nmakeJar.dependsOn(build)\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"gradle-常见脚本\"><a href=\"#gradle-常见脚本\" class=\"headerlink\" title=\"gradle 常见脚本\"></a>gradle 常见脚本</h2><p><code>编译出来的apk重命名</code>:</p>\n<pre><code class=\"xml\">android.applicationVariants.all { variant -&gt;\n    variant.outputs.each { output -&gt;\n        def outputFile = output.outputFile\n        if (outputFile != null &amp;&amp; outputFile.name.endsWith(&#39;.apk&#39;)) {\n            def fileName = outputFile.name.replace(&quot;.apk&quot;, &quot;-${defaultConfig.versionCode}.apk&quot;)\n            output.outputFile = new File(outputFile.parent, fileName)\n        }\n    }\n}\n</code></pre>\n<p><code>productFlavors</code>:多版本编译apk(eg.大陆版/欧美版/台湾版)</p>\n<pre><code class=\"xml\">productFlavors {\n    generic {\n        buildConfigField &quot;boolean&quot;, &quot;MOBILE&quot;, &quot;false&quot;\n        buildConfigField &quot;String&quot;, &quot;UPDATE_URL&quot;, &quot;/api/xxx&quot;\n    }\n    china {\n        buildConfigField &quot;boolean&quot;, &quot;MOBILE&quot;, &quot;true&quot;\n        buildConfigField &quot;String&quot;, &quot;UPDATE_URL&quot;, &quot;/api/yyy&quot;\n\n    }\n    link {\n        buildConfigField &quot;boolean&quot;, &quot;MOBILE&quot;, &quot;false&quot;\n        buildConfigField &quot;String&quot;, &quot;UPDATE_URL&quot;, &quot;/api/zzz&quot;\n    }\n}\n</code></pre>\n<p><code>signingConfigs</code>:</p>\n<pre><code class=\"xml\">signingConfigs {\n    debug_key {\n        keyAlias &#39;androiddebugkey&#39;\n        keyPassword &#39;android&#39;\n        storePassword &#39;android&#39;\n        storeFile file(&#39;keys/debug.keystore&#39;)\n\n    }\n    HMS_release_key {\n        keyAlias &#39;platform&#39;\n        keyPassword &#39;android&#39;\n        storePassword &#39;android&#39;\n        storeFile file(&#39;keys/release.keystore&#39;)\n    }\n}\n</code></pre>\n<p><code>buildTypes</code>: depends: <code>signingConfigs</code></p>\n<pre><code class=\"xml\">buildTypes {\n    release {\n        minifyEnabled false\n        proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;\n        signingConfig signingConfigs.release_key\n        buildConfigField &quot;boolean&quot;, &quot;DEBUG_MODE&quot;, &quot;false&quot;\n    }\n    debug {\n        minifyEnabled = false\n        signingConfig signingConfigs.debug_key\n        buildConfigField &quot;boolean&quot;, &quot;DEBUG_MODE&quot;, &quot;true&quot;\n    }\n}\n</code></pre>\n<h2 id=\"使用国内repositories镜像\"><a href=\"#使用国内repositories镜像\" class=\"headerlink\" title=\"使用国内repositories镜像\"></a>使用国内repositories镜像</h2><p>vim /home/XXX/.gradle/init.gradle</p>\n<pre><code class=\"xml\">allprojects{\n    repositories {\n        def ALIYUN_REPOSITORY_URL = &#39;http://maven.aliyun.com/nexus/content/groups/public&#39;\n        def ALIYUN_JCENTER_URL = &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;\n        all { ArtifactRepository repo -&gt;\n            if(repo instanceof MavenArtifactRepository){\n                def url = repo.url.toString()\n                if (url.startsWith(&#39;https://repo1.maven.org/maven2&#39;)) {\n                    project.logger.lifecycle &quot;Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL.&quot;\n                    remove repo\n                }\n                if (url.startsWith(&#39;https://jcenter.bintray.com/&#39;)) {\n                    project.logger.lifecycle &quot;Repository ${repo.url} replaced by $ALIYUN_JCENTER_URL.&quot;\n                    remove repo\n                }\n            }\n        }\n        maven {\n                url ALIYUN_REPOSITORY_URL\n            url ALIYUN_JCENTER_URL\n        }\n    }\n}\n</code></pre>\n<h2 id=\"项目打包发布\"><a href=\"#项目打包发布\" class=\"headerlink\" title=\"项目打包发布\"></a>项目打包发布</h2><ol>\n<li>Android 项目打包</li>\n</ol>\n<p><code>gradlew assemble</code></p>\n<ol>\n<li>Desktop/HTML 项目打包</li>\n</ol>\n<p><code>gradlew dist</code></p>\n<p>Desktop: </p>\n<p>执行这个命令，将在项目的 <code>build/libs/</code> 文件夹下创建一个可运行的 jar 包。这个 jar 包中包含了所有需要的代码和资源，可以脱离整个项目，只要有 JDK 或 JRE 环境即可运行。运行这个 JAR 文件的命令： <code>java -jar jar-file-name.jar</code>。</p>\n<pre><code class=\"xml\">task dist(type: FatCapsule) {\n    applicationClass mainClass\n    archiveName project.name + &quot;.jar&quot;\n    capsuleManifest {\n        systemProperties[&#39;log4j.configuration&#39;] = &#39;log4j.xml&#39;\n        jvmArgs = [&#39;-Xms768m&#39;, &#39;-Xmx1g&#39;]\n        minJavaVersion = &#39;1.6.0&#39;\n    }\n}\n</code></pre>\n<p>HTML: </p>\n<p>执行这个命令，将会把整个应用编译为一个静态的 WEB 应用，将在项目的 html/build/dist/ 文件夹下生产 JavaScript、HTML、asset 文件，这些文件组成的静态 WEB 应用可以脱离 Java 环境，部署在任何支持 HTML 和 JavaScript 的 WEB 服务器上，并通过任何支持 WebGL 的浏览器上访问并运行。</p>\n<p>注意： 执行打包命令后，在 html/build/dist/ 目录下会生成一个 <code>WEB-INF</code> 文件夹，这个文件夹占用了较大的空间，对于一般的 WEB 服务器没有用，可以删掉。</p>\n<ol>\n<li>library 编译Jar包</li>\n</ol>\n<p><code>gradlew makeJar</code></p>\n<pre><code class=\"xml\">task makeJar(type: Copy) {\n    delete &#39;libs/libmedia.jar&#39;\n    from(&#39;build/intermediates/bundles/default/&#39;)\n    into(&#39;libs/&#39;)\n    include(&#39;classes.jar&#39;)\n    rename (&#39;classes.jar&#39;, &#39;libmedia.jar&#39;)\n}\nmakeJar.dependsOn(build)\n</code></pre>\n"},{"title":"Linux常用压缩、解压对比","date":"2016-01-15T14:54:34.000Z","_content":"\n先上结论:\n\n`结论`：\n是空间与时间的选择。\n\n压缩比率：\ntar.bz2>tgz>tar\n\n\n占用空间：\ntar.bz2<tgz<tar\n\n打包耗时:\ntar.bz2>tgz>tar\n\n解压耗时:\ntar.bz2>tar>tgz\n\nLinux下对于占用空间与耗费时间的折衷多选用`tgz`格式，不仅压缩率较高，而且打包、解压的时间都较为快速，是较为理想的选择。\n\n所以我选择`tgz`.\n\n常用的格式有：\ntar, tar.gz(tgz), tar.bz2,\n\n不同方式，压缩和解压方式所耗CPU时间和压缩比率也差异也比较大。\n\n## tar\n只是打包动作，相当于归档处理，不做压缩；解压也一样，只是把归档文件释放出来。\n\n(1)打包归档格式：\n```bash\ntar -cvf examples.tar files|dir\n```\n\n`说明：`\n```xml\n-c, --create  create a new archive 创建一个归档文件\n-v, --verbose verbosely list files processed 显示创建归档文件的进程\n-f, --file=ARCHIVE use archive file or device ARCHIVE  后面要立刻接被处理的档案名,比如--file=examples.tar\n```\n\n`举例：`\n```bash\ntar -cvf file.tar file1       #file1文件\ntar -cvf file.tar file1 file2 #file1，file2文件\ntar -cvf file.tar dir         #dir目录\n```\n\n(2)释放解压格式：\n```bash\ntar -xvf examples.tar （解压至当前目录下）\ntar -xvf examples.tar  -C /path (/path 解压至其它路径)\n```\n\n`说明：`\n```xml\n-x, --extract, extract files from an archive 从一个归档文件中提取文件\n```\n\n`举例：`\n```bash\ntar -xvf file.tar\ntar -xvf file.tar -C /temp  #解压到temp目录下\n```\n\n## tar.gz tgz\n\n`tar.gz和tgz只是两种不同的书写方式，后者是一种简化书写，等同处理`\n\n这种格式是Linux下使用非常普遍的一种压缩方式，\n兼顾了压缩时间（耗费CPU）和压缩空间（压缩比率）\n其实这是对tar包进行gzip算法的压缩\n\n(1)打包压缩格式：\n```bash\ntar -zcvf examples.tgz examples (examples当前执行路径下的目录)\n```\n\n`说明：`\n```xml\n-z, --gzip filter the archive through gzip 通过gzip压缩的形式对文件进行归档\n```\n\n`举例：`\n```bash\ntar -zcvf file.tgz dir #dir目录\n```\n\n(2)释放解压格式：\n```bash\ntar -zxvf examples.tar （解压至当前执行目录下）\ntar -zxvf examples.tar  -C /path (/path 解压至其它路径)\n```\n\n`举例：`\n```xml\ntar -zcvf file.tgz\ntar -zcvf file.tgz -C /temp\n```\n\n## tar.bz\n\nLinux下压缩比率较tgz大，即压缩后占用更小的空间，使得压缩包看起来更小。\n但同时在压缩，解压的过程却是非常耗费CPU时间。\n\n(1)打包压缩格式：\n\n```bash\ntar -jcvf examples.tar.bz2 examples   (examples为当前执行路径下的目录)\n```\n\n`说明：`\n```xml\n-j, --bzip2 filter the archive through bzip2 通过bzip2压缩的形式对文件进行归档\n```\n\n`举例：`\n```xml\ntar -jcvf file.tar.bz2 dir #dir目录\n```\n\n(2)释放解压：\n```bash\ntar -jxvf examples.tar.bz2 （解压至当前执行目录下）\ntar -jxvf examples.tar.bz2  -C /path (/path 解压至其它路径)\n```\n\n`举例：`\n```xml\ntar -jxvf file.tar.bz2\ntar -jxvf file.tar.bz2 -C /temp\n ```\n\n## gz\n压缩：\n```bash\ngzip -d examples.gz examples\n```\n\n解压：\n```bash\ngunzip examples.gz\n```\n\n## zip\nzip 格式是开放且免费的，所以广泛使用在 Windows、Linux、MacOS 平台，要说 zip 有什么缺点的话，就是它的压缩率并不是很高，不如 rar及 tar.gz 等格式。\n压缩：\n```bash\nzip -r examples.zip examples (examples为目录)\n```\n解压：\n```bash\nzip examples.zip\n```\n## .rar\n压缩：\n```bash\nrar -a examples.rar examples\n```\n解压：\n```bash\nrar -x examples.rar\n```\n \n\n压缩比率，占用时间对比\n\n为了保证能够让压缩比率较为明显，需选取一个内容较多、占用空间较大的目录作为本次实验的测试。\n找了一个大概有23G的目录来测试,首先要明确由于执行环境的变化，误差在所难免\n\n首先明确一个概念：\n压缩比率=原内容大小/压缩后大小，压缩比率越大，则表明压缩后占用空间的压缩包越小\n\n![](https://user-images.githubusercontent.com/35097187/44308296-60b34600-a3e5-11e8-9dd0-35f605880467.png)\n\n转自:https://www.cnblogs.com/joshua317/p/6170839.html\n","source":"_posts/Android/Linux常用压缩、解压对比.md","raw":"---\ntitle: Linux常用压缩、解压对比\npermalink: zip-unzip-compare\ncategories:\n  - 工具\ntags:\n  - 压缩\ndate: 2016-01-15 22:54:34\n---\n\n先上结论:\n\n`结论`：\n是空间与时间的选择。\n\n压缩比率：\ntar.bz2>tgz>tar\n\n\n占用空间：\ntar.bz2<tgz<tar\n\n打包耗时:\ntar.bz2>tgz>tar\n\n解压耗时:\ntar.bz2>tar>tgz\n\nLinux下对于占用空间与耗费时间的折衷多选用`tgz`格式，不仅压缩率较高，而且打包、解压的时间都较为快速，是较为理想的选择。\n\n所以我选择`tgz`.\n\n常用的格式有：\ntar, tar.gz(tgz), tar.bz2,\n\n不同方式，压缩和解压方式所耗CPU时间和压缩比率也差异也比较大。\n\n## tar\n只是打包动作，相当于归档处理，不做压缩；解压也一样，只是把归档文件释放出来。\n\n(1)打包归档格式：\n```bash\ntar -cvf examples.tar files|dir\n```\n\n`说明：`\n```xml\n-c, --create  create a new archive 创建一个归档文件\n-v, --verbose verbosely list files processed 显示创建归档文件的进程\n-f, --file=ARCHIVE use archive file or device ARCHIVE  后面要立刻接被处理的档案名,比如--file=examples.tar\n```\n\n`举例：`\n```bash\ntar -cvf file.tar file1       #file1文件\ntar -cvf file.tar file1 file2 #file1，file2文件\ntar -cvf file.tar dir         #dir目录\n```\n\n(2)释放解压格式：\n```bash\ntar -xvf examples.tar （解压至当前目录下）\ntar -xvf examples.tar  -C /path (/path 解压至其它路径)\n```\n\n`说明：`\n```xml\n-x, --extract, extract files from an archive 从一个归档文件中提取文件\n```\n\n`举例：`\n```bash\ntar -xvf file.tar\ntar -xvf file.tar -C /temp  #解压到temp目录下\n```\n\n## tar.gz tgz\n\n`tar.gz和tgz只是两种不同的书写方式，后者是一种简化书写，等同处理`\n\n这种格式是Linux下使用非常普遍的一种压缩方式，\n兼顾了压缩时间（耗费CPU）和压缩空间（压缩比率）\n其实这是对tar包进行gzip算法的压缩\n\n(1)打包压缩格式：\n```bash\ntar -zcvf examples.tgz examples (examples当前执行路径下的目录)\n```\n\n`说明：`\n```xml\n-z, --gzip filter the archive through gzip 通过gzip压缩的形式对文件进行归档\n```\n\n`举例：`\n```bash\ntar -zcvf file.tgz dir #dir目录\n```\n\n(2)释放解压格式：\n```bash\ntar -zxvf examples.tar （解压至当前执行目录下）\ntar -zxvf examples.tar  -C /path (/path 解压至其它路径)\n```\n\n`举例：`\n```xml\ntar -zcvf file.tgz\ntar -zcvf file.tgz -C /temp\n```\n\n## tar.bz\n\nLinux下压缩比率较tgz大，即压缩后占用更小的空间，使得压缩包看起来更小。\n但同时在压缩，解压的过程却是非常耗费CPU时间。\n\n(1)打包压缩格式：\n\n```bash\ntar -jcvf examples.tar.bz2 examples   (examples为当前执行路径下的目录)\n```\n\n`说明：`\n```xml\n-j, --bzip2 filter the archive through bzip2 通过bzip2压缩的形式对文件进行归档\n```\n\n`举例：`\n```xml\ntar -jcvf file.tar.bz2 dir #dir目录\n```\n\n(2)释放解压：\n```bash\ntar -jxvf examples.tar.bz2 （解压至当前执行目录下）\ntar -jxvf examples.tar.bz2  -C /path (/path 解压至其它路径)\n```\n\n`举例：`\n```xml\ntar -jxvf file.tar.bz2\ntar -jxvf file.tar.bz2 -C /temp\n ```\n\n## gz\n压缩：\n```bash\ngzip -d examples.gz examples\n```\n\n解压：\n```bash\ngunzip examples.gz\n```\n\n## zip\nzip 格式是开放且免费的，所以广泛使用在 Windows、Linux、MacOS 平台，要说 zip 有什么缺点的话，就是它的压缩率并不是很高，不如 rar及 tar.gz 等格式。\n压缩：\n```bash\nzip -r examples.zip examples (examples为目录)\n```\n解压：\n```bash\nzip examples.zip\n```\n## .rar\n压缩：\n```bash\nrar -a examples.rar examples\n```\n解压：\n```bash\nrar -x examples.rar\n```\n \n\n压缩比率，占用时间对比\n\n为了保证能够让压缩比率较为明显，需选取一个内容较多、占用空间较大的目录作为本次实验的测试。\n找了一个大概有23G的目录来测试,首先要明确由于执行环境的变化，误差在所难免\n\n首先明确一个概念：\n压缩比率=原内容大小/压缩后大小，压缩比率越大，则表明压缩后占用空间的压缩包越小\n\n![](https://user-images.githubusercontent.com/35097187/44308296-60b34600-a3e5-11e8-9dd0-35f605880467.png)\n\n转自:https://www.cnblogs.com/joshua317/p/6170839.html\n","slug":"zip-unzip-compare","published":1,"updated":"2018-08-19T11:30:19.749Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwhs0005rmujjb4p2imu","content":"<p>先上结论:</p>\n<p><code>结论</code>：<br>是空间与时间的选择。</p>\n<p>压缩比率：<br>tar.bz2&gt;tgz&gt;tar</p>\n<p>占用空间：<br>tar.bz2&lt;tgz&lt;tar</p>\n<p>打包耗时:<br>tar.bz2&gt;tgz&gt;tar</p>\n<p>解压耗时:<br>tar.bz2&gt;tar&gt;tgz</p>\n<p>Linux下对于占用空间与耗费时间的折衷多选用<code>tgz</code>格式，不仅压缩率较高，而且打包、解压的时间都较为快速，是较为理想的选择。</p>\n<p>所以我选择<code>tgz</code>.</p>\n<p>常用的格式有：<br>tar, tar.gz(tgz), tar.bz2,</p>\n<p>不同方式，压缩和解压方式所耗CPU时间和压缩比率也差异也比较大。</p>\n<h2 id=\"tar\"><a href=\"#tar\" class=\"headerlink\" title=\"tar\"></a>tar</h2><p>只是打包动作，相当于归档处理，不做压缩；解压也一样，只是把归档文件释放出来。</p>\n<p>(1)打包归档格式：</p>\n<pre><code class=\"bash\">tar -cvf examples.tar files|dir\n</code></pre>\n<p><code>说明：</code></p>\n<pre><code class=\"xml\">-c, --create  create a new archive 创建一个归档文件\n-v, --verbose verbosely list files processed 显示创建归档文件的进程\n-f, --file=ARCHIVE use archive file or device ARCHIVE  后面要立刻接被处理的档案名,比如--file=examples.tar\n</code></pre>\n<p><code>举例：</code></p>\n<pre><code class=\"bash\">tar -cvf file.tar file1       #file1文件\ntar -cvf file.tar file1 file2 #file1，file2文件\ntar -cvf file.tar dir         #dir目录\n</code></pre>\n<p>(2)释放解压格式：</p>\n<pre><code class=\"bash\">tar -xvf examples.tar （解压至当前目录下）\ntar -xvf examples.tar  -C /path (/path 解压至其它路径)\n</code></pre>\n<p><code>说明：</code></p>\n<pre><code class=\"xml\">-x, --extract, extract files from an archive 从一个归档文件中提取文件\n</code></pre>\n<p><code>举例：</code></p>\n<pre><code class=\"bash\">tar -xvf file.tar\ntar -xvf file.tar -C /temp  #解压到temp目录下\n</code></pre>\n<h2 id=\"tar-gz-tgz\"><a href=\"#tar-gz-tgz\" class=\"headerlink\" title=\"tar.gz tgz\"></a>tar.gz tgz</h2><p><code>tar.gz和tgz只是两种不同的书写方式，后者是一种简化书写，等同处理</code></p>\n<p>这种格式是Linux下使用非常普遍的一种压缩方式，<br>兼顾了压缩时间（耗费CPU）和压缩空间（压缩比率）<br>其实这是对tar包进行gzip算法的压缩</p>\n<p>(1)打包压缩格式：</p>\n<pre><code class=\"bash\">tar -zcvf examples.tgz examples (examples当前执行路径下的目录)\n</code></pre>\n<p><code>说明：</code></p>\n<pre><code class=\"xml\">-z, --gzip filter the archive through gzip 通过gzip压缩的形式对文件进行归档\n</code></pre>\n<p><code>举例：</code></p>\n<pre><code class=\"bash\">tar -zcvf file.tgz dir #dir目录\n</code></pre>\n<p>(2)释放解压格式：</p>\n<pre><code class=\"bash\">tar -zxvf examples.tar （解压至当前执行目录下）\ntar -zxvf examples.tar  -C /path (/path 解压至其它路径)\n</code></pre>\n<p><code>举例：</code></p>\n<pre><code class=\"xml\">tar -zcvf file.tgz\ntar -zcvf file.tgz -C /temp\n</code></pre>\n<h2 id=\"tar-bz\"><a href=\"#tar-bz\" class=\"headerlink\" title=\"tar.bz\"></a>tar.bz</h2><p>Linux下压缩比率较tgz大，即压缩后占用更小的空间，使得压缩包看起来更小。<br>但同时在压缩，解压的过程却是非常耗费CPU时间。</p>\n<p>(1)打包压缩格式：</p>\n<pre><code class=\"bash\">tar -jcvf examples.tar.bz2 examples   (examples为当前执行路径下的目录)\n</code></pre>\n<p><code>说明：</code></p>\n<pre><code class=\"xml\">-j, --bzip2 filter the archive through bzip2 通过bzip2压缩的形式对文件进行归档\n</code></pre>\n<p><code>举例：</code></p>\n<pre><code class=\"xml\">tar -jcvf file.tar.bz2 dir #dir目录\n</code></pre>\n<p>(2)释放解压：</p>\n<pre><code class=\"bash\">tar -jxvf examples.tar.bz2 （解压至当前执行目录下）\ntar -jxvf examples.tar.bz2  -C /path (/path 解压至其它路径)\n</code></pre>\n<p><code>举例：</code></p>\n<pre><code class=\"xml\">tar -jxvf file.tar.bz2\ntar -jxvf file.tar.bz2 -C /temp\n</code></pre>\n<h2 id=\"gz\"><a href=\"#gz\" class=\"headerlink\" title=\"gz\"></a>gz</h2><p>压缩：</p>\n<pre><code class=\"bash\">gzip -d examples.gz examples\n</code></pre>\n<p>解压：</p>\n<pre><code class=\"bash\">gunzip examples.gz\n</code></pre>\n<h2 id=\"zip\"><a href=\"#zip\" class=\"headerlink\" title=\"zip\"></a>zip</h2><p>zip 格式是开放且免费的，所以广泛使用在 Windows、Linux、MacOS 平台，要说 zip 有什么缺点的话，就是它的压缩率并不是很高，不如 rar及 tar.gz 等格式。<br>压缩：</p>\n<pre><code class=\"bash\">zip -r examples.zip examples (examples为目录)\n</code></pre>\n<p>解压：</p>\n<pre><code class=\"bash\">zip examples.zip\n</code></pre>\n<h2 id=\"rar\"><a href=\"#rar\" class=\"headerlink\" title=\".rar\"></a>.rar</h2><p>压缩：</p>\n<pre><code class=\"bash\">rar -a examples.rar examples\n</code></pre>\n<p>解压：</p>\n<pre><code class=\"bash\">rar -x examples.rar\n</code></pre>\n<p>压缩比率，占用时间对比</p>\n<p>为了保证能够让压缩比率较为明显，需选取一个内容较多、占用空间较大的目录作为本次实验的测试。<br>找了一个大概有23G的目录来测试,首先要明确由于执行环境的变化，误差在所难免</p>\n<p>首先明确一个概念：<br>压缩比率=原内容大小/压缩后大小，压缩比率越大，则表明压缩后占用空间的压缩包越小</p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44308296-60b34600-a3e5-11e8-9dd0-35f605880467.png\" alt=\"\"></p>\n<p>转自:<a href=\"https://www.cnblogs.com/joshua317/p/6170839.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/joshua317/p/6170839.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>先上结论:</p>\n<p><code>结论</code>：<br>是空间与时间的选择。</p>\n<p>压缩比率：<br>tar.bz2&gt;tgz&gt;tar</p>\n<p>占用空间：<br>tar.bz2&lt;tgz&lt;tar</p>\n<p>打包耗时:<br>tar.bz2&gt;tgz&gt;tar</p>\n<p>解压耗时:<br>tar.bz2&gt;tar&gt;tgz</p>\n<p>Linux下对于占用空间与耗费时间的折衷多选用<code>tgz</code>格式，不仅压缩率较高，而且打包、解压的时间都较为快速，是较为理想的选择。</p>\n<p>所以我选择<code>tgz</code>.</p>\n<p>常用的格式有：<br>tar, tar.gz(tgz), tar.bz2,</p>\n<p>不同方式，压缩和解压方式所耗CPU时间和压缩比率也差异也比较大。</p>\n<h2 id=\"tar\"><a href=\"#tar\" class=\"headerlink\" title=\"tar\"></a>tar</h2><p>只是打包动作，相当于归档处理，不做压缩；解压也一样，只是把归档文件释放出来。</p>\n<p>(1)打包归档格式：</p>\n<pre><code class=\"bash\">tar -cvf examples.tar files|dir\n</code></pre>\n<p><code>说明：</code></p>\n<pre><code class=\"xml\">-c, --create  create a new archive 创建一个归档文件\n-v, --verbose verbosely list files processed 显示创建归档文件的进程\n-f, --file=ARCHIVE use archive file or device ARCHIVE  后面要立刻接被处理的档案名,比如--file=examples.tar\n</code></pre>\n<p><code>举例：</code></p>\n<pre><code class=\"bash\">tar -cvf file.tar file1       #file1文件\ntar -cvf file.tar file1 file2 #file1，file2文件\ntar -cvf file.tar dir         #dir目录\n</code></pre>\n<p>(2)释放解压格式：</p>\n<pre><code class=\"bash\">tar -xvf examples.tar （解压至当前目录下）\ntar -xvf examples.tar  -C /path (/path 解压至其它路径)\n</code></pre>\n<p><code>说明：</code></p>\n<pre><code class=\"xml\">-x, --extract, extract files from an archive 从一个归档文件中提取文件\n</code></pre>\n<p><code>举例：</code></p>\n<pre><code class=\"bash\">tar -xvf file.tar\ntar -xvf file.tar -C /temp  #解压到temp目录下\n</code></pre>\n<h2 id=\"tar-gz-tgz\"><a href=\"#tar-gz-tgz\" class=\"headerlink\" title=\"tar.gz tgz\"></a>tar.gz tgz</h2><p><code>tar.gz和tgz只是两种不同的书写方式，后者是一种简化书写，等同处理</code></p>\n<p>这种格式是Linux下使用非常普遍的一种压缩方式，<br>兼顾了压缩时间（耗费CPU）和压缩空间（压缩比率）<br>其实这是对tar包进行gzip算法的压缩</p>\n<p>(1)打包压缩格式：</p>\n<pre><code class=\"bash\">tar -zcvf examples.tgz examples (examples当前执行路径下的目录)\n</code></pre>\n<p><code>说明：</code></p>\n<pre><code class=\"xml\">-z, --gzip filter the archive through gzip 通过gzip压缩的形式对文件进行归档\n</code></pre>\n<p><code>举例：</code></p>\n<pre><code class=\"bash\">tar -zcvf file.tgz dir #dir目录\n</code></pre>\n<p>(2)释放解压格式：</p>\n<pre><code class=\"bash\">tar -zxvf examples.tar （解压至当前执行目录下）\ntar -zxvf examples.tar  -C /path (/path 解压至其它路径)\n</code></pre>\n<p><code>举例：</code></p>\n<pre><code class=\"xml\">tar -zcvf file.tgz\ntar -zcvf file.tgz -C /temp\n</code></pre>\n<h2 id=\"tar-bz\"><a href=\"#tar-bz\" class=\"headerlink\" title=\"tar.bz\"></a>tar.bz</h2><p>Linux下压缩比率较tgz大，即压缩后占用更小的空间，使得压缩包看起来更小。<br>但同时在压缩，解压的过程却是非常耗费CPU时间。</p>\n<p>(1)打包压缩格式：</p>\n<pre><code class=\"bash\">tar -jcvf examples.tar.bz2 examples   (examples为当前执行路径下的目录)\n</code></pre>\n<p><code>说明：</code></p>\n<pre><code class=\"xml\">-j, --bzip2 filter the archive through bzip2 通过bzip2压缩的形式对文件进行归档\n</code></pre>\n<p><code>举例：</code></p>\n<pre><code class=\"xml\">tar -jcvf file.tar.bz2 dir #dir目录\n</code></pre>\n<p>(2)释放解压：</p>\n<pre><code class=\"bash\">tar -jxvf examples.tar.bz2 （解压至当前执行目录下）\ntar -jxvf examples.tar.bz2  -C /path (/path 解压至其它路径)\n</code></pre>\n<p><code>举例：</code></p>\n<pre><code class=\"xml\">tar -jxvf file.tar.bz2\ntar -jxvf file.tar.bz2 -C /temp\n</code></pre>\n<h2 id=\"gz\"><a href=\"#gz\" class=\"headerlink\" title=\"gz\"></a>gz</h2><p>压缩：</p>\n<pre><code class=\"bash\">gzip -d examples.gz examples\n</code></pre>\n<p>解压：</p>\n<pre><code class=\"bash\">gunzip examples.gz\n</code></pre>\n<h2 id=\"zip\"><a href=\"#zip\" class=\"headerlink\" title=\"zip\"></a>zip</h2><p>zip 格式是开放且免费的，所以广泛使用在 Windows、Linux、MacOS 平台，要说 zip 有什么缺点的话，就是它的压缩率并不是很高，不如 rar及 tar.gz 等格式。<br>压缩：</p>\n<pre><code class=\"bash\">zip -r examples.zip examples (examples为目录)\n</code></pre>\n<p>解压：</p>\n<pre><code class=\"bash\">zip examples.zip\n</code></pre>\n<h2 id=\"rar\"><a href=\"#rar\" class=\"headerlink\" title=\".rar\"></a>.rar</h2><p>压缩：</p>\n<pre><code class=\"bash\">rar -a examples.rar examples\n</code></pre>\n<p>解压：</p>\n<pre><code class=\"bash\">rar -x examples.rar\n</code></pre>\n<p>压缩比率，占用时间对比</p>\n<p>为了保证能够让压缩比率较为明显，需选取一个内容较多、占用空间较大的目录作为本次实验的测试。<br>找了一个大概有23G的目录来测试,首先要明确由于执行环境的变化，误差在所难免</p>\n<p>首先明确一个概念：<br>压缩比率=原内容大小/压缩后大小，压缩比率越大，则表明压缩后占用空间的压缩包越小</p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44308296-60b34600-a3e5-11e8-9dd0-35f605880467.png\" alt=\"\"></p>\n<p>转自:<a href=\"https://www.cnblogs.com/joshua317/p/6170839.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/joshua317/p/6170839.html</a></p>\n"},{"title":"Chrome插件目录","date":"2016-08-13T06:35:48.000Z","_content":"\n## Chrome插件目录\n\nUbuntu:      ~/.config/google-chrome/Default/Extensions\n\nWindows:   C:\\Users\\Administrator\\AppData\\Local\\Google\\Chrome\\User Data/Default/Extensions/\n\nMac OS X:   ./Library/Application Support/Google/Chrome/Default/Extensions","source":"_posts/Android/不同系统chrome插件位置.md","raw":"---\ntitle: Chrome插件目录\npermalink: chrome-plugin-location\ncategories:\n  - 工具\ntags:\n  - chrome\n  - chrome-plugin\ndate: 2016-08-13 14:35:48\n---\n\n## Chrome插件目录\n\nUbuntu:      ~/.config/google-chrome/Default/Extensions\n\nWindows:   C:\\Users\\Administrator\\AppData\\Local\\Google\\Chrome\\User Data/Default/Extensions/\n\nMac OS X:   ./Library/Application Support/Google/Chrome/Default/Extensions","slug":"chrome-plugin-location","published":1,"updated":"2018-08-13T15:14:18.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwht0006rmujfvzlfqpc","content":"<h2 id=\"Chrome插件目录\"><a href=\"#Chrome插件目录\" class=\"headerlink\" title=\"Chrome插件目录\"></a>Chrome插件目录</h2><p>Ubuntu:      ~/.config/google-chrome/Default/Extensions</p>\n<p>Windows:   C:\\Users\\Administrator\\AppData\\Local\\Google\\Chrome\\User Data/Default/Extensions/</p>\n<p>Mac OS X:   ./Library/Application Support/Google/Chrome/Default/Extensions</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Chrome插件目录\"><a href=\"#Chrome插件目录\" class=\"headerlink\" title=\"Chrome插件目录\"></a>Chrome插件目录</h2><p>Ubuntu:      ~/.config/google-chrome/Default/Extensions</p>\n<p>Windows:   C:\\Users\\Administrator\\AppData\\Local\\Google\\Chrome\\User Data/Default/Extensions/</p>\n<p>Mac OS X:   ./Library/Application Support/Google/Chrome/Default/Extensions</p>\n"},{"title":"合并重复联系人","date":"2018-01-16T02:00:00.000Z","_content":"\n详细code逻辑，请参考lineageos 开源项目.\n## 1.搜索重复联系人\n\n```java\n//SearchDupActivity.java\n@Override\nprotected Dialog onCreateDialog(int id) {\n    switch (id) {\n        case R.id.search_dup_dialog: {\n            mProgressDialog = initSearchingDialog();\n            DuplicatesUtils.setDialog(mProgressDialog);\n            Thread thread = new SearchDuplicatedThread();\n            DuplicatesUtils.mSearchState = true;\n            thread.start();\n            return mProgressDialog;\n        }\n    }\n    return super.onCreateDialog(id);\n}\n```\n\n### 初始化search 界面\n\n```java\n//SearchDupActivity.java\nprivate ProgressDialog initSearchingDialog() {\n    ProgressDialog dialog = new MyProgressDialog(this);\n    dialog.setMessage(this.getString(R.string.searching_duplicated_contacts));\n    dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n    dialog.setCanceledOnTouchOutside(false);\n    Cursor cursor = null;\n    int allCount = 0;\n    String selection = RawContacts.DELETED + \"= 0\";\n    try {\n        //计算progress total size（通过rawcontacts表查询，去除DELETED）\n        cursor = getContentResolver()\n                .query(RawContacts.CONTENT_URI, RAWCONTACTS_ID_PROJECTION,\n                selection, null, null);\n    } finally {\n        if (cursor != null) {\n            allCount = cursor.getCount();\n            cursor.close();\n        }\n    }\n    dialog.setMax(allCount);\n    return dialog;\n}\n```\n\n***\n1.获取 account list\n2.计算 duplicate contacts 用于显示MergeContactActivity的数据\n3.查询完后，handler通知启动MergeContactActivity界面。\n***\n\n```java\n//SearchDupActivity.java\nprivate class SearchDuplicatedThread extends Thread {\n    @Override\n    public void run() {\n        List<AccountWithDataSet> list = AccountTypeManager\n                .getInstance(SearchDupActivity.this).getAccounts(true);\n        ArrayList<Account> accountsList = new ArrayList<>();\n        for (int i = 0; i < list.size(); i++) {\n            accountsList.add(list.get(i).getAccountOrNull());\n        }\n\n        /* calculate the contacts which can be merged. */\n        boolean isComplete = DuplicatesUtils\n                .calculateMergeRawContacts(SearchDupActivity.this, accountsList,\n                        getContentResolver());\n        Message msg = Message.obtain();\n        if (isComplete) {\n            ArrayList<DuplicatesUtils.MergeContacts> mergeRawContacts =\n                    DuplicatesUtils.getMergeRawContacts();\n            if (mergeRawContacts != null && mergeRawContacts.size() > 0) {\n                msg.what = FIND_DUPLICATED;\n            } else {\n                msg.what = NO_DUPLICATED;\n            }\n            handler.sendMessage(msg);\n        }\n    }\n}\n```\n\n***\n1.根据account 先进行区分\n2.根据account 查询 rawcontacts, 获取HashMap &lt;name(ignore大小写), list(rawcontacts ids)&gt;\n3.判定是否有dup contacts(list size 是否大于2)\n 判定是否可merge：\na。根据id in RawContactsEntity进行查询\nb。根据mimeType 组建mergePhoneList、mergeEmailList、photoid等\nc。构建ArrayList&lt;ContactsInfo&gt;\nd。构建ArrayList&lt;MergeContacts&gt; 对于sim contacts 进行额外判定。（MergeContacts:ContactsInfo ～ 1：n）\n4.progress 进度的更新\n***\n\n```java\n//DuplicatesUtils.java\npublic static boolean calculateMergeRawContacts(Context context, List<Account> accounts,\n    ContentResolver resolver) {\n    SimContactsOperation simContactsOperation = new SimContactsOperation(context);\n    mMergeRawContacts = new ArrayList<>();\n    int count = 0;\n    // contacts in different accounts are separated.\n    for (int i = 0; i < accounts.size() && mSearchState; i++) {\n        Account account = accounts.get(i);\n        HashMap<String, List<Long>> map = DuplicatesUtils.getRawNameWithIds(resolver,\n                new String[]{account.name, account.type});\n        if (map != null && map.size() > 0) {\n            ArrayList<ContactsInfo> lst1;\n            Iterator<String> iterator = map.keySet().iterator();\n            while (mSearchState && iterator.hasNext()) {\n                List<String> mergePhoneList = new ArrayList();\n                List<String> mergeEmailList = new ArrayList();\n                long contactId = -1;\n                lst1 = new ArrayList<>();\n                String keyName = iterator.next();\n                List<Long> lst = map.get(keyName);\n                if (lst.size() >= 2) {\n                    EntityIterator entityIterator = DuplicatesUtils.getEntityByIds(resolver,\n                            lst);\n                    if (entityIterator == null) {\n                        continue;\n                    }\n                    try {\n                        while (entityIterator.hasNext()) {\n                            ArrayList<String> phoneList = new ArrayList<>();\n                            ArrayList<String> emailList = new ArrayList<>();\n                            long photoId = 0;\n                            Entity next1 = entityIterator.next();\n                            ContentValues values = next1.getEntityValues();\n                            Long rawId = values.getAsLong(RawContacts._ID);\n                            String id = values.getAsString(RawContacts.CONTACT_ID);\n                            if (!TextUtils.isEmpty(id)) {\n                                contactId = Long.parseLong(id);\n                            }\n                            Iterator<Entity.NamedContentValues> namedContentValuesIterator =\n                                    next1.getSubValues().iterator();\n                            while (namedContentValuesIterator.hasNext()) {\n                                ContentValues values1 = namedContentValuesIterator\n                                        .next().values;\n                                String mimeType = values1.getAsString(Data.MIMETYPE);\n                                if (CommonDataKinds.StructuredName\n                                        .CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                    continue;\n                                }\n                                if (CommonDataKinds.Photo.CONTENT_ITEM_TYPE\n                                        .equals(mimeType)) {\n                                    photoId = values1.getAsLong(CommonDataKinds.Photo._ID)\n                                            .longValue();\n                                    continue;\n                                }\n                                if (CommonDataKinds.Phone.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                    String data1 = values1\n                                            .getAsString(CommonDataKinds.Phone.DATA1);\n                                    phoneList.add(data1);\n                                    if (!TextUtils.isEmpty(data1)\n                                            && !mergePhoneList.contains(data1)) {\n                                        boolean contains = false;\n                                        for (int j = 0; j < mergePhoneList.size(); j++) {\n                                            if (PhoneNumberUtils.compare(data1,\n                                                    mergePhoneList.get(j))) {\n                                                contains = true;\n                                                break;\n                                            }\n                                        }\n                                        if (!contains) {\n                                            mergePhoneList.add(data1);\n                                        }\n                                        continue;\n                                    }\n                                }\n                                if (CommonDataKinds.Email.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                    String email = values1\n                                            .getAsString(CommonDataKinds.Email.DATA1);\n                                    emailList.add(email);\n                                    if (!mergeEmailList.contains(email)) {\n                                        mergeEmailList.add(email);\n                                    }\n                                    continue;\n                                }\n                            }\n                            Cursor cursor = resolver.query(Contacts.CONTENT_URI,\n                                    CONTACTS_PROJECTION, Contacts._ID.concat(\" = ?\"),\n                                    new String[]{String.valueOf(contactId)}, null);\n\n                            if (cursor != null && cursor.moveToNext()) {\n                                String lookUp = cursor.getString(cursor\n                                        .getColumnIndex(Contacts.LOOKUP_KEY));\n                                String displayName = cursor.getString(cursor.getColumnIndex(\n                                        Contacts.DISPLAY_NAME_PRIMARY));\n                                lst1.add(new ContactsInfo(contactId, lookUp, photoId,\n                                        displayName, phoneList, emailList, rawId));\n                                cursor.close();\n                            }\n                        }\n                    } finally {\n                        if (entityIterator != null) {\n                            entityIterator.close();\n                        }\n                    }\n                    // for sim contacts, analyse if it can be merged.\n                    if (contactId != -1\n                            && account.type.equals(SimContactsConstants.ACCOUNT_TYPE_SIM)) {\n                        int subscription = simContactsOperation.getSimSubscription(contactId);\n                        int oneSimAnrCount = MoreContactUtils.getOneSimAnrCount(\n                                context, subscription);\n                        int oneSimEmailCount = MoreContactUtils\n                                .getOneSimEmailCount(context, subscription);\n                        if (mergePhoneList.size() > oneSimAnrCount + 1\n                                || mergeEmailList.size() > oneSimEmailCount) {\n                            continue;\n                        }\n                    }\n                    if (mMergeRawContacts != null) {\n                        mMergeRawContacts.add(\n                            new MergeContacts(account.name, account.type, lst1));\n                    }\n                }\n                count += lst.size();\n                mProgressDialog.setProgress(count);\n            }\n        }\n    }\n    if (mSearchState) {\n        // search ended, change the flag.\n        mSearchState = false;\n        return true;\n    }\n    return false;\n}\n```\n\n## 2.显示重复联系人\n\n***\n根据ArrayList&lt;MergeContacts&gt; 显示UI e.g. 根据mSelectCount 控制merge enanble或disable等\n***\n\n```java\n//MergeContactActivity.java\n@Override\nprotected void onListItemClick(ListView l, View v, int position, long id) {\n    MergeContactAdapter adapter = (MergeContactAdapter) l.getAdapter();\n    DuplicatesUtils.MergeContacts item = (DuplicatesUtils.MergeContacts) adapter\n            .getItem(position);\n    CheckBox cb = (CheckBox) v.findViewById(R.id.row_box);\n    // mark the mergeContacts item, which will be merged later, if true.\n    // calculate the selected count.\n    if (cb.isChecked() && item.isChecked()) {\n        cb.setChecked(false);\n        item.setChecked(false);\n        mSelectCount--;\n    } else {\n        cb.setChecked(true);\n        item.setChecked(true);\n        mSelectCount++;\n    }\n    // if the selected count is '0', disable the menuItem.\n    if (mSelectCount == 0 && mergeItem != null && mergeItem.isEnabled()) {\n        mergeItem.setEnabled(false);\n    } else if (mSelectCount > 0 && mergeItem != null && !mergeItem.isEnabled()) {\n        mergeItem.setEnabled(true);\n    }\n}\n```\n\n## 3.合并重复联系人\n\n```java\n@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    switch (item.getItemId()) {\n        case R.id.menu_merge: {\n            mProgressDialog = new MyProgressDialog(MergeContactActivity.this);\n            mProgressDialog.setMessage(this.getString(R.string.merging_contacts));\n            mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n            Iterator<DuplicatesUtils.MergeContacts> iterator = mMergeList.iterator();\n            while (iterator.hasNext()) {\n                DuplicatesUtils.MergeContacts next = iterator.next();\n                if (!next.isChecked()) {\n                    iterator.remove();\n                }\n            }\n            mProgressDialog.setMax(mMergeList.size());\n            mProgressDialog.setCancelable(false);\n            mProgressDialog.setCanceledOnTouchOutside(false);\n            mProgressDialog.show();\n            Thread thread = new MergeDuplicatedThread();\n            DuplicatesUtils.mMergeState = true;\n            thread.start();\n        }\n    }\n    return true;\n}\n```\n","source":"_posts/Android/合并重复联系人.md","raw":"---\ntitle: 合并重复联系人\npermalink: merge-contacts\ncategories:\n  - Android\ntags:\n  - android\n  - contacts\ndate: 2018-01-16 10:00:00\n---\n\n详细code逻辑，请参考lineageos 开源项目.\n## 1.搜索重复联系人\n\n```java\n//SearchDupActivity.java\n@Override\nprotected Dialog onCreateDialog(int id) {\n    switch (id) {\n        case R.id.search_dup_dialog: {\n            mProgressDialog = initSearchingDialog();\n            DuplicatesUtils.setDialog(mProgressDialog);\n            Thread thread = new SearchDuplicatedThread();\n            DuplicatesUtils.mSearchState = true;\n            thread.start();\n            return mProgressDialog;\n        }\n    }\n    return super.onCreateDialog(id);\n}\n```\n\n### 初始化search 界面\n\n```java\n//SearchDupActivity.java\nprivate ProgressDialog initSearchingDialog() {\n    ProgressDialog dialog = new MyProgressDialog(this);\n    dialog.setMessage(this.getString(R.string.searching_duplicated_contacts));\n    dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n    dialog.setCanceledOnTouchOutside(false);\n    Cursor cursor = null;\n    int allCount = 0;\n    String selection = RawContacts.DELETED + \"= 0\";\n    try {\n        //计算progress total size（通过rawcontacts表查询，去除DELETED）\n        cursor = getContentResolver()\n                .query(RawContacts.CONTENT_URI, RAWCONTACTS_ID_PROJECTION,\n                selection, null, null);\n    } finally {\n        if (cursor != null) {\n            allCount = cursor.getCount();\n            cursor.close();\n        }\n    }\n    dialog.setMax(allCount);\n    return dialog;\n}\n```\n\n***\n1.获取 account list\n2.计算 duplicate contacts 用于显示MergeContactActivity的数据\n3.查询完后，handler通知启动MergeContactActivity界面。\n***\n\n```java\n//SearchDupActivity.java\nprivate class SearchDuplicatedThread extends Thread {\n    @Override\n    public void run() {\n        List<AccountWithDataSet> list = AccountTypeManager\n                .getInstance(SearchDupActivity.this).getAccounts(true);\n        ArrayList<Account> accountsList = new ArrayList<>();\n        for (int i = 0; i < list.size(); i++) {\n            accountsList.add(list.get(i).getAccountOrNull());\n        }\n\n        /* calculate the contacts which can be merged. */\n        boolean isComplete = DuplicatesUtils\n                .calculateMergeRawContacts(SearchDupActivity.this, accountsList,\n                        getContentResolver());\n        Message msg = Message.obtain();\n        if (isComplete) {\n            ArrayList<DuplicatesUtils.MergeContacts> mergeRawContacts =\n                    DuplicatesUtils.getMergeRawContacts();\n            if (mergeRawContacts != null && mergeRawContacts.size() > 0) {\n                msg.what = FIND_DUPLICATED;\n            } else {\n                msg.what = NO_DUPLICATED;\n            }\n            handler.sendMessage(msg);\n        }\n    }\n}\n```\n\n***\n1.根据account 先进行区分\n2.根据account 查询 rawcontacts, 获取HashMap &lt;name(ignore大小写), list(rawcontacts ids)&gt;\n3.判定是否有dup contacts(list size 是否大于2)\n 判定是否可merge：\na。根据id in RawContactsEntity进行查询\nb。根据mimeType 组建mergePhoneList、mergeEmailList、photoid等\nc。构建ArrayList&lt;ContactsInfo&gt;\nd。构建ArrayList&lt;MergeContacts&gt; 对于sim contacts 进行额外判定。（MergeContacts:ContactsInfo ～ 1：n）\n4.progress 进度的更新\n***\n\n```java\n//DuplicatesUtils.java\npublic static boolean calculateMergeRawContacts(Context context, List<Account> accounts,\n    ContentResolver resolver) {\n    SimContactsOperation simContactsOperation = new SimContactsOperation(context);\n    mMergeRawContacts = new ArrayList<>();\n    int count = 0;\n    // contacts in different accounts are separated.\n    for (int i = 0; i < accounts.size() && mSearchState; i++) {\n        Account account = accounts.get(i);\n        HashMap<String, List<Long>> map = DuplicatesUtils.getRawNameWithIds(resolver,\n                new String[]{account.name, account.type});\n        if (map != null && map.size() > 0) {\n            ArrayList<ContactsInfo> lst1;\n            Iterator<String> iterator = map.keySet().iterator();\n            while (mSearchState && iterator.hasNext()) {\n                List<String> mergePhoneList = new ArrayList();\n                List<String> mergeEmailList = new ArrayList();\n                long contactId = -1;\n                lst1 = new ArrayList<>();\n                String keyName = iterator.next();\n                List<Long> lst = map.get(keyName);\n                if (lst.size() >= 2) {\n                    EntityIterator entityIterator = DuplicatesUtils.getEntityByIds(resolver,\n                            lst);\n                    if (entityIterator == null) {\n                        continue;\n                    }\n                    try {\n                        while (entityIterator.hasNext()) {\n                            ArrayList<String> phoneList = new ArrayList<>();\n                            ArrayList<String> emailList = new ArrayList<>();\n                            long photoId = 0;\n                            Entity next1 = entityIterator.next();\n                            ContentValues values = next1.getEntityValues();\n                            Long rawId = values.getAsLong(RawContacts._ID);\n                            String id = values.getAsString(RawContacts.CONTACT_ID);\n                            if (!TextUtils.isEmpty(id)) {\n                                contactId = Long.parseLong(id);\n                            }\n                            Iterator<Entity.NamedContentValues> namedContentValuesIterator =\n                                    next1.getSubValues().iterator();\n                            while (namedContentValuesIterator.hasNext()) {\n                                ContentValues values1 = namedContentValuesIterator\n                                        .next().values;\n                                String mimeType = values1.getAsString(Data.MIMETYPE);\n                                if (CommonDataKinds.StructuredName\n                                        .CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                    continue;\n                                }\n                                if (CommonDataKinds.Photo.CONTENT_ITEM_TYPE\n                                        .equals(mimeType)) {\n                                    photoId = values1.getAsLong(CommonDataKinds.Photo._ID)\n                                            .longValue();\n                                    continue;\n                                }\n                                if (CommonDataKinds.Phone.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                    String data1 = values1\n                                            .getAsString(CommonDataKinds.Phone.DATA1);\n                                    phoneList.add(data1);\n                                    if (!TextUtils.isEmpty(data1)\n                                            && !mergePhoneList.contains(data1)) {\n                                        boolean contains = false;\n                                        for (int j = 0; j < mergePhoneList.size(); j++) {\n                                            if (PhoneNumberUtils.compare(data1,\n                                                    mergePhoneList.get(j))) {\n                                                contains = true;\n                                                break;\n                                            }\n                                        }\n                                        if (!contains) {\n                                            mergePhoneList.add(data1);\n                                        }\n                                        continue;\n                                    }\n                                }\n                                if (CommonDataKinds.Email.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                    String email = values1\n                                            .getAsString(CommonDataKinds.Email.DATA1);\n                                    emailList.add(email);\n                                    if (!mergeEmailList.contains(email)) {\n                                        mergeEmailList.add(email);\n                                    }\n                                    continue;\n                                }\n                            }\n                            Cursor cursor = resolver.query(Contacts.CONTENT_URI,\n                                    CONTACTS_PROJECTION, Contacts._ID.concat(\" = ?\"),\n                                    new String[]{String.valueOf(contactId)}, null);\n\n                            if (cursor != null && cursor.moveToNext()) {\n                                String lookUp = cursor.getString(cursor\n                                        .getColumnIndex(Contacts.LOOKUP_KEY));\n                                String displayName = cursor.getString(cursor.getColumnIndex(\n                                        Contacts.DISPLAY_NAME_PRIMARY));\n                                lst1.add(new ContactsInfo(contactId, lookUp, photoId,\n                                        displayName, phoneList, emailList, rawId));\n                                cursor.close();\n                            }\n                        }\n                    } finally {\n                        if (entityIterator != null) {\n                            entityIterator.close();\n                        }\n                    }\n                    // for sim contacts, analyse if it can be merged.\n                    if (contactId != -1\n                            && account.type.equals(SimContactsConstants.ACCOUNT_TYPE_SIM)) {\n                        int subscription = simContactsOperation.getSimSubscription(contactId);\n                        int oneSimAnrCount = MoreContactUtils.getOneSimAnrCount(\n                                context, subscription);\n                        int oneSimEmailCount = MoreContactUtils\n                                .getOneSimEmailCount(context, subscription);\n                        if (mergePhoneList.size() > oneSimAnrCount + 1\n                                || mergeEmailList.size() > oneSimEmailCount) {\n                            continue;\n                        }\n                    }\n                    if (mMergeRawContacts != null) {\n                        mMergeRawContacts.add(\n                            new MergeContacts(account.name, account.type, lst1));\n                    }\n                }\n                count += lst.size();\n                mProgressDialog.setProgress(count);\n            }\n        }\n    }\n    if (mSearchState) {\n        // search ended, change the flag.\n        mSearchState = false;\n        return true;\n    }\n    return false;\n}\n```\n\n## 2.显示重复联系人\n\n***\n根据ArrayList&lt;MergeContacts&gt; 显示UI e.g. 根据mSelectCount 控制merge enanble或disable等\n***\n\n```java\n//MergeContactActivity.java\n@Override\nprotected void onListItemClick(ListView l, View v, int position, long id) {\n    MergeContactAdapter adapter = (MergeContactAdapter) l.getAdapter();\n    DuplicatesUtils.MergeContacts item = (DuplicatesUtils.MergeContacts) adapter\n            .getItem(position);\n    CheckBox cb = (CheckBox) v.findViewById(R.id.row_box);\n    // mark the mergeContacts item, which will be merged later, if true.\n    // calculate the selected count.\n    if (cb.isChecked() && item.isChecked()) {\n        cb.setChecked(false);\n        item.setChecked(false);\n        mSelectCount--;\n    } else {\n        cb.setChecked(true);\n        item.setChecked(true);\n        mSelectCount++;\n    }\n    // if the selected count is '0', disable the menuItem.\n    if (mSelectCount == 0 && mergeItem != null && mergeItem.isEnabled()) {\n        mergeItem.setEnabled(false);\n    } else if (mSelectCount > 0 && mergeItem != null && !mergeItem.isEnabled()) {\n        mergeItem.setEnabled(true);\n    }\n}\n```\n\n## 3.合并重复联系人\n\n```java\n@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    switch (item.getItemId()) {\n        case R.id.menu_merge: {\n            mProgressDialog = new MyProgressDialog(MergeContactActivity.this);\n            mProgressDialog.setMessage(this.getString(R.string.merging_contacts));\n            mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n            Iterator<DuplicatesUtils.MergeContacts> iterator = mMergeList.iterator();\n            while (iterator.hasNext()) {\n                DuplicatesUtils.MergeContacts next = iterator.next();\n                if (!next.isChecked()) {\n                    iterator.remove();\n                }\n            }\n            mProgressDialog.setMax(mMergeList.size());\n            mProgressDialog.setCancelable(false);\n            mProgressDialog.setCanceledOnTouchOutside(false);\n            mProgressDialog.show();\n            Thread thread = new MergeDuplicatedThread();\n            DuplicatesUtils.mMergeState = true;\n            thread.start();\n        }\n    }\n    return true;\n}\n```\n","slug":"merge-contacts","published":1,"updated":"2018-08-19T11:00:01.821Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwhu0009rmuja3jro71b","content":"<p>详细code逻辑，请参考lineageos 开源项目.</p>\n<h2 id=\"1-搜索重复联系人\"><a href=\"#1-搜索重复联系人\" class=\"headerlink\" title=\"1.搜索重复联系人\"></a>1.搜索重复联系人</h2><pre><code class=\"java\">//SearchDupActivity.java\n@Override\nprotected Dialog onCreateDialog(int id) {\n    switch (id) {\n        case R.id.search_dup_dialog: {\n            mProgressDialog = initSearchingDialog();\n            DuplicatesUtils.setDialog(mProgressDialog);\n            Thread thread = new SearchDuplicatedThread();\n            DuplicatesUtils.mSearchState = true;\n            thread.start();\n            return mProgressDialog;\n        }\n    }\n    return super.onCreateDialog(id);\n}\n</code></pre>\n<h3 id=\"初始化search-界面\"><a href=\"#初始化search-界面\" class=\"headerlink\" title=\"初始化search 界面\"></a>初始化search 界面</h3><pre><code class=\"java\">//SearchDupActivity.java\nprivate ProgressDialog initSearchingDialog() {\n    ProgressDialog dialog = new MyProgressDialog(this);\n    dialog.setMessage(this.getString(R.string.searching_duplicated_contacts));\n    dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n    dialog.setCanceledOnTouchOutside(false);\n    Cursor cursor = null;\n    int allCount = 0;\n    String selection = RawContacts.DELETED + &quot;= 0&quot;;\n    try {\n        //计算progress total size（通过rawcontacts表查询，去除DELETED）\n        cursor = getContentResolver()\n                .query(RawContacts.CONTENT_URI, RAWCONTACTS_ID_PROJECTION,\n                selection, null, null);\n    } finally {\n        if (cursor != null) {\n            allCount = cursor.getCount();\n            cursor.close();\n        }\n    }\n    dialog.setMax(allCount);\n    return dialog;\n}\n</code></pre>\n<hr>\n<p>1.获取 account list<br>2.计算 duplicate contacts 用于显示MergeContactActivity的数据<br>3.查询完后，handler通知启动MergeContactActivity界面。</p>\n<hr>\n<pre><code class=\"java\">//SearchDupActivity.java\nprivate class SearchDuplicatedThread extends Thread {\n    @Override\n    public void run() {\n        List&lt;AccountWithDataSet&gt; list = AccountTypeManager\n                .getInstance(SearchDupActivity.this).getAccounts(true);\n        ArrayList&lt;Account&gt; accountsList = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; list.size(); i++) {\n            accountsList.add(list.get(i).getAccountOrNull());\n        }\n\n        /* calculate the contacts which can be merged. */\n        boolean isComplete = DuplicatesUtils\n                .calculateMergeRawContacts(SearchDupActivity.this, accountsList,\n                        getContentResolver());\n        Message msg = Message.obtain();\n        if (isComplete) {\n            ArrayList&lt;DuplicatesUtils.MergeContacts&gt; mergeRawContacts =\n                    DuplicatesUtils.getMergeRawContacts();\n            if (mergeRawContacts != null &amp;&amp; mergeRawContacts.size() &gt; 0) {\n                msg.what = FIND_DUPLICATED;\n            } else {\n                msg.what = NO_DUPLICATED;\n            }\n            handler.sendMessage(msg);\n        }\n    }\n}\n</code></pre>\n<hr>\n<p>1.根据account 先进行区分<br>2.根据account 查询 rawcontacts, 获取HashMap &lt;name(ignore大小写), list(rawcontacts ids)&gt;<br>3.判定是否有dup contacts(list size 是否大于2)<br> 判定是否可merge：<br>a。根据id in RawContactsEntity进行查询<br>b。根据mimeType 组建mergePhoneList、mergeEmailList、photoid等<br>c。构建ArrayList&lt;ContactsInfo&gt;<br>d。构建ArrayList&lt;MergeContacts&gt; 对于sim contacts 进行额外判定。（MergeContacts:ContactsInfo ～ 1：n）<br>4.progress 进度的更新</p>\n<hr>\n<pre><code class=\"java\">//DuplicatesUtils.java\npublic static boolean calculateMergeRawContacts(Context context, List&lt;Account&gt; accounts,\n    ContentResolver resolver) {\n    SimContactsOperation simContactsOperation = new SimContactsOperation(context);\n    mMergeRawContacts = new ArrayList&lt;&gt;();\n    int count = 0;\n    // contacts in different accounts are separated.\n    for (int i = 0; i &lt; accounts.size() &amp;&amp; mSearchState; i++) {\n        Account account = accounts.get(i);\n        HashMap&lt;String, List&lt;Long&gt;&gt; map = DuplicatesUtils.getRawNameWithIds(resolver,\n                new String[]{account.name, account.type});\n        if (map != null &amp;&amp; map.size() &gt; 0) {\n            ArrayList&lt;ContactsInfo&gt; lst1;\n            Iterator&lt;String&gt; iterator = map.keySet().iterator();\n            while (mSearchState &amp;&amp; iterator.hasNext()) {\n                List&lt;String&gt; mergePhoneList = new ArrayList();\n                List&lt;String&gt; mergeEmailList = new ArrayList();\n                long contactId = -1;\n                lst1 = new ArrayList&lt;&gt;();\n                String keyName = iterator.next();\n                List&lt;Long&gt; lst = map.get(keyName);\n                if (lst.size() &gt;= 2) {\n                    EntityIterator entityIterator = DuplicatesUtils.getEntityByIds(resolver,\n                            lst);\n                    if (entityIterator == null) {\n                        continue;\n                    }\n                    try {\n                        while (entityIterator.hasNext()) {\n                            ArrayList&lt;String&gt; phoneList = new ArrayList&lt;&gt;();\n                            ArrayList&lt;String&gt; emailList = new ArrayList&lt;&gt;();\n                            long photoId = 0;\n                            Entity next1 = entityIterator.next();\n                            ContentValues values = next1.getEntityValues();\n                            Long rawId = values.getAsLong(RawContacts._ID);\n                            String id = values.getAsString(RawContacts.CONTACT_ID);\n                            if (!TextUtils.isEmpty(id)) {\n                                contactId = Long.parseLong(id);\n                            }\n                            Iterator&lt;Entity.NamedContentValues&gt; namedContentValuesIterator =\n                                    next1.getSubValues().iterator();\n                            while (namedContentValuesIterator.hasNext()) {\n                                ContentValues values1 = namedContentValuesIterator\n                                        .next().values;\n                                String mimeType = values1.getAsString(Data.MIMETYPE);\n                                if (CommonDataKinds.StructuredName\n                                        .CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                    continue;\n                                }\n                                if (CommonDataKinds.Photo.CONTENT_ITEM_TYPE\n                                        .equals(mimeType)) {\n                                    photoId = values1.getAsLong(CommonDataKinds.Photo._ID)\n                                            .longValue();\n                                    continue;\n                                }\n                                if (CommonDataKinds.Phone.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                    String data1 = values1\n                                            .getAsString(CommonDataKinds.Phone.DATA1);\n                                    phoneList.add(data1);\n                                    if (!TextUtils.isEmpty(data1)\n                                            &amp;&amp; !mergePhoneList.contains(data1)) {\n                                        boolean contains = false;\n                                        for (int j = 0; j &lt; mergePhoneList.size(); j++) {\n                                            if (PhoneNumberUtils.compare(data1,\n                                                    mergePhoneList.get(j))) {\n                                                contains = true;\n                                                break;\n                                            }\n                                        }\n                                        if (!contains) {\n                                            mergePhoneList.add(data1);\n                                        }\n                                        continue;\n                                    }\n                                }\n                                if (CommonDataKinds.Email.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                    String email = values1\n                                            .getAsString(CommonDataKinds.Email.DATA1);\n                                    emailList.add(email);\n                                    if (!mergeEmailList.contains(email)) {\n                                        mergeEmailList.add(email);\n                                    }\n                                    continue;\n                                }\n                            }\n                            Cursor cursor = resolver.query(Contacts.CONTENT_URI,\n                                    CONTACTS_PROJECTION, Contacts._ID.concat(&quot; = ?&quot;),\n                                    new String[]{String.valueOf(contactId)}, null);\n\n                            if (cursor != null &amp;&amp; cursor.moveToNext()) {\n                                String lookUp = cursor.getString(cursor\n                                        .getColumnIndex(Contacts.LOOKUP_KEY));\n                                String displayName = cursor.getString(cursor.getColumnIndex(\n                                        Contacts.DISPLAY_NAME_PRIMARY));\n                                lst1.add(new ContactsInfo(contactId, lookUp, photoId,\n                                        displayName, phoneList, emailList, rawId));\n                                cursor.close();\n                            }\n                        }\n                    } finally {\n                        if (entityIterator != null) {\n                            entityIterator.close();\n                        }\n                    }\n                    // for sim contacts, analyse if it can be merged.\n                    if (contactId != -1\n                            &amp;&amp; account.type.equals(SimContactsConstants.ACCOUNT_TYPE_SIM)) {\n                        int subscription = simContactsOperation.getSimSubscription(contactId);\n                        int oneSimAnrCount = MoreContactUtils.getOneSimAnrCount(\n                                context, subscription);\n                        int oneSimEmailCount = MoreContactUtils\n                                .getOneSimEmailCount(context, subscription);\n                        if (mergePhoneList.size() &gt; oneSimAnrCount + 1\n                                || mergeEmailList.size() &gt; oneSimEmailCount) {\n                            continue;\n                        }\n                    }\n                    if (mMergeRawContacts != null) {\n                        mMergeRawContacts.add(\n                            new MergeContacts(account.name, account.type, lst1));\n                    }\n                }\n                count += lst.size();\n                mProgressDialog.setProgress(count);\n            }\n        }\n    }\n    if (mSearchState) {\n        // search ended, change the flag.\n        mSearchState = false;\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<h2 id=\"2-显示重复联系人\"><a href=\"#2-显示重复联系人\" class=\"headerlink\" title=\"2.显示重复联系人\"></a>2.显示重复联系人</h2><hr>\n<p>根据ArrayList&lt;MergeContacts&gt; 显示UI e.g. 根据mSelectCount 控制merge enanble或disable等</p>\n<hr>\n<pre><code class=\"java\">//MergeContactActivity.java\n@Override\nprotected void onListItemClick(ListView l, View v, int position, long id) {\n    MergeContactAdapter adapter = (MergeContactAdapter) l.getAdapter();\n    DuplicatesUtils.MergeContacts item = (DuplicatesUtils.MergeContacts) adapter\n            .getItem(position);\n    CheckBox cb = (CheckBox) v.findViewById(R.id.row_box);\n    // mark the mergeContacts item, which will be merged later, if true.\n    // calculate the selected count.\n    if (cb.isChecked() &amp;&amp; item.isChecked()) {\n        cb.setChecked(false);\n        item.setChecked(false);\n        mSelectCount--;\n    } else {\n        cb.setChecked(true);\n        item.setChecked(true);\n        mSelectCount++;\n    }\n    // if the selected count is &#39;0&#39;, disable the menuItem.\n    if (mSelectCount == 0 &amp;&amp; mergeItem != null &amp;&amp; mergeItem.isEnabled()) {\n        mergeItem.setEnabled(false);\n    } else if (mSelectCount &gt; 0 &amp;&amp; mergeItem != null &amp;&amp; !mergeItem.isEnabled()) {\n        mergeItem.setEnabled(true);\n    }\n}\n</code></pre>\n<h2 id=\"3-合并重复联系人\"><a href=\"#3-合并重复联系人\" class=\"headerlink\" title=\"3.合并重复联系人\"></a>3.合并重复联系人</h2><pre><code class=\"java\">@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    switch (item.getItemId()) {\n        case R.id.menu_merge: {\n            mProgressDialog = new MyProgressDialog(MergeContactActivity.this);\n            mProgressDialog.setMessage(this.getString(R.string.merging_contacts));\n            mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n            Iterator&lt;DuplicatesUtils.MergeContacts&gt; iterator = mMergeList.iterator();\n            while (iterator.hasNext()) {\n                DuplicatesUtils.MergeContacts next = iterator.next();\n                if (!next.isChecked()) {\n                    iterator.remove();\n                }\n            }\n            mProgressDialog.setMax(mMergeList.size());\n            mProgressDialog.setCancelable(false);\n            mProgressDialog.setCanceledOnTouchOutside(false);\n            mProgressDialog.show();\n            Thread thread = new MergeDuplicatedThread();\n            DuplicatesUtils.mMergeState = true;\n            thread.start();\n        }\n    }\n    return true;\n}\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>详细code逻辑，请参考lineageos 开源项目.</p>\n<h2 id=\"1-搜索重复联系人\"><a href=\"#1-搜索重复联系人\" class=\"headerlink\" title=\"1.搜索重复联系人\"></a>1.搜索重复联系人</h2><pre><code class=\"java\">//SearchDupActivity.java\n@Override\nprotected Dialog onCreateDialog(int id) {\n    switch (id) {\n        case R.id.search_dup_dialog: {\n            mProgressDialog = initSearchingDialog();\n            DuplicatesUtils.setDialog(mProgressDialog);\n            Thread thread = new SearchDuplicatedThread();\n            DuplicatesUtils.mSearchState = true;\n            thread.start();\n            return mProgressDialog;\n        }\n    }\n    return super.onCreateDialog(id);\n}\n</code></pre>\n<h3 id=\"初始化search-界面\"><a href=\"#初始化search-界面\" class=\"headerlink\" title=\"初始化search 界面\"></a>初始化search 界面</h3><pre><code class=\"java\">//SearchDupActivity.java\nprivate ProgressDialog initSearchingDialog() {\n    ProgressDialog dialog = new MyProgressDialog(this);\n    dialog.setMessage(this.getString(R.string.searching_duplicated_contacts));\n    dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n    dialog.setCanceledOnTouchOutside(false);\n    Cursor cursor = null;\n    int allCount = 0;\n    String selection = RawContacts.DELETED + &quot;= 0&quot;;\n    try {\n        //计算progress total size（通过rawcontacts表查询，去除DELETED）\n        cursor = getContentResolver()\n                .query(RawContacts.CONTENT_URI, RAWCONTACTS_ID_PROJECTION,\n                selection, null, null);\n    } finally {\n        if (cursor != null) {\n            allCount = cursor.getCount();\n            cursor.close();\n        }\n    }\n    dialog.setMax(allCount);\n    return dialog;\n}\n</code></pre>\n<hr>\n<p>1.获取 account list<br>2.计算 duplicate contacts 用于显示MergeContactActivity的数据<br>3.查询完后，handler通知启动MergeContactActivity界面。</p>\n<hr>\n<pre><code class=\"java\">//SearchDupActivity.java\nprivate class SearchDuplicatedThread extends Thread {\n    @Override\n    public void run() {\n        List&lt;AccountWithDataSet&gt; list = AccountTypeManager\n                .getInstance(SearchDupActivity.this).getAccounts(true);\n        ArrayList&lt;Account&gt; accountsList = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; list.size(); i++) {\n            accountsList.add(list.get(i).getAccountOrNull());\n        }\n\n        /* calculate the contacts which can be merged. */\n        boolean isComplete = DuplicatesUtils\n                .calculateMergeRawContacts(SearchDupActivity.this, accountsList,\n                        getContentResolver());\n        Message msg = Message.obtain();\n        if (isComplete) {\n            ArrayList&lt;DuplicatesUtils.MergeContacts&gt; mergeRawContacts =\n                    DuplicatesUtils.getMergeRawContacts();\n            if (mergeRawContacts != null &amp;&amp; mergeRawContacts.size() &gt; 0) {\n                msg.what = FIND_DUPLICATED;\n            } else {\n                msg.what = NO_DUPLICATED;\n            }\n            handler.sendMessage(msg);\n        }\n    }\n}\n</code></pre>\n<hr>\n<p>1.根据account 先进行区分<br>2.根据account 查询 rawcontacts, 获取HashMap &lt;name(ignore大小写), list(rawcontacts ids)&gt;<br>3.判定是否有dup contacts(list size 是否大于2)<br> 判定是否可merge：<br>a。根据id in RawContactsEntity进行查询<br>b。根据mimeType 组建mergePhoneList、mergeEmailList、photoid等<br>c。构建ArrayList&lt;ContactsInfo&gt;<br>d。构建ArrayList&lt;MergeContacts&gt; 对于sim contacts 进行额外判定。（MergeContacts:ContactsInfo ～ 1：n）<br>4.progress 进度的更新</p>\n<hr>\n<pre><code class=\"java\">//DuplicatesUtils.java\npublic static boolean calculateMergeRawContacts(Context context, List&lt;Account&gt; accounts,\n    ContentResolver resolver) {\n    SimContactsOperation simContactsOperation = new SimContactsOperation(context);\n    mMergeRawContacts = new ArrayList&lt;&gt;();\n    int count = 0;\n    // contacts in different accounts are separated.\n    for (int i = 0; i &lt; accounts.size() &amp;&amp; mSearchState; i++) {\n        Account account = accounts.get(i);\n        HashMap&lt;String, List&lt;Long&gt;&gt; map = DuplicatesUtils.getRawNameWithIds(resolver,\n                new String[]{account.name, account.type});\n        if (map != null &amp;&amp; map.size() &gt; 0) {\n            ArrayList&lt;ContactsInfo&gt; lst1;\n            Iterator&lt;String&gt; iterator = map.keySet().iterator();\n            while (mSearchState &amp;&amp; iterator.hasNext()) {\n                List&lt;String&gt; mergePhoneList = new ArrayList();\n                List&lt;String&gt; mergeEmailList = new ArrayList();\n                long contactId = -1;\n                lst1 = new ArrayList&lt;&gt;();\n                String keyName = iterator.next();\n                List&lt;Long&gt; lst = map.get(keyName);\n                if (lst.size() &gt;= 2) {\n                    EntityIterator entityIterator = DuplicatesUtils.getEntityByIds(resolver,\n                            lst);\n                    if (entityIterator == null) {\n                        continue;\n                    }\n                    try {\n                        while (entityIterator.hasNext()) {\n                            ArrayList&lt;String&gt; phoneList = new ArrayList&lt;&gt;();\n                            ArrayList&lt;String&gt; emailList = new ArrayList&lt;&gt;();\n                            long photoId = 0;\n                            Entity next1 = entityIterator.next();\n                            ContentValues values = next1.getEntityValues();\n                            Long rawId = values.getAsLong(RawContacts._ID);\n                            String id = values.getAsString(RawContacts.CONTACT_ID);\n                            if (!TextUtils.isEmpty(id)) {\n                                contactId = Long.parseLong(id);\n                            }\n                            Iterator&lt;Entity.NamedContentValues&gt; namedContentValuesIterator =\n                                    next1.getSubValues().iterator();\n                            while (namedContentValuesIterator.hasNext()) {\n                                ContentValues values1 = namedContentValuesIterator\n                                        .next().values;\n                                String mimeType = values1.getAsString(Data.MIMETYPE);\n                                if (CommonDataKinds.StructuredName\n                                        .CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                    continue;\n                                }\n                                if (CommonDataKinds.Photo.CONTENT_ITEM_TYPE\n                                        .equals(mimeType)) {\n                                    photoId = values1.getAsLong(CommonDataKinds.Photo._ID)\n                                            .longValue();\n                                    continue;\n                                }\n                                if (CommonDataKinds.Phone.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                    String data1 = values1\n                                            .getAsString(CommonDataKinds.Phone.DATA1);\n                                    phoneList.add(data1);\n                                    if (!TextUtils.isEmpty(data1)\n                                            &amp;&amp; !mergePhoneList.contains(data1)) {\n                                        boolean contains = false;\n                                        for (int j = 0; j &lt; mergePhoneList.size(); j++) {\n                                            if (PhoneNumberUtils.compare(data1,\n                                                    mergePhoneList.get(j))) {\n                                                contains = true;\n                                                break;\n                                            }\n                                        }\n                                        if (!contains) {\n                                            mergePhoneList.add(data1);\n                                        }\n                                        continue;\n                                    }\n                                }\n                                if (CommonDataKinds.Email.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                    String email = values1\n                                            .getAsString(CommonDataKinds.Email.DATA1);\n                                    emailList.add(email);\n                                    if (!mergeEmailList.contains(email)) {\n                                        mergeEmailList.add(email);\n                                    }\n                                    continue;\n                                }\n                            }\n                            Cursor cursor = resolver.query(Contacts.CONTENT_URI,\n                                    CONTACTS_PROJECTION, Contacts._ID.concat(&quot; = ?&quot;),\n                                    new String[]{String.valueOf(contactId)}, null);\n\n                            if (cursor != null &amp;&amp; cursor.moveToNext()) {\n                                String lookUp = cursor.getString(cursor\n                                        .getColumnIndex(Contacts.LOOKUP_KEY));\n                                String displayName = cursor.getString(cursor.getColumnIndex(\n                                        Contacts.DISPLAY_NAME_PRIMARY));\n                                lst1.add(new ContactsInfo(contactId, lookUp, photoId,\n                                        displayName, phoneList, emailList, rawId));\n                                cursor.close();\n                            }\n                        }\n                    } finally {\n                        if (entityIterator != null) {\n                            entityIterator.close();\n                        }\n                    }\n                    // for sim contacts, analyse if it can be merged.\n                    if (contactId != -1\n                            &amp;&amp; account.type.equals(SimContactsConstants.ACCOUNT_TYPE_SIM)) {\n                        int subscription = simContactsOperation.getSimSubscription(contactId);\n                        int oneSimAnrCount = MoreContactUtils.getOneSimAnrCount(\n                                context, subscription);\n                        int oneSimEmailCount = MoreContactUtils\n                                .getOneSimEmailCount(context, subscription);\n                        if (mergePhoneList.size() &gt; oneSimAnrCount + 1\n                                || mergeEmailList.size() &gt; oneSimEmailCount) {\n                            continue;\n                        }\n                    }\n                    if (mMergeRawContacts != null) {\n                        mMergeRawContacts.add(\n                            new MergeContacts(account.name, account.type, lst1));\n                    }\n                }\n                count += lst.size();\n                mProgressDialog.setProgress(count);\n            }\n        }\n    }\n    if (mSearchState) {\n        // search ended, change the flag.\n        mSearchState = false;\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<h2 id=\"2-显示重复联系人\"><a href=\"#2-显示重复联系人\" class=\"headerlink\" title=\"2.显示重复联系人\"></a>2.显示重复联系人</h2><hr>\n<p>根据ArrayList&lt;MergeContacts&gt; 显示UI e.g. 根据mSelectCount 控制merge enanble或disable等</p>\n<hr>\n<pre><code class=\"java\">//MergeContactActivity.java\n@Override\nprotected void onListItemClick(ListView l, View v, int position, long id) {\n    MergeContactAdapter adapter = (MergeContactAdapter) l.getAdapter();\n    DuplicatesUtils.MergeContacts item = (DuplicatesUtils.MergeContacts) adapter\n            .getItem(position);\n    CheckBox cb = (CheckBox) v.findViewById(R.id.row_box);\n    // mark the mergeContacts item, which will be merged later, if true.\n    // calculate the selected count.\n    if (cb.isChecked() &amp;&amp; item.isChecked()) {\n        cb.setChecked(false);\n        item.setChecked(false);\n        mSelectCount--;\n    } else {\n        cb.setChecked(true);\n        item.setChecked(true);\n        mSelectCount++;\n    }\n    // if the selected count is &#39;0&#39;, disable the menuItem.\n    if (mSelectCount == 0 &amp;&amp; mergeItem != null &amp;&amp; mergeItem.isEnabled()) {\n        mergeItem.setEnabled(false);\n    } else if (mSelectCount &gt; 0 &amp;&amp; mergeItem != null &amp;&amp; !mergeItem.isEnabled()) {\n        mergeItem.setEnabled(true);\n    }\n}\n</code></pre>\n<h2 id=\"3-合并重复联系人\"><a href=\"#3-合并重复联系人\" class=\"headerlink\" title=\"3.合并重复联系人\"></a>3.合并重复联系人</h2><pre><code class=\"java\">@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    switch (item.getItemId()) {\n        case R.id.menu_merge: {\n            mProgressDialog = new MyProgressDialog(MergeContactActivity.this);\n            mProgressDialog.setMessage(this.getString(R.string.merging_contacts));\n            mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n            Iterator&lt;DuplicatesUtils.MergeContacts&gt; iterator = mMergeList.iterator();\n            while (iterator.hasNext()) {\n                DuplicatesUtils.MergeContacts next = iterator.next();\n                if (!next.isChecked()) {\n                    iterator.remove();\n                }\n            }\n            mProgressDialog.setMax(mMergeList.size());\n            mProgressDialog.setCancelable(false);\n            mProgressDialog.setCanceledOnTouchOutside(false);\n            mProgressDialog.show();\n            Thread thread = new MergeDuplicatedThread();\n            DuplicatesUtils.mMergeState = true;\n            thread.start();\n        }\n    }\n    return true;\n}\n</code></pre>\n"},{"title":"Build LineageOS for Nexus 5","date":"2018-01-05T04:05:21.000Z","_content":"\n## dependences\nTo build LineageOS, you’ll need:\n\nFor Ubuntu 14.04:\n`\nbc bison build-essential ccache curl flex g++-multilib gcc-multilib git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev libesd0-dev liblz4-tool libncurses5-dev libsdl1.2-dev libssl-dev libwxgtk2.8-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev\n`\n\nFor Ubuntu 16.04 (xenial), substitute:\n`\nlibwxgtk3.0-dev → libwxgtk2.8-dev\n`\n**Java**\nDifferent versions of LineageOS require different JDK (Java Development Kit) versions.\n\nLineageOS 14.1: OpenJDK 1.8 (install openjdk-8-jdk)\nLineageOS 11.0-13.0: OpenJDK 1.7 (install openjdk-7-jdk)\n\n**Enter the following to download the repo binary and make it executable (runnable):**\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\nchmod a+x ~/bin/repo\n\n\n## Get source code\n```bash\n$ repo init -u https://github.com/LineageOS/android.git -b cm-14.1\n$ repo sync\n```\n\n**Prepare the device-specific code**\n```bash\n$ source build/envsetup.sh\n$ breakfast hammerhead\n```\n\n\n\n**Turn on caching to speed up build**\n\nMake use of ccache if you want to speed up subsequent builds by running:\n```bash\n$ export USE_CCACHE=1\n```\nand adding that line to your ~/.bashrc file. Then, specify the maximum amount of disk space you want ccache to use by typing this:\n```bash\n$ ccache -M 50G\n```\n\n## 添加私有库\nvim .repo/local_manifests/lge.xml\n\n```\n<!-- nexus5 -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<manifest>\n  <project name=\"TheMuppets/proprietary_vendor_lge.git\" path=\"vendor/lge\" remote=\"github\" />\n</manifest>\n```\n\n```\n<!-- nexus6p -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<manifest>\n  <project name=\"TheMuppets/proprietary_vendor_huawei.git\" path=\"vendor/huawei\" remote=\"github\" />\n</manifest>\n```\n之后再 repo sync 一次。\n\n## 编译\n```bash\nexport WITH_SU=true //打开root\nbrunch hammerhead\n```\n\n## 刷机\n```bash\nadb reboot bootloader\nsource build/envsetup.sh\n\n#fastboot oem ramdump enable //如果bootloader download 模式未打开\nbreakfast hammerhead\nfastboot -w flashall\n```\n\nPS:\n关于科学上网:\n1.将repo文件 https://android.googlesource.com/ 全部使用 https://aosp.tuna.tsinghua.edu.cn/ 代替。\n2.替换已有的 AOSP 源代码的 remote，将 .repo/manifest.xml 把其中的 aosp 这个 remote 的 fetch 从 https://android.googlesource.com 改为 https://aosp.tuna.tsinghua.edu.cn/。\n```\n<manifest>\n   <remote  name=\"aosp\"\n-           fetch=\"https://android.googlesource.com\"\n+           fetch=\"https://aosp.tuna.tsinghua.edu.cn\"\n            review=\"android-review.googlesource.com\" />\n   <remote  name=\"github\"\n```\n同时，修改 .repo/manifests.git/config，将\n``\nurl = https://android.googlesource.com/platform/manifest\n``\n更改为\n``\nurl = https://aosp.tuna.tsinghua.edu.cn/platform/manifest\n``\n","source":"_posts/Android/为Nexus编译LineageOS.md","raw":"---\ntitle: 'Build LineageOS for Nexus 5'\npermalink: 'Build-LineageOS-for-Nexus-5'\ndate: 2018-01-05 12:05:21\ncategories:\n- Android\ntags:\n- android\n- cm\n- lineageos\n---\n\n## dependences\nTo build LineageOS, you’ll need:\n\nFor Ubuntu 14.04:\n`\nbc bison build-essential ccache curl flex g++-multilib gcc-multilib git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev libesd0-dev liblz4-tool libncurses5-dev libsdl1.2-dev libssl-dev libwxgtk2.8-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev\n`\n\nFor Ubuntu 16.04 (xenial), substitute:\n`\nlibwxgtk3.0-dev → libwxgtk2.8-dev\n`\n**Java**\nDifferent versions of LineageOS require different JDK (Java Development Kit) versions.\n\nLineageOS 14.1: OpenJDK 1.8 (install openjdk-8-jdk)\nLineageOS 11.0-13.0: OpenJDK 1.7 (install openjdk-7-jdk)\n\n**Enter the following to download the repo binary and make it executable (runnable):**\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\nchmod a+x ~/bin/repo\n\n\n## Get source code\n```bash\n$ repo init -u https://github.com/LineageOS/android.git -b cm-14.1\n$ repo sync\n```\n\n**Prepare the device-specific code**\n```bash\n$ source build/envsetup.sh\n$ breakfast hammerhead\n```\n\n\n\n**Turn on caching to speed up build**\n\nMake use of ccache if you want to speed up subsequent builds by running:\n```bash\n$ export USE_CCACHE=1\n```\nand adding that line to your ~/.bashrc file. Then, specify the maximum amount of disk space you want ccache to use by typing this:\n```bash\n$ ccache -M 50G\n```\n\n## 添加私有库\nvim .repo/local_manifests/lge.xml\n\n```\n<!-- nexus5 -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<manifest>\n  <project name=\"TheMuppets/proprietary_vendor_lge.git\" path=\"vendor/lge\" remote=\"github\" />\n</manifest>\n```\n\n```\n<!-- nexus6p -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<manifest>\n  <project name=\"TheMuppets/proprietary_vendor_huawei.git\" path=\"vendor/huawei\" remote=\"github\" />\n</manifest>\n```\n之后再 repo sync 一次。\n\n## 编译\n```bash\nexport WITH_SU=true //打开root\nbrunch hammerhead\n```\n\n## 刷机\n```bash\nadb reboot bootloader\nsource build/envsetup.sh\n\n#fastboot oem ramdump enable //如果bootloader download 模式未打开\nbreakfast hammerhead\nfastboot -w flashall\n```\n\nPS:\n关于科学上网:\n1.将repo文件 https://android.googlesource.com/ 全部使用 https://aosp.tuna.tsinghua.edu.cn/ 代替。\n2.替换已有的 AOSP 源代码的 remote，将 .repo/manifest.xml 把其中的 aosp 这个 remote 的 fetch 从 https://android.googlesource.com 改为 https://aosp.tuna.tsinghua.edu.cn/。\n```\n<manifest>\n   <remote  name=\"aosp\"\n-           fetch=\"https://android.googlesource.com\"\n+           fetch=\"https://aosp.tuna.tsinghua.edu.cn\"\n            review=\"android-review.googlesource.com\" />\n   <remote  name=\"github\"\n```\n同时，修改 .repo/manifests.git/config，将\n``\nurl = https://android.googlesource.com/platform/manifest\n``\n更改为\n``\nurl = https://aosp.tuna.tsinghua.edu.cn/platform/manifest\n``\n","slug":"Build-LineageOS-for-Nexus-5","published":1,"updated":"2018-08-08T03:27:04.534Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwhv000armujf8jbtzw5","content":"<h2 id=\"dependences\"><a href=\"#dependences\" class=\"headerlink\" title=\"dependences\"></a>dependences</h2><p>To build LineageOS, you’ll need:</p>\n<p>For Ubuntu 14.04:<br><code>bc bison build-essential ccache curl flex g++-multilib gcc-multilib git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev libesd0-dev liblz4-tool libncurses5-dev libsdl1.2-dev libssl-dev libwxgtk2.8-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev</code></p>\n<p>For Ubuntu 16.04 (xenial), substitute:<br><code>libwxgtk3.0-dev → libwxgtk2.8-dev</code><br><strong>Java</strong><br>Different versions of LineageOS require different JDK (Java Development Kit) versions.</p>\n<p>LineageOS 14.1: OpenJDK 1.8 (install openjdk-8-jdk)<br>LineageOS 11.0-13.0: OpenJDK 1.7 (install openjdk-7-jdk)</p>\n<p><strong>Enter the following to download the repo binary and make it executable (runnable):</strong><br>curl <a href=\"https://storage.googleapis.com/git-repo-downloads/repo\" target=\"_blank\" rel=\"noopener\">https://storage.googleapis.com/git-repo-downloads/repo</a> &gt; ~/bin/repo<br>chmod a+x ~/bin/repo</p>\n<h2 id=\"Get-source-code\"><a href=\"#Get-source-code\" class=\"headerlink\" title=\"Get source code\"></a>Get source code</h2><pre><code class=\"bash\">$ repo init -u https://github.com/LineageOS/android.git -b cm-14.1\n$ repo sync\n</code></pre>\n<p><strong>Prepare the device-specific code</strong></p>\n<pre><code class=\"bash\">$ source build/envsetup.sh\n$ breakfast hammerhead\n</code></pre>\n<p><strong>Turn on caching to speed up build</strong></p>\n<p>Make use of ccache if you want to speed up subsequent builds by running:</p>\n<pre><code class=\"bash\">$ export USE_CCACHE=1\n</code></pre>\n<p>and adding that line to your ~/.bashrc file. Then, specify the maximum amount of disk space you want ccache to use by typing this:</p>\n<pre><code class=\"bash\">$ ccache -M 50G\n</code></pre>\n<h2 id=\"添加私有库\"><a href=\"#添加私有库\" class=\"headerlink\" title=\"添加私有库\"></a>添加私有库</h2><p>vim .repo/local_manifests/lge.xml</p>\n<pre><code>&lt;!-- nexus5 --&gt;\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;manifest&gt;\n  &lt;project name=&quot;TheMuppets/proprietary_vendor_lge.git&quot; path=&quot;vendor/lge&quot; remote=&quot;github&quot; /&gt;\n&lt;/manifest&gt;\n</code></pre><pre><code>&lt;!-- nexus6p --&gt;\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;manifest&gt;\n  &lt;project name=&quot;TheMuppets/proprietary_vendor_huawei.git&quot; path=&quot;vendor/huawei&quot; remote=&quot;github&quot; /&gt;\n&lt;/manifest&gt;\n</code></pre><p>之后再 repo sync 一次。</p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><pre><code class=\"bash\">export WITH_SU=true //打开root\nbrunch hammerhead\n</code></pre>\n<h2 id=\"刷机\"><a href=\"#刷机\" class=\"headerlink\" title=\"刷机\"></a>刷机</h2><pre><code class=\"bash\">adb reboot bootloader\nsource build/envsetup.sh\n\n#fastboot oem ramdump enable //如果bootloader download 模式未打开\nbreakfast hammerhead\nfastboot -w flashall\n</code></pre>\n<p>PS:<br>关于科学上网:<br>1.将repo文件 <a href=\"https://android.googlesource.com/\" target=\"_blank\" rel=\"noopener\">https://android.googlesource.com/</a> 全部使用 <a href=\"https://aosp.tuna.tsinghua.edu.cn/\" target=\"_blank\" rel=\"noopener\">https://aosp.tuna.tsinghua.edu.cn/</a> 代替。<br>2.替换已有的 AOSP 源代码的 remote，将 .repo/manifest.xml 把其中的 aosp 这个 remote 的 fetch 从 <a href=\"https://android.googlesource.com\" target=\"_blank\" rel=\"noopener\">https://android.googlesource.com</a> 改为 <a href=\"https://aosp.tuna.tsinghua.edu.cn/。\" target=\"_blank\" rel=\"noopener\">https://aosp.tuna.tsinghua.edu.cn/。</a></p>\n<pre><code>&lt;manifest&gt;\n   &lt;remote  name=&quot;aosp&quot;\n-           fetch=&quot;https://android.googlesource.com&quot;\n+           fetch=&quot;https://aosp.tuna.tsinghua.edu.cn&quot;\n            review=&quot;android-review.googlesource.com&quot; /&gt;\n   &lt;remote  name=&quot;github&quot;\n</code></pre><p>同时，修改 .repo/manifests.git/config，将<br><code>url = https://android.googlesource.com/platform/manifest</code><br>更改为<br><code>url = https://aosp.tuna.tsinghua.edu.cn/platform/manifest</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"dependences\"><a href=\"#dependences\" class=\"headerlink\" title=\"dependences\"></a>dependences</h2><p>To build LineageOS, you’ll need:</p>\n<p>For Ubuntu 14.04:<br><code>bc bison build-essential ccache curl flex g++-multilib gcc-multilib git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev libesd0-dev liblz4-tool libncurses5-dev libsdl1.2-dev libssl-dev libwxgtk2.8-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev</code></p>\n<p>For Ubuntu 16.04 (xenial), substitute:<br><code>libwxgtk3.0-dev → libwxgtk2.8-dev</code><br><strong>Java</strong><br>Different versions of LineageOS require different JDK (Java Development Kit) versions.</p>\n<p>LineageOS 14.1: OpenJDK 1.8 (install openjdk-8-jdk)<br>LineageOS 11.0-13.0: OpenJDK 1.7 (install openjdk-7-jdk)</p>\n<p><strong>Enter the following to download the repo binary and make it executable (runnable):</strong><br>curl <a href=\"https://storage.googleapis.com/git-repo-downloads/repo\" target=\"_blank\" rel=\"noopener\">https://storage.googleapis.com/git-repo-downloads/repo</a> &gt; ~/bin/repo<br>chmod a+x ~/bin/repo</p>\n<h2 id=\"Get-source-code\"><a href=\"#Get-source-code\" class=\"headerlink\" title=\"Get source code\"></a>Get source code</h2><pre><code class=\"bash\">$ repo init -u https://github.com/LineageOS/android.git -b cm-14.1\n$ repo sync\n</code></pre>\n<p><strong>Prepare the device-specific code</strong></p>\n<pre><code class=\"bash\">$ source build/envsetup.sh\n$ breakfast hammerhead\n</code></pre>\n<p><strong>Turn on caching to speed up build</strong></p>\n<p>Make use of ccache if you want to speed up subsequent builds by running:</p>\n<pre><code class=\"bash\">$ export USE_CCACHE=1\n</code></pre>\n<p>and adding that line to your ~/.bashrc file. Then, specify the maximum amount of disk space you want ccache to use by typing this:</p>\n<pre><code class=\"bash\">$ ccache -M 50G\n</code></pre>\n<h2 id=\"添加私有库\"><a href=\"#添加私有库\" class=\"headerlink\" title=\"添加私有库\"></a>添加私有库</h2><p>vim .repo/local_manifests/lge.xml</p>\n<pre><code>&lt;!-- nexus5 --&gt;\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;manifest&gt;\n  &lt;project name=&quot;TheMuppets/proprietary_vendor_lge.git&quot; path=&quot;vendor/lge&quot; remote=&quot;github&quot; /&gt;\n&lt;/manifest&gt;\n</code></pre><pre><code>&lt;!-- nexus6p --&gt;\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;manifest&gt;\n  &lt;project name=&quot;TheMuppets/proprietary_vendor_huawei.git&quot; path=&quot;vendor/huawei&quot; remote=&quot;github&quot; /&gt;\n&lt;/manifest&gt;\n</code></pre><p>之后再 repo sync 一次。</p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><pre><code class=\"bash\">export WITH_SU=true //打开root\nbrunch hammerhead\n</code></pre>\n<h2 id=\"刷机\"><a href=\"#刷机\" class=\"headerlink\" title=\"刷机\"></a>刷机</h2><pre><code class=\"bash\">adb reboot bootloader\nsource build/envsetup.sh\n\n#fastboot oem ramdump enable //如果bootloader download 模式未打开\nbreakfast hammerhead\nfastboot -w flashall\n</code></pre>\n<p>PS:<br>关于科学上网:<br>1.将repo文件 <a href=\"https://android.googlesource.com/\" target=\"_blank\" rel=\"noopener\">https://android.googlesource.com/</a> 全部使用 <a href=\"https://aosp.tuna.tsinghua.edu.cn/\" target=\"_blank\" rel=\"noopener\">https://aosp.tuna.tsinghua.edu.cn/</a> 代替。<br>2.替换已有的 AOSP 源代码的 remote，将 .repo/manifest.xml 把其中的 aosp 这个 remote 的 fetch 从 <a href=\"https://android.googlesource.com\" target=\"_blank\" rel=\"noopener\">https://android.googlesource.com</a> 改为 <a href=\"https://aosp.tuna.tsinghua.edu.cn/。\" target=\"_blank\" rel=\"noopener\">https://aosp.tuna.tsinghua.edu.cn/。</a></p>\n<pre><code>&lt;manifest&gt;\n   &lt;remote  name=&quot;aosp&quot;\n-           fetch=&quot;https://android.googlesource.com&quot;\n+           fetch=&quot;https://aosp.tuna.tsinghua.edu.cn&quot;\n            review=&quot;android-review.googlesource.com&quot; /&gt;\n   &lt;remote  name=&quot;github&quot;\n</code></pre><p>同时，修改 .repo/manifests.git/config，将<br><code>url = https://android.googlesource.com/platform/manifest</code><br>更改为<br><code>url = https://aosp.tuna.tsinghua.edu.cn/platform/manifest</code></p>\n"},{"title":"多语言下，String子串可点击并实现跳转","date":"2018-01-22T09:53:49.000Z","_content":"\n## 总结\n通过Spannable实现色彩效果，ClickableSpan实现点击。\n\n对于resource string，通过添加标签位，来计算不同语言下，可点击的substring的index\n\n## 工具类\n\n```java\n//LinkifyUtils.java\npublic class LinkifyUtils {\n    private static final String PLACE_HOLDER_LINK_BEGIN = \"LINK_BEGIN\";\n    private static final String PLACE_HOLDER_LINK_END = \"LINK_END\";\n\n    private LinkifyUtils() {\n    }\n\n    /** Interface that handles the click event of the link */\n    public interface OnClickListener {\n        void onClick();\n    }\n\n    /**\n     * Applies the text into the {@link TextView} and part of it a clickable link.\n     * The text surrounded with \"LINK_BEGIN\" and \"LINK_END\" will become a clickable link. Only\n     * supports at most one link.\n     * @return true if the link has been successfully applied, or false if the original text\n     *         contains no link place holders.\n     */\n    public static boolean linkify(TextView textView, StringBuilder text,\n                                  final OnClickListener listener) {\n        // Remove place-holders from the string and record their positions\n        final int beginIndex = text.indexOf(PLACE_HOLDER_LINK_BEGIN);\n        if (beginIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(beginIndex, beginIndex + PLACE_HOLDER_LINK_BEGIN.length());\n        final int endIndex = text.indexOf(PLACE_HOLDER_LINK_END);\n        if (endIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(endIndex, endIndex + PLACE_HOLDER_LINK_END.length());\n\n        textView.setText(text.toString(), TextView.BufferType.SPANNABLE);\n        textView.setMovementMethod(LinkMovementMethod.getInstance());\n        Spannable spannableContent = (Spannable) textView.getText();\n        ClickableSpan spannableLink = new ClickableSpan() {\n            @Override\n            public void onClick(View widget) {\n                listener.onClick();\n            }\n\n            @Override\n            public void updateDrawState(TextPaint ds) {\n                super.updateDrawState(ds);\n                ds.setUnderlineText(false);\n            }\n        };\n        spannableContent.setSpan(spannableLink, beginIndex, endIndex,\n                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        return true;\n    }\n}\n```\n\n## UI界面\n\n```java\n//XXXActivity.java\n        StringBuilder contentBuilder = new StringBuilder();\n        contentBuilder.append(getText(R.string.no_internet));\n        LinkifyUtils.linkify(tvEmpty, contentBuilder, new LinkifyUtils.OnClickListener() {\n            @Override\n            public void onClick() {\n                Intent intent = new Intent();\n                intent.setClassName(\"com.android.settings\", \"com.android.settings.wifi.WifiSettings\");\n                startActivity(intent);\n            }\n        });\n```\n\n```xml\n<string name=\"no_internet\">No internet connection. Make sure  <xliff:g id=\"link_begin\">LINK_BEGIN</xliff:g>Wi-Fi<xliff:g id=\"link_end\">LINK_END</xliff:g> is turned on, then try again.</string>\n\n<string name=\"no_internet\">未连接到互联网。请确保  <xliff:g id=\"link_begin\">LINK_BEGIN</xliff:g>Wi-Fi<xliff:g id=\"link_end\">LINK_END</xliff:g> 网路已开启，然后重试。</string>\n\n```\n","source":"_posts/Android/多语言下，String子串可点击并实现跳转.md","raw":"---\ntitle: 多语言下，String子串可点击并实现跳转\npermalink: substring-jump\ncategories:\n  - Android\ntags:\n  - android\ndate: 2018-01-22 17:53:49\n---\n\n## 总结\n通过Spannable实现色彩效果，ClickableSpan实现点击。\n\n对于resource string，通过添加标签位，来计算不同语言下，可点击的substring的index\n\n## 工具类\n\n```java\n//LinkifyUtils.java\npublic class LinkifyUtils {\n    private static final String PLACE_HOLDER_LINK_BEGIN = \"LINK_BEGIN\";\n    private static final String PLACE_HOLDER_LINK_END = \"LINK_END\";\n\n    private LinkifyUtils() {\n    }\n\n    /** Interface that handles the click event of the link */\n    public interface OnClickListener {\n        void onClick();\n    }\n\n    /**\n     * Applies the text into the {@link TextView} and part of it a clickable link.\n     * The text surrounded with \"LINK_BEGIN\" and \"LINK_END\" will become a clickable link. Only\n     * supports at most one link.\n     * @return true if the link has been successfully applied, or false if the original text\n     *         contains no link place holders.\n     */\n    public static boolean linkify(TextView textView, StringBuilder text,\n                                  final OnClickListener listener) {\n        // Remove place-holders from the string and record their positions\n        final int beginIndex = text.indexOf(PLACE_HOLDER_LINK_BEGIN);\n        if (beginIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(beginIndex, beginIndex + PLACE_HOLDER_LINK_BEGIN.length());\n        final int endIndex = text.indexOf(PLACE_HOLDER_LINK_END);\n        if (endIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(endIndex, endIndex + PLACE_HOLDER_LINK_END.length());\n\n        textView.setText(text.toString(), TextView.BufferType.SPANNABLE);\n        textView.setMovementMethod(LinkMovementMethod.getInstance());\n        Spannable spannableContent = (Spannable) textView.getText();\n        ClickableSpan spannableLink = new ClickableSpan() {\n            @Override\n            public void onClick(View widget) {\n                listener.onClick();\n            }\n\n            @Override\n            public void updateDrawState(TextPaint ds) {\n                super.updateDrawState(ds);\n                ds.setUnderlineText(false);\n            }\n        };\n        spannableContent.setSpan(spannableLink, beginIndex, endIndex,\n                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        return true;\n    }\n}\n```\n\n## UI界面\n\n```java\n//XXXActivity.java\n        StringBuilder contentBuilder = new StringBuilder();\n        contentBuilder.append(getText(R.string.no_internet));\n        LinkifyUtils.linkify(tvEmpty, contentBuilder, new LinkifyUtils.OnClickListener() {\n            @Override\n            public void onClick() {\n                Intent intent = new Intent();\n                intent.setClassName(\"com.android.settings\", \"com.android.settings.wifi.WifiSettings\");\n                startActivity(intent);\n            }\n        });\n```\n\n```xml\n<string name=\"no_internet\">No internet connection. Make sure  <xliff:g id=\"link_begin\">LINK_BEGIN</xliff:g>Wi-Fi<xliff:g id=\"link_end\">LINK_END</xliff:g> is turned on, then try again.</string>\n\n<string name=\"no_internet\">未连接到互联网。请确保  <xliff:g id=\"link_begin\">LINK_BEGIN</xliff:g>Wi-Fi<xliff:g id=\"link_end\">LINK_END</xliff:g> 网路已开启，然后重试。</string>\n\n```\n","slug":"substring-jump","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwhw000frmujyyqaj9lw","content":"<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过Spannable实现色彩效果，ClickableSpan实现点击。</p>\n<p>对于resource string，通过添加标签位，来计算不同语言下，可点击的substring的index</p>\n<h2 id=\"工具类\"><a href=\"#工具类\" class=\"headerlink\" title=\"工具类\"></a>工具类</h2><pre><code class=\"java\">//LinkifyUtils.java\npublic class LinkifyUtils {\n    private static final String PLACE_HOLDER_LINK_BEGIN = &quot;LINK_BEGIN&quot;;\n    private static final String PLACE_HOLDER_LINK_END = &quot;LINK_END&quot;;\n\n    private LinkifyUtils() {\n    }\n\n    /** Interface that handles the click event of the link */\n    public interface OnClickListener {\n        void onClick();\n    }\n\n    /**\n     * Applies the text into the {@link TextView} and part of it a clickable link.\n     * The text surrounded with &quot;LINK_BEGIN&quot; and &quot;LINK_END&quot; will become a clickable link. Only\n     * supports at most one link.\n     * @return true if the link has been successfully applied, or false if the original text\n     *         contains no link place holders.\n     */\n    public static boolean linkify(TextView textView, StringBuilder text,\n                                  final OnClickListener listener) {\n        // Remove place-holders from the string and record their positions\n        final int beginIndex = text.indexOf(PLACE_HOLDER_LINK_BEGIN);\n        if (beginIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(beginIndex, beginIndex + PLACE_HOLDER_LINK_BEGIN.length());\n        final int endIndex = text.indexOf(PLACE_HOLDER_LINK_END);\n        if (endIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(endIndex, endIndex + PLACE_HOLDER_LINK_END.length());\n\n        textView.setText(text.toString(), TextView.BufferType.SPANNABLE);\n        textView.setMovementMethod(LinkMovementMethod.getInstance());\n        Spannable spannableContent = (Spannable) textView.getText();\n        ClickableSpan spannableLink = new ClickableSpan() {\n            @Override\n            public void onClick(View widget) {\n                listener.onClick();\n            }\n\n            @Override\n            public void updateDrawState(TextPaint ds) {\n                super.updateDrawState(ds);\n                ds.setUnderlineText(false);\n            }\n        };\n        spannableContent.setSpan(spannableLink, beginIndex, endIndex,\n                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        return true;\n    }\n}\n</code></pre>\n<h2 id=\"UI界面\"><a href=\"#UI界面\" class=\"headerlink\" title=\"UI界面\"></a>UI界面</h2><pre><code class=\"java\">//XXXActivity.java\n        StringBuilder contentBuilder = new StringBuilder();\n        contentBuilder.append(getText(R.string.no_internet));\n        LinkifyUtils.linkify(tvEmpty, contentBuilder, new LinkifyUtils.OnClickListener() {\n            @Override\n            public void onClick() {\n                Intent intent = new Intent();\n                intent.setClassName(&quot;com.android.settings&quot;, &quot;com.android.settings.wifi.WifiSettings&quot;);\n                startActivity(intent);\n            }\n        });\n</code></pre>\n<pre><code class=\"xml\">&lt;string name=&quot;no_internet&quot;&gt;No internet connection. Make sure  &lt;xliff:g id=&quot;link_begin&quot;&gt;LINK_BEGIN&lt;/xliff:g&gt;Wi-Fi&lt;xliff:g id=&quot;link_end&quot;&gt;LINK_END&lt;/xliff:g&gt; is turned on, then try again.&lt;/string&gt;\n\n&lt;string name=&quot;no_internet&quot;&gt;未连接到互联网。请确保  &lt;xliff:g id=&quot;link_begin&quot;&gt;LINK_BEGIN&lt;/xliff:g&gt;Wi-Fi&lt;xliff:g id=&quot;link_end&quot;&gt;LINK_END&lt;/xliff:g&gt; 网路已开启，然后重试。&lt;/string&gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过Spannable实现色彩效果，ClickableSpan实现点击。</p>\n<p>对于resource string，通过添加标签位，来计算不同语言下，可点击的substring的index</p>\n<h2 id=\"工具类\"><a href=\"#工具类\" class=\"headerlink\" title=\"工具类\"></a>工具类</h2><pre><code class=\"java\">//LinkifyUtils.java\npublic class LinkifyUtils {\n    private static final String PLACE_HOLDER_LINK_BEGIN = &quot;LINK_BEGIN&quot;;\n    private static final String PLACE_HOLDER_LINK_END = &quot;LINK_END&quot;;\n\n    private LinkifyUtils() {\n    }\n\n    /** Interface that handles the click event of the link */\n    public interface OnClickListener {\n        void onClick();\n    }\n\n    /**\n     * Applies the text into the {@link TextView} and part of it a clickable link.\n     * The text surrounded with &quot;LINK_BEGIN&quot; and &quot;LINK_END&quot; will become a clickable link. Only\n     * supports at most one link.\n     * @return true if the link has been successfully applied, or false if the original text\n     *         contains no link place holders.\n     */\n    public static boolean linkify(TextView textView, StringBuilder text,\n                                  final OnClickListener listener) {\n        // Remove place-holders from the string and record their positions\n        final int beginIndex = text.indexOf(PLACE_HOLDER_LINK_BEGIN);\n        if (beginIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(beginIndex, beginIndex + PLACE_HOLDER_LINK_BEGIN.length());\n        final int endIndex = text.indexOf(PLACE_HOLDER_LINK_END);\n        if (endIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(endIndex, endIndex + PLACE_HOLDER_LINK_END.length());\n\n        textView.setText(text.toString(), TextView.BufferType.SPANNABLE);\n        textView.setMovementMethod(LinkMovementMethod.getInstance());\n        Spannable spannableContent = (Spannable) textView.getText();\n        ClickableSpan spannableLink = new ClickableSpan() {\n            @Override\n            public void onClick(View widget) {\n                listener.onClick();\n            }\n\n            @Override\n            public void updateDrawState(TextPaint ds) {\n                super.updateDrawState(ds);\n                ds.setUnderlineText(false);\n            }\n        };\n        spannableContent.setSpan(spannableLink, beginIndex, endIndex,\n                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        return true;\n    }\n}\n</code></pre>\n<h2 id=\"UI界面\"><a href=\"#UI界面\" class=\"headerlink\" title=\"UI界面\"></a>UI界面</h2><pre><code class=\"java\">//XXXActivity.java\n        StringBuilder contentBuilder = new StringBuilder();\n        contentBuilder.append(getText(R.string.no_internet));\n        LinkifyUtils.linkify(tvEmpty, contentBuilder, new LinkifyUtils.OnClickListener() {\n            @Override\n            public void onClick() {\n                Intent intent = new Intent();\n                intent.setClassName(&quot;com.android.settings&quot;, &quot;com.android.settings.wifi.WifiSettings&quot;);\n                startActivity(intent);\n            }\n        });\n</code></pre>\n<pre><code class=\"xml\">&lt;string name=&quot;no_internet&quot;&gt;No internet connection. Make sure  &lt;xliff:g id=&quot;link_begin&quot;&gt;LINK_BEGIN&lt;/xliff:g&gt;Wi-Fi&lt;xliff:g id=&quot;link_end&quot;&gt;LINK_END&lt;/xliff:g&gt; is turned on, then try again.&lt;/string&gt;\n\n&lt;string name=&quot;no_internet&quot;&gt;未连接到互联网。请确保  &lt;xliff:g id=&quot;link_begin&quot;&gt;LINK_BEGIN&lt;/xliff:g&gt;Wi-Fi&lt;xliff:g id=&quot;link_end&quot;&gt;LINK_END&lt;/xliff:g&gt; 网路已开启，然后重试。&lt;/string&gt;\n</code></pre>\n"},{"title":"开机导入Sim卡联系人","date":"2018-01-15T14:54:34.000Z","_content":"\n## ContactsProvider\n１.ContactsProvider.apk会启动一个广播接收器SystemStartReceiver来接收BOOT_COMPLETED的广播。\n\n２.ContactsProvider收到该广播后，将raw_contacts表里所有非本地联系人的数据都删除掉。\n然后读取当前是否存在Sim卡，若存在，则发SYNC_ICC_CARD_CONTACTS广播。\n\n3.SystemStartReceiver收到广播后启动一个thread来执行读取sim卡联系人，并发送MSG_NOTIFY_ICC_LOADING的message给主线程，主线程收到后发loadicccontacts广播。\n\n4.开始读取ICC数据库的内容，IccProvider中会执行loadFromEf()，获得IIccPhoneBook接口，通过AIDL调用getAdnRecordsInEf()方法，获取sim卡上的全部联系人数据，返回cursor并装载成ArrayList。\n\n5.子线程给主线程发送MSG_NOTIFY_ICC_CHECKFINISHING的message，表示ICC读取完毕。主线程会发loadicccontacts广播。\n\n6.子线程发送消息MSG_INSERT_NEW_CONTACTS给主线程，进行数据库批量处理的操作，即把几个ContentProviderOperation打包在一起，Transaction事务机制，通过applyBatch()方法，主线程将这些sim卡联系人逐个的添加到raw_contacts表和data表中.\n\n## Contacts\nContacts 收到loadicccontacts的广播，设置当前sim卡联系人已经开始读取，LOADICC_START\nContacts 收到loadicccontacts的广播，设置当前sim卡联系人已经读取完毕，LOADICC_FINISH\n","source":"_posts/Android/开机导入Sim卡联系人.md","raw":"---\ntitle: 开机导入Sim卡联系人\npermalink: import-Sim-card-contacts-when-boot\ncategories:\n  - Android\ntags:\n  - android\n  - 面试\n  - contacts\ndate: 2018-01-15 22:54:34\n---\n\n## ContactsProvider\n１.ContactsProvider.apk会启动一个广播接收器SystemStartReceiver来接收BOOT_COMPLETED的广播。\n\n２.ContactsProvider收到该广播后，将raw_contacts表里所有非本地联系人的数据都删除掉。\n然后读取当前是否存在Sim卡，若存在，则发SYNC_ICC_CARD_CONTACTS广播。\n\n3.SystemStartReceiver收到广播后启动一个thread来执行读取sim卡联系人，并发送MSG_NOTIFY_ICC_LOADING的message给主线程，主线程收到后发loadicccontacts广播。\n\n4.开始读取ICC数据库的内容，IccProvider中会执行loadFromEf()，获得IIccPhoneBook接口，通过AIDL调用getAdnRecordsInEf()方法，获取sim卡上的全部联系人数据，返回cursor并装载成ArrayList。\n\n5.子线程给主线程发送MSG_NOTIFY_ICC_CHECKFINISHING的message，表示ICC读取完毕。主线程会发loadicccontacts广播。\n\n6.子线程发送消息MSG_INSERT_NEW_CONTACTS给主线程，进行数据库批量处理的操作，即把几个ContentProviderOperation打包在一起，Transaction事务机制，通过applyBatch()方法，主线程将这些sim卡联系人逐个的添加到raw_contacts表和data表中.\n\n## Contacts\nContacts 收到loadicccontacts的广播，设置当前sim卡联系人已经开始读取，LOADICC_START\nContacts 收到loadicccontacts的广播，设置当前sim卡联系人已经读取完毕，LOADICC_FINISH\n","slug":"import-Sim-card-contacts-when-boot","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwhy000hrmujnr5qvdon","content":"<h2 id=\"ContactsProvider\"><a href=\"#ContactsProvider\" class=\"headerlink\" title=\"ContactsProvider\"></a>ContactsProvider</h2><p>１.ContactsProvider.apk会启动一个广播接收器SystemStartReceiver来接收BOOT_COMPLETED的广播。</p>\n<p>２.ContactsProvider收到该广播后，将raw_contacts表里所有非本地联系人的数据都删除掉。<br>然后读取当前是否存在Sim卡，若存在，则发SYNC_ICC_CARD_CONTACTS广播。</p>\n<p>3.SystemStartReceiver收到广播后启动一个thread来执行读取sim卡联系人，并发送MSG_NOTIFY_ICC_LOADING的message给主线程，主线程收到后发loadicccontacts广播。</p>\n<p>4.开始读取ICC数据库的内容，IccProvider中会执行loadFromEf()，获得IIccPhoneBook接口，通过AIDL调用getAdnRecordsInEf()方法，获取sim卡上的全部联系人数据，返回cursor并装载成ArrayList。</p>\n<p>5.子线程给主线程发送MSG_NOTIFY_ICC_CHECKFINISHING的message，表示ICC读取完毕。主线程会发loadicccontacts广播。</p>\n<p>6.子线程发送消息MSG_INSERT_NEW_CONTACTS给主线程，进行数据库批量处理的操作，即把几个ContentProviderOperation打包在一起，Transaction事务机制，通过applyBatch()方法，主线程将这些sim卡联系人逐个的添加到raw_contacts表和data表中.</p>\n<h2 id=\"Contacts\"><a href=\"#Contacts\" class=\"headerlink\" title=\"Contacts\"></a>Contacts</h2><p>Contacts 收到loadicccontacts的广播，设置当前sim卡联系人已经开始读取，LOADICC_START<br>Contacts 收到loadicccontacts的广播，设置当前sim卡联系人已经读取完毕，LOADICC_FINISH</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ContactsProvider\"><a href=\"#ContactsProvider\" class=\"headerlink\" title=\"ContactsProvider\"></a>ContactsProvider</h2><p>１.ContactsProvider.apk会启动一个广播接收器SystemStartReceiver来接收BOOT_COMPLETED的广播。</p>\n<p>２.ContactsProvider收到该广播后，将raw_contacts表里所有非本地联系人的数据都删除掉。<br>然后读取当前是否存在Sim卡，若存在，则发SYNC_ICC_CARD_CONTACTS广播。</p>\n<p>3.SystemStartReceiver收到广播后启动一个thread来执行读取sim卡联系人，并发送MSG_NOTIFY_ICC_LOADING的message给主线程，主线程收到后发loadicccontacts广播。</p>\n<p>4.开始读取ICC数据库的内容，IccProvider中会执行loadFromEf()，获得IIccPhoneBook接口，通过AIDL调用getAdnRecordsInEf()方法，获取sim卡上的全部联系人数据，返回cursor并装载成ArrayList。</p>\n<p>5.子线程给主线程发送MSG_NOTIFY_ICC_CHECKFINISHING的message，表示ICC读取完毕。主线程会发loadicccontacts广播。</p>\n<p>6.子线程发送消息MSG_INSERT_NEW_CONTACTS给主线程，进行数据库批量处理的操作，即把几个ContentProviderOperation打包在一起，Transaction事务机制，通过applyBatch()方法，主线程将这些sim卡联系人逐个的添加到raw_contacts表和data表中.</p>\n<h2 id=\"Contacts\"><a href=\"#Contacts\" class=\"headerlink\" title=\"Contacts\"></a>Contacts</h2><p>Contacts 收到loadicccontacts的广播，设置当前sim卡联系人已经开始读取，LOADICC_START<br>Contacts 收到loadicccontacts的广播，设置当前sim卡联系人已经读取完毕，LOADICC_FINISH</p>\n"},{"title":"联系人号码模糊查询","date":"2018-01-01T03:37:02.000Z","_content":"\nAOSP的联系人查询,匹配的号码是从头开始匹配,不支持任意子串的匹配.eg.1234567, 123能匹配, 456不能匹配。\n","source":"_posts/Android/联系人号码模糊查询.md","raw":"---\ntitle: 联系人号码模糊查询\npermalink: contacts-phone-number-fuzzy-search\ncategories:\n  - Android\ntags:\n  - android\n  - contacts\ndate: 2018-01-01 11:37:02\n---\n\nAOSP的联系人查询,匹配的号码是从头开始匹配,不支持任意子串的匹配.eg.1234567, 123能匹配, 456不能匹配。\n","slug":"contacts-phone-number-fuzzy-search","published":1,"updated":"2018-08-20T09:19:00.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwhz000mrmujxq7hbru7","content":"<p>AOSP的联系人查询,匹配的号码是从头开始匹配,不支持任意子串的匹配.eg.1234567, 123能匹配, 456不能匹配。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>AOSP的联系人查询,匹配的号码是从头开始匹配,不支持任意子串的匹配.eg.1234567, 123能匹配, 456不能匹配。</p>\n"},{"title":"跨进程通讯的4种方式","date":"2015-08-10T14:45:19.000Z","_content":"\n## 方式一：访问其他应用程序的Activity\n\n在android系统中有很多应用程序提供了可以跨进程访问的Activity，例如，下面的代码可以直接调用拨打电话的Activity。\nIntent callIntent = new Intent(Intent.ACTION_CALL, Uri.parse(\"tel:12345678\" );\nstartActivity(callIntent);\n\nandroid:exported：\n\ndefault value的值是根据是否有<intent-filter>来决定的，有的话，默认值就是true，没有的话默认值就是false；\n\n如果被设置为了false，那么这个Activity将只会被当前Application或者拥有同样user ID的Application的组件调用。\n\n## 方式二：Content Provider\n使用文件或数据库SqlLite来存储数据\n\n## 方式三：广播（Broadcast）\n## 方式四：AIDL服务\nAIDL 并不需要权限\n","source":"_posts/Android/跨进程通讯的4种方式.md","raw":"---\ntitle: 跨进程通讯的4种方式\npermalink: access-across-processes\ncategories:\n  - Android\ntags:\n  - android\n  - 面试\ndate: 2015-08-10 22:45:19\n---\n\n## 方式一：访问其他应用程序的Activity\n\n在android系统中有很多应用程序提供了可以跨进程访问的Activity，例如，下面的代码可以直接调用拨打电话的Activity。\nIntent callIntent = new Intent(Intent.ACTION_CALL, Uri.parse(\"tel:12345678\" );\nstartActivity(callIntent);\n\nandroid:exported：\n\ndefault value的值是根据是否有<intent-filter>来决定的，有的话，默认值就是true，没有的话默认值就是false；\n\n如果被设置为了false，那么这个Activity将只会被当前Application或者拥有同样user ID的Application的组件调用。\n\n## 方式二：Content Provider\n使用文件或数据库SqlLite来存储数据\n\n## 方式三：广播（Broadcast）\n## 方式四：AIDL服务\nAIDL 并不需要权限\n","slug":"access-across-processes","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwi0000prmujlb4p5tqb","content":"<h2 id=\"方式一：访问其他应用程序的Activity\"><a href=\"#方式一：访问其他应用程序的Activity\" class=\"headerlink\" title=\"方式一：访问其他应用程序的Activity\"></a>方式一：访问其他应用程序的Activity</h2><p>在android系统中有很多应用程序提供了可以跨进程访问的Activity，例如，下面的代码可以直接调用拨打电话的Activity。<br>Intent callIntent = new Intent(Intent.ACTION_CALL, Uri.parse(“tel:12345678” );<br>startActivity(callIntent);</p>\n<p>android:exported：</p>\n<p>default value的值是根据是否有<intent-filter>来决定的，有的话，默认值就是true，没有的话默认值就是false；</intent-filter></p>\n<p>如果被设置为了false，那么这个Activity将只会被当前Application或者拥有同样user ID的Application的组件调用。</p>\n<h2 id=\"方式二：Content-Provider\"><a href=\"#方式二：Content-Provider\" class=\"headerlink\" title=\"方式二：Content Provider\"></a>方式二：Content Provider</h2><p>使用文件或数据库SqlLite来存储数据</p>\n<h2 id=\"方式三：广播（Broadcast）\"><a href=\"#方式三：广播（Broadcast）\" class=\"headerlink\" title=\"方式三：广播（Broadcast）\"></a>方式三：广播（Broadcast）</h2><h2 id=\"方式四：AIDL服务\"><a href=\"#方式四：AIDL服务\" class=\"headerlink\" title=\"方式四：AIDL服务\"></a>方式四：AIDL服务</h2><p>AIDL 并不需要权限</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"方式一：访问其他应用程序的Activity\"><a href=\"#方式一：访问其他应用程序的Activity\" class=\"headerlink\" title=\"方式一：访问其他应用程序的Activity\"></a>方式一：访问其他应用程序的Activity</h2><p>在android系统中有很多应用程序提供了可以跨进程访问的Activity，例如，下面的代码可以直接调用拨打电话的Activity。<br>Intent callIntent = new Intent(Intent.ACTION_CALL, Uri.parse(“tel:12345678” );<br>startActivity(callIntent);</p>\n<p>android:exported：</p>\n<p>default value的值是根据是否有<intent-filter>来决定的，有的话，默认值就是true，没有的话默认值就是false；</intent-filter></p>\n<p>如果被设置为了false，那么这个Activity将只会被当前Application或者拥有同样user ID的Application的组件调用。</p>\n<h2 id=\"方式二：Content-Provider\"><a href=\"#方式二：Content-Provider\" class=\"headerlink\" title=\"方式二：Content Provider\"></a>方式二：Content Provider</h2><p>使用文件或数据库SqlLite来存储数据</p>\n<h2 id=\"方式三：广播（Broadcast）\"><a href=\"#方式三：广播（Broadcast）\" class=\"headerlink\" title=\"方式三：广播（Broadcast）\"></a>方式三：广播（Broadcast）</h2><h2 id=\"方式四：AIDL服务\"><a href=\"#方式四：AIDL服务\" class=\"headerlink\" title=\"方式四：AIDL服务\"></a>方式四：AIDL服务</h2><p>AIDL 并不需要权限</p>\n"},{"title":"blog init","date":"2017-12-23T06:53:20.000Z","_content":"\n```bash\n#!/bin/\nmkdir ~/hexo\ncd ~/hexo\ngit clone https://github.com/steinswang/blog.git\ngit clone https://github.com/steinswang/steinswang.github.io.git\n```\n","source":"_posts/init/blog-init.md","raw":"---\n\ntitle: blog init\npermalink: blog-init\ncategories:\n  - init\ntags:\n  - tools\ndate: 2017-12-23 14:53:20\n---\n\n```bash\n#!/bin/\nmkdir ~/hexo\ncd ~/hexo\ngit clone https://github.com/steinswang/blog.git\ngit clone https://github.com/steinswang/steinswang.github.io.git\n```\n","slug":"blog-init","published":1,"updated":"2018-08-12T13:59:32.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwi1000urmujkrn8ozeu","content":"<pre><code class=\"bash\">#!/bin/\nmkdir ~/hexo\ncd ~/hexo\ngit clone https://github.com/steinswang/blog.git\ngit clone https://github.com/steinswang/steinswang.github.io.git\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<pre><code class=\"bash\">#!/bin/\nmkdir ~/hexo\ncd ~/hexo\ngit clone https://github.com/steinswang/blog.git\ngit clone https://github.com/steinswang/steinswang.github.io.git\n</code></pre>\n"},{"title":"Hexo+GitHub Pages搭建属于自己的blog","date":"2018-01-03T12:34:01.000Z","_content":"\nHexo是一个快速，简单，功能强大的开源博客框架-》[官网](https://hexo.io/)\nGitHub Pages 是一个不受限的网站空间。\n两者相得益彰。给那些喜欢自己折腾的人提供一些借鉴。\n<!--more -->\n## 搭建过程\n### 环境介绍\n博主使用系统：Ubuntu 14.04\n安装 node与npm\n### 安装Hexo\n```bash\nnpm install hexo-cli -g\n```\n### 初始化blog\n```bash\nhexo init blog\n```\n至此，本地blog已经创建完成，是不是很简单，简单到没朋友\n### 选择主题\n可以在[hexo官网](https://hexo.io/themes/)查看自己喜欢的主题\n通过git clone [url] themes/xxx 将主题克隆到本地，\n修改 `_config.yml` 中的theme：xxx\n### 常用命令\n```bash\n#创建一个新的文章\n$ hexo new \"文章名\"\n\n#生成静态文件\n$ hexo generate\n\n#将一个草稿发布出去\n$ hexo publish [layout] <filename>\n\n#启动一个本地服务器\n$ hexo server\n```\n更多命令移步[官方文档](https://hexo.io/docs/commands.html)\n### 搭建github pages\n本地blog已经搭建完成，现在可以发布到github pages上\n#### 注册github账户\n到[github官网](https://github.com/)注册一个github账户\n#### 配置登录免密码\n移步 {% post_link 一个客户端设置多个github账号 %}\n#### 创建github远程仓库\n在github上创建一个仓库 `xxx.github.io` xxx为自己的github用户名\n#### 安装插件\n```bash\n$ npm install hexo-deployer-git --save\n```\n#### 配置Hexo\n修改 `_comfig.yml`,xxx为你的用户名\n```xml\ndeploy:\n   type: git\n   repo: git@github.com:xxx/xxx.github.io.git\n   branch: master\n```\n#### 推送服务器\n```bash\n$ hexo deploy\n```\n>若出现`ERROR Deployer not found: git`报错，请执行上面安装插件步骤\n\n#### 测试\n打开 `xxx.github.io` ，就能看到你的blog了\n","source":"_posts/工具/Hexo-GitHub-Pages搭建属于自己的blog.md","raw":"---\ntitle: Hexo+GitHub Pages搭建属于自己的blog\npermalink: Hexo-GitHub-Pages-Establish-blog\ncategories:\n- 工具\ntags:\n- hexo\n- blog\ndate: 2018-01-03 20:34:01\n---\n\nHexo是一个快速，简单，功能强大的开源博客框架-》[官网](https://hexo.io/)\nGitHub Pages 是一个不受限的网站空间。\n两者相得益彰。给那些喜欢自己折腾的人提供一些借鉴。\n<!--more -->\n## 搭建过程\n### 环境介绍\n博主使用系统：Ubuntu 14.04\n安装 node与npm\n### 安装Hexo\n```bash\nnpm install hexo-cli -g\n```\n### 初始化blog\n```bash\nhexo init blog\n```\n至此，本地blog已经创建完成，是不是很简单，简单到没朋友\n### 选择主题\n可以在[hexo官网](https://hexo.io/themes/)查看自己喜欢的主题\n通过git clone [url] themes/xxx 将主题克隆到本地，\n修改 `_config.yml` 中的theme：xxx\n### 常用命令\n```bash\n#创建一个新的文章\n$ hexo new \"文章名\"\n\n#生成静态文件\n$ hexo generate\n\n#将一个草稿发布出去\n$ hexo publish [layout] <filename>\n\n#启动一个本地服务器\n$ hexo server\n```\n更多命令移步[官方文档](https://hexo.io/docs/commands.html)\n### 搭建github pages\n本地blog已经搭建完成，现在可以发布到github pages上\n#### 注册github账户\n到[github官网](https://github.com/)注册一个github账户\n#### 配置登录免密码\n移步 {% post_link 一个客户端设置多个github账号 %}\n#### 创建github远程仓库\n在github上创建一个仓库 `xxx.github.io` xxx为自己的github用户名\n#### 安装插件\n```bash\n$ npm install hexo-deployer-git --save\n```\n#### 配置Hexo\n修改 `_comfig.yml`,xxx为你的用户名\n```xml\ndeploy:\n   type: git\n   repo: git@github.com:xxx/xxx.github.io.git\n   branch: master\n```\n#### 推送服务器\n```bash\n$ hexo deploy\n```\n>若出现`ERROR Deployer not found: git`报错，请执行上面安装插件步骤\n\n#### 测试\n打开 `xxx.github.io` ，就能看到你的blog了\n","slug":"Hexo-GitHub-Pages-Establish-blog","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwi2000xrmujp961mjls","content":"<p>Hexo是一个快速，简单，功能强大的开源博客框架-》<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">官网</a><br>GitHub Pages 是一个不受限的网站空间。<br>两者相得益彰。给那些喜欢自己折腾的人提供一些借鉴。<br><a id=\"more\"></a></p>\n<h2 id=\"搭建过程\"><a href=\"#搭建过程\" class=\"headerlink\" title=\"搭建过程\"></a>搭建过程</h2><h3 id=\"环境介绍\"><a href=\"#环境介绍\" class=\"headerlink\" title=\"环境介绍\"></a>环境介绍</h3><p>博主使用系统：Ubuntu 14.04<br>安装 node与npm</p>\n<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><pre><code class=\"bash\">npm install hexo-cli -g\n</code></pre>\n<h3 id=\"初始化blog\"><a href=\"#初始化blog\" class=\"headerlink\" title=\"初始化blog\"></a>初始化blog</h3><pre><code class=\"bash\">hexo init blog\n</code></pre>\n<p>至此，本地blog已经创建完成，是不是很简单，简单到没朋友</p>\n<h3 id=\"选择主题\"><a href=\"#选择主题\" class=\"headerlink\" title=\"选择主题\"></a>选择主题</h3><p>可以在<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">hexo官网</a>查看自己喜欢的主题<br>通过git clone [url] themes/xxx 将主题克隆到本地，<br>修改 <code>_config.yml</code> 中的theme：xxx</p>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><pre><code class=\"bash\">#创建一个新的文章\n$ hexo new &quot;文章名&quot;\n\n#生成静态文件\n$ hexo generate\n\n#将一个草稿发布出去\n$ hexo publish [layout] &lt;filename&gt;\n\n#启动一个本地服务器\n$ hexo server\n</code></pre>\n<p>更多命令移步<a href=\"https://hexo.io/docs/commands.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h3 id=\"搭建github-pages\"><a href=\"#搭建github-pages\" class=\"headerlink\" title=\"搭建github pages\"></a>搭建github pages</h3><p>本地blog已经搭建完成，现在可以发布到github pages上</p>\n<h4 id=\"注册github账户\"><a href=\"#注册github账户\" class=\"headerlink\" title=\"注册github账户\"></a>注册github账户</h4><p>到<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">github官网</a>注册一个github账户</p>\n<h4 id=\"配置登录免密码\"><a href=\"#配置登录免密码\" class=\"headerlink\" title=\"配置登录免密码\"></a>配置登录免密码</h4><p>移步 </p>\n<h4 id=\"创建github远程仓库\"><a href=\"#创建github远程仓库\" class=\"headerlink\" title=\"创建github远程仓库\"></a>创建github远程仓库</h4><p>在github上创建一个仓库 <code>xxx.github.io</code> xxx为自己的github用户名</p>\n<h4 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h4><pre><code class=\"bash\">$ npm install hexo-deployer-git --save\n</code></pre>\n<h4 id=\"配置Hexo\"><a href=\"#配置Hexo\" class=\"headerlink\" title=\"配置Hexo\"></a>配置Hexo</h4><p>修改 <code>_comfig.yml</code>,xxx为你的用户名</p>\n<pre><code class=\"xml\">deploy:\n   type: git\n   repo: git@github.com:xxx/xxx.github.io.git\n   branch: master\n</code></pre>\n<h4 id=\"推送服务器\"><a href=\"#推送服务器\" class=\"headerlink\" title=\"推送服务器\"></a>推送服务器</h4><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<blockquote>\n<p>若出现<code>ERROR Deployer not found: git</code>报错，请执行上面安装插件步骤</p>\n</blockquote>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><p>打开 <code>xxx.github.io</code> ，就能看到你的blog了</p>\n","site":{"data":{}},"excerpt":"<p>Hexo是一个快速，简单，功能强大的开源博客框架-》<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">官网</a><br>GitHub Pages 是一个不受限的网站空间。<br>两者相得益彰。给那些喜欢自己折腾的人提供一些借鉴。<br>","more":"</p>\n<h2 id=\"搭建过程\"><a href=\"#搭建过程\" class=\"headerlink\" title=\"搭建过程\"></a>搭建过程</h2><h3 id=\"环境介绍\"><a href=\"#环境介绍\" class=\"headerlink\" title=\"环境介绍\"></a>环境介绍</h3><p>博主使用系统：Ubuntu 14.04<br>安装 node与npm</p>\n<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><pre><code class=\"bash\">npm install hexo-cli -g\n</code></pre>\n<h3 id=\"初始化blog\"><a href=\"#初始化blog\" class=\"headerlink\" title=\"初始化blog\"></a>初始化blog</h3><pre><code class=\"bash\">hexo init blog\n</code></pre>\n<p>至此，本地blog已经创建完成，是不是很简单，简单到没朋友</p>\n<h3 id=\"选择主题\"><a href=\"#选择主题\" class=\"headerlink\" title=\"选择主题\"></a>选择主题</h3><p>可以在<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">hexo官网</a>查看自己喜欢的主题<br>通过git clone [url] themes/xxx 将主题克隆到本地，<br>修改 <code>_config.yml</code> 中的theme：xxx</p>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><pre><code class=\"bash\">#创建一个新的文章\n$ hexo new &quot;文章名&quot;\n\n#生成静态文件\n$ hexo generate\n\n#将一个草稿发布出去\n$ hexo publish [layout] &lt;filename&gt;\n\n#启动一个本地服务器\n$ hexo server\n</code></pre>\n<p>更多命令移步<a href=\"https://hexo.io/docs/commands.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h3 id=\"搭建github-pages\"><a href=\"#搭建github-pages\" class=\"headerlink\" title=\"搭建github pages\"></a>搭建github pages</h3><p>本地blog已经搭建完成，现在可以发布到github pages上</p>\n<h4 id=\"注册github账户\"><a href=\"#注册github账户\" class=\"headerlink\" title=\"注册github账户\"></a>注册github账户</h4><p>到<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">github官网</a>注册一个github账户</p>\n<h4 id=\"配置登录免密码\"><a href=\"#配置登录免密码\" class=\"headerlink\" title=\"配置登录免密码\"></a>配置登录免密码</h4><p>移步 </p>\n<h4 id=\"创建github远程仓库\"><a href=\"#创建github远程仓库\" class=\"headerlink\" title=\"创建github远程仓库\"></a>创建github远程仓库</h4><p>在github上创建一个仓库 <code>xxx.github.io</code> xxx为自己的github用户名</p>\n<h4 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h4><pre><code class=\"bash\">$ npm install hexo-deployer-git --save\n</code></pre>\n<h4 id=\"配置Hexo\"><a href=\"#配置Hexo\" class=\"headerlink\" title=\"配置Hexo\"></a>配置Hexo</h4><p>修改 <code>_comfig.yml</code>,xxx为你的用户名</p>\n<pre><code class=\"xml\">deploy:\n   type: git\n   repo: git@github.com:xxx/xxx.github.io.git\n   branch: master\n</code></pre>\n<h4 id=\"推送服务器\"><a href=\"#推送服务器\" class=\"headerlink\" title=\"推送服务器\"></a>推送服务器</h4><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<blockquote>\n<p>若出现<code>ERROR Deployer not found: git</code>报错，请执行上面安装插件步骤</p>\n</blockquote>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><p>打开 <code>xxx.github.io</code> ，就能看到你的blog了</p>"},{"title":"工具软件&插件","date":"2018-01-23T06:53:20.000Z","_content":"\n## sublime\n\n### package control\nSublime Text 3\n```javascript\nimport urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n```\n\nSublime Text 2\n```javascript\nimport urllib2,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), 'wb' ).write(by) if dh == h else None; print('Error validating download (got %s instead of %s), please try manual install' % (dh, h) if dh != h else 'Please restart Sublime Text to finish installation')\n```\n### Ubuntu下Sublime Text 3输入中文issue\n\n\n```bash\ngit clone https://github.com/lyfeyaj/sublime-text-imfix.git\ncd ~/sublime-text-imfix\n./sublime-imfix\n```\n","source":"_posts/工具/工具软件-插件.md","raw":"---\ntitle: 工具软件&插件\npermalink: tool-softwares-and-plugins\ncategories:\n  - 工具\ntags:\n  - tools\ndate: 2018-01-23 14:53:20\n---\n\n## sublime\n\n### package control\nSublime Text 3\n```javascript\nimport urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n```\n\nSublime Text 2\n```javascript\nimport urllib2,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), 'wb' ).write(by) if dh == h else None; print('Error validating download (got %s instead of %s), please try manual install' % (dh, h) if dh != h else 'Please restart Sublime Text to finish installation')\n```\n### Ubuntu下Sublime Text 3输入中文issue\n\n\n```bash\ngit clone https://github.com/lyfeyaj/sublime-text-imfix.git\ncd ~/sublime-text-imfix\n./sublime-imfix\n```\n","slug":"tool-softwares-and-plugins","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwi30011rmujusixx9vp","content":"<h2 id=\"sublime\"><a href=\"#sublime\" class=\"headerlink\" title=\"sublime\"></a>sublime</h2><h3 id=\"package-control\"><a href=\"#package-control\" class=\"headerlink\" title=\"package control\"></a>package control</h3><p>Sublime Text 3</p>\n<pre><code class=\"javascript\">import urllib.request,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)\n</code></pre>\n<p>Sublime Text 2</p>\n<pre><code class=\"javascript\">import urllib2,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &#39;wb&#39; ).write(by) if dh == h else None; print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h) if dh != h else &#39;Please restart Sublime Text to finish installation&#39;)\n</code></pre>\n<h3 id=\"Ubuntu下Sublime-Text-3输入中文issue\"><a href=\"#Ubuntu下Sublime-Text-3输入中文issue\" class=\"headerlink\" title=\"Ubuntu下Sublime Text 3输入中文issue\"></a>Ubuntu下Sublime Text 3输入中文issue</h3><pre><code class=\"bash\">git clone https://github.com/lyfeyaj/sublime-text-imfix.git\ncd ~/sublime-text-imfix\n./sublime-imfix\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"sublime\"><a href=\"#sublime\" class=\"headerlink\" title=\"sublime\"></a>sublime</h2><h3 id=\"package-control\"><a href=\"#package-control\" class=\"headerlink\" title=\"package control\"></a>package control</h3><p>Sublime Text 3</p>\n<pre><code class=\"javascript\">import urllib.request,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)\n</code></pre>\n<p>Sublime Text 2</p>\n<pre><code class=\"javascript\">import urllib2,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &#39;wb&#39; ).write(by) if dh == h else None; print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h) if dh != h else &#39;Please restart Sublime Text to finish installation&#39;)\n</code></pre>\n<h3 id=\"Ubuntu下Sublime-Text-3输入中文issue\"><a href=\"#Ubuntu下Sublime-Text-3输入中文issue\" class=\"headerlink\" title=\"Ubuntu下Sublime Text 3输入中文issue\"></a>Ubuntu下Sublime Text 3输入中文issue</h3><pre><code class=\"bash\">git clone https://github.com/lyfeyaj/sublime-text-imfix.git\ncd ~/sublime-text-imfix\n./sublime-imfix\n</code></pre>\n"},{"title":"工具软件keys","date":"2018-01-23T06:35:48.000Z","_content":"\n## markdownpad pro:\n\n邮箱：\n```xml\nSoar360@live.com\n```\n\n授权秘钥：\n```xml\nGBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==\n```\n\n## sublime text3:\n\n```xml\n----- BEGIN LICENSE -----\neldon\nSingle User License\nEA7E-1122628\nC0360740 20724B8A 30420C09 6D7E046F\n3F5D5FBB 17EF95DA 2BA7BB27 CCB14947\n27A316BE 8BCF4BC0 252FB8FF FD97DF71\nB11A1DA9 F7119CA0 31984BB9 7D71700C\n2C728BF8 B952E5F5 B941FF64 6D7979DA\nB8EB32F8 8D415F8E F16FE657 A35381CC\n290E2905 96E81236 63D2B06D E5F01A69\n84174B79 7C467714 641A9013 94CA7162\n------ END LICENSE ------\n```\n","source":"_posts/工具/工具软件keys.md","raw":"---\ntitle: 工具软件keys\npermalink: tool-software-keys\ncategories:\n  - 工具\ntags:\n  - tools\n  - keys\ndate: 2018-01-23 14:35:48\n---\n\n## markdownpad pro:\n\n邮箱：\n```xml\nSoar360@live.com\n```\n\n授权秘钥：\n```xml\nGBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==\n```\n\n## sublime text3:\n\n```xml\n----- BEGIN LICENSE -----\neldon\nSingle User License\nEA7E-1122628\nC0360740 20724B8A 30420C09 6D7E046F\n3F5D5FBB 17EF95DA 2BA7BB27 CCB14947\n27A316BE 8BCF4BC0 252FB8FF FD97DF71\nB11A1DA9 F7119CA0 31984BB9 7D71700C\n2C728BF8 B952E5F5 B941FF64 6D7979DA\nB8EB32F8 8D415F8E F16FE657 A35381CC\n290E2905 96E81236 63D2B06D E5F01A69\n84174B79 7C467714 641A9013 94CA7162\n------ END LICENSE ------\n```\n","slug":"tool-software-keys","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwi40015rmujfapvv4vm","content":"<h2 id=\"markdownpad-pro\"><a href=\"#markdownpad-pro\" class=\"headerlink\" title=\"markdownpad pro:\"></a>markdownpad pro:</h2><p>邮箱：</p>\n<pre><code class=\"xml\">Soar360@live.com\n</code></pre>\n<p>授权秘钥：</p>\n<pre><code class=\"xml\">GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==\n</code></pre>\n<h2 id=\"sublime-text3\"><a href=\"#sublime-text3\" class=\"headerlink\" title=\"sublime text3:\"></a>sublime text3:</h2><pre><code class=\"xml\">----- BEGIN LICENSE -----\neldon\nSingle User License\nEA7E-1122628\nC0360740 20724B8A 30420C09 6D7E046F\n3F5D5FBB 17EF95DA 2BA7BB27 CCB14947\n27A316BE 8BCF4BC0 252FB8FF FD97DF71\nB11A1DA9 F7119CA0 31984BB9 7D71700C\n2C728BF8 B952E5F5 B941FF64 6D7979DA\nB8EB32F8 8D415F8E F16FE657 A35381CC\n290E2905 96E81236 63D2B06D E5F01A69\n84174B79 7C467714 641A9013 94CA7162\n------ END LICENSE ------\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"markdownpad-pro\"><a href=\"#markdownpad-pro\" class=\"headerlink\" title=\"markdownpad pro:\"></a>markdownpad pro:</h2><p>邮箱：</p>\n<pre><code class=\"xml\">Soar360@live.com\n</code></pre>\n<p>授权秘钥：</p>\n<pre><code class=\"xml\">GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==\n</code></pre>\n<h2 id=\"sublime-text3\"><a href=\"#sublime-text3\" class=\"headerlink\" title=\"sublime text3:\"></a>sublime text3:</h2><pre><code class=\"xml\">----- BEGIN LICENSE -----\neldon\nSingle User License\nEA7E-1122628\nC0360740 20724B8A 30420C09 6D7E046F\n3F5D5FBB 17EF95DA 2BA7BB27 CCB14947\n27A316BE 8BCF4BC0 252FB8FF FD97DF71\nB11A1DA9 F7119CA0 31984BB9 7D71700C\n2C728BF8 B952E5F5 B941FF64 6D7979DA\nB8EB32F8 8D415F8E F16FE657 A35381CC\n290E2905 96E81236 63D2B06D E5F01A69\n84174B79 7C467714 641A9013 94CA7162\n------ END LICENSE ------\n</code></pre>\n"},{"title":"快捷键说明","date":"2017-12-30T08:45:31.000Z","_content":"\n## 说明\n### 搜索框\n| Key | Descption |\n| :- | :- |\n| ESC | 1.如果输入框有内容，清除内容<br>2.如果输入框无内容，失去焦点 |\n| i/I | 获取焦点 |\n| 下 | 向下选择文章 |\n| 上 | 向上选择文章 |\n| 回车 | 打开当前选中的文章，若没有，则默认打开第一个 |\n\n### 全局\n| Key | Descption |\n| :- | :- |\n| s/S | 全屏/取消全屏 |\n| w/W | 打开/关闭文章目录 |\n| j/J | 向下滑动 |\n| k/K | 向上滑动 |\n| gg/GG | 到最顶端 |\n| shift+G/g | 到最下端 |\n\n","source":"_posts/工具/快捷键.md","raw":"---\ntitle: 快捷键说明\ndate: 2017-12-30 16:45:31\npermalink: 3-hexo-shortcuts\ncategories:\n- 工具\ntags:\n- hexo\n- 3-hexo\n---\n\n## 说明\n### 搜索框\n| Key | Descption |\n| :- | :- |\n| ESC | 1.如果输入框有内容，清除内容<br>2.如果输入框无内容，失去焦点 |\n| i/I | 获取焦点 |\n| 下 | 向下选择文章 |\n| 上 | 向上选择文章 |\n| 回车 | 打开当前选中的文章，若没有，则默认打开第一个 |\n\n### 全局\n| Key | Descption |\n| :- | :- |\n| s/S | 全屏/取消全屏 |\n| w/W | 打开/关闭文章目录 |\n| j/J | 向下滑动 |\n| k/K | 向上滑动 |\n| gg/GG | 到最顶端 |\n| shift+G/g | 到最下端 |\n\n","slug":"3-hexo-shortcuts","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwi50018rmujx4bywegy","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><h3 id=\"搜索框\"><a href=\"#搜索框\" class=\"headerlink\" title=\"搜索框\"></a>搜索框</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Key</th>\n<th style=\"text-align:left\">Descption</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ESC</td>\n<td style=\"text-align:left\">1.如果输入框有内容，清除内容<br>2.如果输入框无内容，失去焦点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">i/I</td>\n<td style=\"text-align:left\">获取焦点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">下</td>\n<td style=\"text-align:left\">向下选择文章</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">上</td>\n<td style=\"text-align:left\">向上选择文章</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">回车</td>\n<td style=\"text-align:left\">打开当前选中的文章，若没有，则默认打开第一个</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"全局\"><a href=\"#全局\" class=\"headerlink\" title=\"全局\"></a>全局</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Key</th>\n<th style=\"text-align:left\">Descption</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">s/S</td>\n<td style=\"text-align:left\">全屏/取消全屏</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">w/W</td>\n<td style=\"text-align:left\">打开/关闭文章目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">j/J</td>\n<td style=\"text-align:left\">向下滑动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">k/K</td>\n<td style=\"text-align:left\">向上滑动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">gg/GG</td>\n<td style=\"text-align:left\">到最顶端</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">shift+G/g</td>\n<td style=\"text-align:left\">到最下端</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><h3 id=\"搜索框\"><a href=\"#搜索框\" class=\"headerlink\" title=\"搜索框\"></a>搜索框</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Key</th>\n<th style=\"text-align:left\">Descption</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ESC</td>\n<td style=\"text-align:left\">1.如果输入框有内容，清除内容<br>2.如果输入框无内容，失去焦点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">i/I</td>\n<td style=\"text-align:left\">获取焦点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">下</td>\n<td style=\"text-align:left\">向下选择文章</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">上</td>\n<td style=\"text-align:left\">向上选择文章</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">回车</td>\n<td style=\"text-align:left\">打开当前选中的文章，若没有，则默认打开第一个</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"全局\"><a href=\"#全局\" class=\"headerlink\" title=\"全局\"></a>全局</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Key</th>\n<th style=\"text-align:left\">Descption</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">s/S</td>\n<td style=\"text-align:left\">全屏/取消全屏</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">w/W</td>\n<td style=\"text-align:left\">打开/关闭文章目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">j/J</td>\n<td style=\"text-align:left\">向下滑动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">k/K</td>\n<td style=\"text-align:left\">向上滑动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">gg/GG</td>\n<td style=\"text-align:left\">到最顶端</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">shift+G/g</td>\n<td style=\"text-align:left\">到最下端</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"正则表达式详解","date":"2017-10-04T01:41:40.000Z","_content":"## 本文目标\n>本文旨在更加简洁清晰的展现正则表达式， `第一部分` 是对正则表达式语法的简洁介绍， `第二部分` 则是常用正则表达式的示例。\n\n<!--more -->\n## 简介及语法\n### 正则表达式是什么\n>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\n\n>正则表达式语言由两种基本字符类型组成：原义（正常）`文本字符`和`元字符`。元字符使正则表达式具有处理能力。\n\n### 常用元字符\n\n| 元字符 | 做什么用     |\n| :-------- | :-------- |\n| `.` | 匹配除换行符以外的任意字符 |\n| `\\w`\t| 匹配字母或数字或下划线或汉字 |\n| `\\s` | 匹配任意的空白符，包括空格，制表符（Tab），换行符，中文全角空格等） |\n| `\\d`\t| 匹配数字 |\n|`\\b`\t|匹配单词的开始或结束|\n|`^` |\t匹配字符串的开始|\n|`$` |\t匹配字符串的结束|\n\n### 字符转义\n\n>如果你想查找元字符本身的话，比如你查找 `.` ,或者 `*` ,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用 `\\` 来取消这些字符的特殊意义。因此，你应该使用 `\\.` 和 `\\*` 。当然，要查找 `\\` 本身，你也得用 `\\\\` .\n>例如： `deerchao\\.net` 匹配 **deerchao.net**，`C:\\\\Windows` 匹配 **C:\\Windows** 。\n\n### 重复\n>你已经看过了前面的 `*` , `+` , `{2}` , `{5,12}` 这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)\n\n| 元字符    | 做什么用     |\n| :------------- | :------------- |\n|`*`|\t重复零次或更多次|\n|`+`|\t重复一次或更多次|\n|`?`|\t重复零次或一次|\n|`{n}`|\t重复n次|\n|`{n,}`|重复n次或更多次|\n|`{n,m}`|\t重复n到m次|\n\n>下面是一些重复的示例：\n`Windows\\d+` 匹配Windows后面跟1个或更多数字\n`^\\w+` 匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)\n\n### 字符类\n>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？\n很简单，你只需要在方括号里列出它们就行了，像 `[aeiou]` 就匹配任何一个英文元音字母， `[.?!]` 匹配标点符号(.或?或!)。\n我们也可以轻松地指定一个字符范围，像 `[0-9]` 代表的含意与 `\\d` 就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于 `\\w` （如果只考虑英文的话）。\n下面是一个更复杂的表达式： `\\(?0\\d{2}[) -]?\\d{8}` 。\n这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符\\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。\n\n### 分支条件\n>正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。\n示例： `0\\d{2}-\\d{8}|0\\d{3}-\\d{7}`\n这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。\n示例： `\\d{5}-\\d{4}|\\d{5}`\n这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个示例是因为它能说明一个问题：**使用分枝条件时，要注意各个条件的顺序**。如果你把它改成 `\\d{5}|\\d{5}-\\d{4}` 的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。\n\n### 分组\n>重复单个字符，直接在字符后面加上限定符就行了。但如果想要重复多个字符，我们可以用小括号来指定 **子表达式**(也叫作**分组**)。\n`(\\d{1,3}\\.){3}\\d{1,3}` 是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它： `\\d{1,3}` 匹配1到3位的数字， `(\\d{1,3}\\.){3}` 匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字 `(\\d{1,3})` 。\n不幸的是，它也将匹配 *256.300.888.999* 这种不可能存在的IP地址。我们只能使用冗长的分组，选择，字符串来描述一个 **正确的IP地址：** `((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)`\n\n### 反义\n>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：\n\n| 元字符     | 做什么用     |\n| :------------- | :------------- |\n|`\\W`|\t匹配任意不是字母，数字，下划线，汉字的字符|\n|`\\S`|\t匹配任意不是空白符的字符|\n|`\\D`|\t匹配任意非数字的字符|\n|`\\B`|\t匹配不是单词开头或结束的位置|\n|`[^x]`|\t匹配除了x以外的任意字符|\n|`[^aeiou]`|\t匹配除了aeiou这几个字母以外的任意字符|\n>示例： `\\S+` 匹配不包含空白符的字符串。 `<a[^>]+>` 匹配用尖括号括起来的以a开头的字符串。\n\n### 后向引用\n>使用小括号指定一个子表达式后，**匹配这个子表达式** 的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个 **组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。\n **后向引用** 用于重复搜索前面某个分组匹配的文本。\n示例： `\\b(\\w+)\\b\\s+\\1\\b` 可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字 `\\b(\\w+)\\b` ，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符`\\s+`，最后是分组1中捕获的内容（也就是前面匹配的那个单词） `\\1` 。\n你也可以自己指定子表达式的 **组名**.要指定一个子表达式的组名，请使用这样的语法： `(?<Word>\\w+)` (或者把尖括号换成 `'` 也行： `(?'Word'\\w+))`,这样就把`\\w+`的组名指定为 **Word** 了。要反向引用这个分组捕获的内容，你可以使用 `\\k<Word>` ,所以上一个示例也可以写成这样： `\\b(?<Word>\\w+)\\b\\s+\\k<Word>\\b` 。\n\n### 零宽断言\n>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为 **零宽断言**。\n`(?=exp)` 也叫 **零宽度正预测先行断言**，它断言自身出现的位置的后面能匹配表达式exp。比如`\\b\\w+(?=ing\\b)`，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找 *I'm singing while you're dancing.* 时，它会匹配 sing 和 danc 。\n`(?<=exp)` 也叫 **零宽度正回顾后发断言** ，它断言自身出现的位置的前面能匹配表达式exp。比如 `(?<=\\bre)\\w+\\b` 会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找 *reading a book* 时，它匹配ading。\n假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分： `((?<=\\d)\\d{3})+\\b` ，用它对1234567890进行查找时结果是234567890。\n下面这个示例同时使用了这两种断言： `(?<=\\s)\\d+(?=\\s)` 匹配以空白符间隔的数字( **再次强调，不包括这些空白符** )。\n\n### 负向零宽断言\n>前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：\n`\\b\\w*q[^u]\\w*\\b` 匹配 *包含后面不是字母u的字母q的单词* 。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的 `\\w*\\b` 将会匹配下一个单词，于是 `\\b\\w*q[^u]\\w*\\b` 就能匹配整个Iraq fighting。**负向零宽断言** 能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题： `\\b\\w*q(?!u)\\w*\\b` 。\n**零宽度负预测先行断言**(?!exp)，断言此位置的后面不能匹配表达式exp。例如： `\\d{3}(?!\\d)` 匹配三位数字，而且这三位数字的后面不能是数字； `\\b((?!abc)\\w)+\\b` 匹配不包含连续字符串abc的单词。\n同理，我们可以用(?<!exp),**零宽度负回顾后发断言来断言** 此位置的前面不能匹配表达式exp：(?<![a-z])\\d{7}匹配前面不是小写字母的七位数字。\n一个更复杂的示例：`(?<=<(\\w+)>).*(?=<\\/\\1>)` 匹配不包含属性的简单HTML标签内里的内容。`(?<=<(\\w+)>)` 指定了这样的 **前缀**：被尖括号括起来的单词(比如可能是<b>)，然后是. `*` (任意的字符串),最后是一个 **后缀** `(?=<\\/\\1>)`。注意后缀里的 \\/ ，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的 `(\\w+)` 匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。\n\n### 注释\n>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：`2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)`。\n要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：\n      `(?<=`    # 断言要匹配的文本的前缀\n      `<(\\w+)>` # 查找尖括号括起来的字母或数字(即HTML/XML标签)\n      `)`       # 前缀结束\n      `.*`      # 匹配任意文本\n      `(?=`     # 断言要匹配的文本的后缀\n      `<\\/\\1>`  # 查找尖括号括起来的内容：前面是一个\"/\"，后面是先前捕获的标签\n      `)`       # 后缀结束\n\n### 贪婪与懒惰\n>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配 **尽可能多** 的字符。以这个表达式为例： `a.*b` ，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为 **贪婪匹配**。\n有时，我们更需要 **懒惰匹配**，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 ? 。这样 `.*?` 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。\n示例： `a.*?b` 匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。\n\n| 语法     | 做什么用     |\n| :------------- | :------------- |\n|`*?`|\t重复任意次，但尽可能少重复|\n|`+?`|\t重复1次或更多次，但尽可能少重复|\n|`??`|\t重复0次或1次，但尽可能少重复|\n|`{n,m}?`|\t重复n到m次，但尽可能少重复|\n|`{n,}?`|\t重复n次以上，但尽可能少重复|\n\n### 其他元字符\n\n| 元字符     | 做什么用     |\n| :------------- | :------------- |\n|`\\a`|\t报警字符(打印它的效果是电脑嘀一声)|\n|`\\b`|\t通常是单词分界位置，但如果在字符类里使用代表退格|\n|`\\t`|\t制表符，Tab|\n|`\\r`|\t回车|\n|`\\v`|\t竖向制表符|\n|`\\f`|\t换页符|\n|`\\n`|\t换行符|\n|`\\e`|\tEscape|\n|`\\0nn`|\tASCII代码中八进制代码为nn的字符|\n|`\\xnn`|\tASCII代码中十六进制代码为nn的字符|\n|`\\unnnn`|\tUnicode代码中十六进制代码为nnnn的字符|\n|`\\cN`|\tASCII控制字符。比如\\cC代表Ctrl+C|\n|`\\A`|\t字符串开头(类似^，但不受处理多行选项的影响)|\n|`\\Z`|\t字符串结尾或行尾(不受处理多行选项的影响)|\n|`\\z`|\t字符串结尾(类似$，但不受处理多行选项的影响)|\n|`\\G`|\t当前搜索的开头|\n|`\\p{name}`|\tUnicode中命名为name的字符类，例如\\p{IsGreek}|\n|`(?>exp)`|\t贪婪子表达式|\n|`(?<x>-<y>exp)`|\t平衡组|\n|`(?im-nsx:exp)`|\t在子表达式exp中改变处理选项|\n|`(?im-nsx)`|\t为表达式后面的部分改变处理选项|\n|[1]|\t把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no|\n|`(?(exp)yes)`|\t同上，只是使用空表达式作为no|\n|[2]|\t如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no|\n|`(?(name)yes)`|\t同上，只是使用空表达式作为no|\n>[1]:`(?(exp)yes|no)`\n>[2]:`(?(name)yes|no)`\n\n## 正则表达式常用实例\n### 账号/密码\n```java\n帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线) = \"^[a-zA-Z][a-zA-Z0-9_]{4,15}$\"\n密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线) = \"^[a-zA-Z]\\w{5,17}$\"\n强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间) = \"^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$\"\n```\n### 字符串校验\n```java\n汉字 = \"^[\\u4e00-\\u9fa5]{0,}$\";\n英文和数字 = \"^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$\";\n长度为3-20的所有字符 = \"^.{3,20}$\"；\n由26个英文字母组成的字符串 = \"^[A-Za-z]+$\"；\n由26个大写英文字母组成的字符串 = \"^[A-Z]+$\"；\n由26个小写英文字母组成的字符串 = \"^[a-z]+$\"；\n由数字和26个英文字母组成的字符串 = \"^[A-Za-z0-9]+$\"；\n由数字、26个英文字母或者下划线组成的字符串 = \"^\\w+$ 或 ^\\w{3,20}$\"；\n中文、英文、数字包括下划线 = \"^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\"；\n中文、英文、数字但不包括下划线等符号 = \"^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$\"；\n禁止输入含有~的字符 = \"[^~\\x22]+\"；\n```\n### 手机号\n```java\n/**\n * 手机号码\n * 移动：134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188\n * 联通：130,131,132,145,152,155,156,1709,171,176,185,186\n * 电信：133,134,153,1700,177,180,181,189\n */\nString MOBILE = \"^1(3[0-9]|4[57]|5[0-35-9]|7[01678]|8[0-9])\\\\d{8}$\";\n/**\n * 中国移动：China Mobile\n * 134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188\n */\nString CM = \"^1(3[4-9]|4[7]|5[0-27-9]|7[0]|7[8]|8[2-478])\\\\d{8}$\";\n/**\n * 中国联通：China Unicom\n * 130,131,132,145,152,155,156,1709,171,176,185,186\n */\nString CU = \"^1(3[0-2]|4[5]|5[56]|709|7[1]|7[6]|8[56])\\\\d{8}$\";\n/**\n * 中国电信：China Telecom\n * 133,134,153,1700,177,180,181,189\n */\nString CT = \"^1(3[34]|53|77|700|8[019])\\\\d{8}$\";\n```\n### IP地址\n```java\nString IPREGEXP = \"((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\";\n```\n### EMAIL地址\n```java\nEmail地址 = \"^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\";\n```\n### 域名\n```java\n域名 = \"[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?\";\nInternetURL = \"[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$\"\n```\n### 身份证\n```java\n身份证号(15位、18位数字) = \"^\\d{15}|\\d{18}$\"\n短身份证号码(数字、字母x结尾) = \"^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$\"\n```\n### 数字类校验\n```java\n数字 = \"^[0-9]*$\";\nn位的数字 = \"^\\d{n}$\";\n至少n位的数字 = \"^\\d{n,}$\";\nm-n位的数字 = \"^\\d{m,n}$\";\n零和非零开头的数字 = \"^(0|[1-9][0-9]*)$\";\n非零开头的最多带两位小数的数字 = \"^([1-9][0-9]*)+(.[0-9]{1,2})?$\";\n带1-2位小数的正数或负数 = \"^(\\-)?\\d+(\\.\\d{1,2})?$\";\n正数、负数、和小数 = \"^(\\-|\\+)?\\d+(\\.\\d+)?$\";\n有两位小数的正实数 = \"^[0-9]+(.[0-9]{2})?$\";\n有1~3位小数的正实数 = \"^[0-9]+(.[0-9]{1,3})?$\";\n非零的正整数 = \"^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$\";\n非零的负整数 = \"^\\-[1-9][]0-9\"*$\" 或 \"^-[1-9]\\d*$\";\n```","source":"_posts/工具/正则表达式详解.md","raw":"---\ntitle: 正则表达式详解\npermalink: 正则表达式详解\ndate: 2017-10-04 09:41:40\ncategories:\n- 工具\ntags:\n- 正则表达式\n---\n## 本文目标\n>本文旨在更加简洁清晰的展现正则表达式， `第一部分` 是对正则表达式语法的简洁介绍， `第二部分` 则是常用正则表达式的示例。\n\n<!--more -->\n## 简介及语法\n### 正则表达式是什么\n>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\n\n>正则表达式语言由两种基本字符类型组成：原义（正常）`文本字符`和`元字符`。元字符使正则表达式具有处理能力。\n\n### 常用元字符\n\n| 元字符 | 做什么用     |\n| :-------- | :-------- |\n| `.` | 匹配除换行符以外的任意字符 |\n| `\\w`\t| 匹配字母或数字或下划线或汉字 |\n| `\\s` | 匹配任意的空白符，包括空格，制表符（Tab），换行符，中文全角空格等） |\n| `\\d`\t| 匹配数字 |\n|`\\b`\t|匹配单词的开始或结束|\n|`^` |\t匹配字符串的开始|\n|`$` |\t匹配字符串的结束|\n\n### 字符转义\n\n>如果你想查找元字符本身的话，比如你查找 `.` ,或者 `*` ,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用 `\\` 来取消这些字符的特殊意义。因此，你应该使用 `\\.` 和 `\\*` 。当然，要查找 `\\` 本身，你也得用 `\\\\` .\n>例如： `deerchao\\.net` 匹配 **deerchao.net**，`C:\\\\Windows` 匹配 **C:\\Windows** 。\n\n### 重复\n>你已经看过了前面的 `*` , `+` , `{2}` , `{5,12}` 这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)\n\n| 元字符    | 做什么用     |\n| :------------- | :------------- |\n|`*`|\t重复零次或更多次|\n|`+`|\t重复一次或更多次|\n|`?`|\t重复零次或一次|\n|`{n}`|\t重复n次|\n|`{n,}`|重复n次或更多次|\n|`{n,m}`|\t重复n到m次|\n\n>下面是一些重复的示例：\n`Windows\\d+` 匹配Windows后面跟1个或更多数字\n`^\\w+` 匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)\n\n### 字符类\n>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？\n很简单，你只需要在方括号里列出它们就行了，像 `[aeiou]` 就匹配任何一个英文元音字母， `[.?!]` 匹配标点符号(.或?或!)。\n我们也可以轻松地指定一个字符范围，像 `[0-9]` 代表的含意与 `\\d` 就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于 `\\w` （如果只考虑英文的话）。\n下面是一个更复杂的表达式： `\\(?0\\d{2}[) -]?\\d{8}` 。\n这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符\\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。\n\n### 分支条件\n>正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。\n示例： `0\\d{2}-\\d{8}|0\\d{3}-\\d{7}`\n这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。\n示例： `\\d{5}-\\d{4}|\\d{5}`\n这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个示例是因为它能说明一个问题：**使用分枝条件时，要注意各个条件的顺序**。如果你把它改成 `\\d{5}|\\d{5}-\\d{4}` 的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。\n\n### 分组\n>重复单个字符，直接在字符后面加上限定符就行了。但如果想要重复多个字符，我们可以用小括号来指定 **子表达式**(也叫作**分组**)。\n`(\\d{1,3}\\.){3}\\d{1,3}` 是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它： `\\d{1,3}` 匹配1到3位的数字， `(\\d{1,3}\\.){3}` 匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字 `(\\d{1,3})` 。\n不幸的是，它也将匹配 *256.300.888.999* 这种不可能存在的IP地址。我们只能使用冗长的分组，选择，字符串来描述一个 **正确的IP地址：** `((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)`\n\n### 反义\n>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：\n\n| 元字符     | 做什么用     |\n| :------------- | :------------- |\n|`\\W`|\t匹配任意不是字母，数字，下划线，汉字的字符|\n|`\\S`|\t匹配任意不是空白符的字符|\n|`\\D`|\t匹配任意非数字的字符|\n|`\\B`|\t匹配不是单词开头或结束的位置|\n|`[^x]`|\t匹配除了x以外的任意字符|\n|`[^aeiou]`|\t匹配除了aeiou这几个字母以外的任意字符|\n>示例： `\\S+` 匹配不包含空白符的字符串。 `<a[^>]+>` 匹配用尖括号括起来的以a开头的字符串。\n\n### 后向引用\n>使用小括号指定一个子表达式后，**匹配这个子表达式** 的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个 **组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。\n **后向引用** 用于重复搜索前面某个分组匹配的文本。\n示例： `\\b(\\w+)\\b\\s+\\1\\b` 可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字 `\\b(\\w+)\\b` ，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符`\\s+`，最后是分组1中捕获的内容（也就是前面匹配的那个单词） `\\1` 。\n你也可以自己指定子表达式的 **组名**.要指定一个子表达式的组名，请使用这样的语法： `(?<Word>\\w+)` (或者把尖括号换成 `'` 也行： `(?'Word'\\w+))`,这样就把`\\w+`的组名指定为 **Word** 了。要反向引用这个分组捕获的内容，你可以使用 `\\k<Word>` ,所以上一个示例也可以写成这样： `\\b(?<Word>\\w+)\\b\\s+\\k<Word>\\b` 。\n\n### 零宽断言\n>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为 **零宽断言**。\n`(?=exp)` 也叫 **零宽度正预测先行断言**，它断言自身出现的位置的后面能匹配表达式exp。比如`\\b\\w+(?=ing\\b)`，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找 *I'm singing while you're dancing.* 时，它会匹配 sing 和 danc 。\n`(?<=exp)` 也叫 **零宽度正回顾后发断言** ，它断言自身出现的位置的前面能匹配表达式exp。比如 `(?<=\\bre)\\w+\\b` 会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找 *reading a book* 时，它匹配ading。\n假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分： `((?<=\\d)\\d{3})+\\b` ，用它对1234567890进行查找时结果是234567890。\n下面这个示例同时使用了这两种断言： `(?<=\\s)\\d+(?=\\s)` 匹配以空白符间隔的数字( **再次强调，不包括这些空白符** )。\n\n### 负向零宽断言\n>前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：\n`\\b\\w*q[^u]\\w*\\b` 匹配 *包含后面不是字母u的字母q的单词* 。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的 `\\w*\\b` 将会匹配下一个单词，于是 `\\b\\w*q[^u]\\w*\\b` 就能匹配整个Iraq fighting。**负向零宽断言** 能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题： `\\b\\w*q(?!u)\\w*\\b` 。\n**零宽度负预测先行断言**(?!exp)，断言此位置的后面不能匹配表达式exp。例如： `\\d{3}(?!\\d)` 匹配三位数字，而且这三位数字的后面不能是数字； `\\b((?!abc)\\w)+\\b` 匹配不包含连续字符串abc的单词。\n同理，我们可以用(?<!exp),**零宽度负回顾后发断言来断言** 此位置的前面不能匹配表达式exp：(?<![a-z])\\d{7}匹配前面不是小写字母的七位数字。\n一个更复杂的示例：`(?<=<(\\w+)>).*(?=<\\/\\1>)` 匹配不包含属性的简单HTML标签内里的内容。`(?<=<(\\w+)>)` 指定了这样的 **前缀**：被尖括号括起来的单词(比如可能是<b>)，然后是. `*` (任意的字符串),最后是一个 **后缀** `(?=<\\/\\1>)`。注意后缀里的 \\/ ，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的 `(\\w+)` 匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。\n\n### 注释\n>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：`2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)`。\n要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：\n      `(?<=`    # 断言要匹配的文本的前缀\n      `<(\\w+)>` # 查找尖括号括起来的字母或数字(即HTML/XML标签)\n      `)`       # 前缀结束\n      `.*`      # 匹配任意文本\n      `(?=`     # 断言要匹配的文本的后缀\n      `<\\/\\1>`  # 查找尖括号括起来的内容：前面是一个\"/\"，后面是先前捕获的标签\n      `)`       # 后缀结束\n\n### 贪婪与懒惰\n>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配 **尽可能多** 的字符。以这个表达式为例： `a.*b` ，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为 **贪婪匹配**。\n有时，我们更需要 **懒惰匹配**，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 ? 。这样 `.*?` 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。\n示例： `a.*?b` 匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。\n\n| 语法     | 做什么用     |\n| :------------- | :------------- |\n|`*?`|\t重复任意次，但尽可能少重复|\n|`+?`|\t重复1次或更多次，但尽可能少重复|\n|`??`|\t重复0次或1次，但尽可能少重复|\n|`{n,m}?`|\t重复n到m次，但尽可能少重复|\n|`{n,}?`|\t重复n次以上，但尽可能少重复|\n\n### 其他元字符\n\n| 元字符     | 做什么用     |\n| :------------- | :------------- |\n|`\\a`|\t报警字符(打印它的效果是电脑嘀一声)|\n|`\\b`|\t通常是单词分界位置，但如果在字符类里使用代表退格|\n|`\\t`|\t制表符，Tab|\n|`\\r`|\t回车|\n|`\\v`|\t竖向制表符|\n|`\\f`|\t换页符|\n|`\\n`|\t换行符|\n|`\\e`|\tEscape|\n|`\\0nn`|\tASCII代码中八进制代码为nn的字符|\n|`\\xnn`|\tASCII代码中十六进制代码为nn的字符|\n|`\\unnnn`|\tUnicode代码中十六进制代码为nnnn的字符|\n|`\\cN`|\tASCII控制字符。比如\\cC代表Ctrl+C|\n|`\\A`|\t字符串开头(类似^，但不受处理多行选项的影响)|\n|`\\Z`|\t字符串结尾或行尾(不受处理多行选项的影响)|\n|`\\z`|\t字符串结尾(类似$，但不受处理多行选项的影响)|\n|`\\G`|\t当前搜索的开头|\n|`\\p{name}`|\tUnicode中命名为name的字符类，例如\\p{IsGreek}|\n|`(?>exp)`|\t贪婪子表达式|\n|`(?<x>-<y>exp)`|\t平衡组|\n|`(?im-nsx:exp)`|\t在子表达式exp中改变处理选项|\n|`(?im-nsx)`|\t为表达式后面的部分改变处理选项|\n|[1]|\t把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no|\n|`(?(exp)yes)`|\t同上，只是使用空表达式作为no|\n|[2]|\t如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no|\n|`(?(name)yes)`|\t同上，只是使用空表达式作为no|\n>[1]:`(?(exp)yes|no)`\n>[2]:`(?(name)yes|no)`\n\n## 正则表达式常用实例\n### 账号/密码\n```java\n帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线) = \"^[a-zA-Z][a-zA-Z0-9_]{4,15}$\"\n密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线) = \"^[a-zA-Z]\\w{5,17}$\"\n强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间) = \"^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$\"\n```\n### 字符串校验\n```java\n汉字 = \"^[\\u4e00-\\u9fa5]{0,}$\";\n英文和数字 = \"^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$\";\n长度为3-20的所有字符 = \"^.{3,20}$\"；\n由26个英文字母组成的字符串 = \"^[A-Za-z]+$\"；\n由26个大写英文字母组成的字符串 = \"^[A-Z]+$\"；\n由26个小写英文字母组成的字符串 = \"^[a-z]+$\"；\n由数字和26个英文字母组成的字符串 = \"^[A-Za-z0-9]+$\"；\n由数字、26个英文字母或者下划线组成的字符串 = \"^\\w+$ 或 ^\\w{3,20}$\"；\n中文、英文、数字包括下划线 = \"^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\"；\n中文、英文、数字但不包括下划线等符号 = \"^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$\"；\n禁止输入含有~的字符 = \"[^~\\x22]+\"；\n```\n### 手机号\n```java\n/**\n * 手机号码\n * 移动：134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188\n * 联通：130,131,132,145,152,155,156,1709,171,176,185,186\n * 电信：133,134,153,1700,177,180,181,189\n */\nString MOBILE = \"^1(3[0-9]|4[57]|5[0-35-9]|7[01678]|8[0-9])\\\\d{8}$\";\n/**\n * 中国移动：China Mobile\n * 134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188\n */\nString CM = \"^1(3[4-9]|4[7]|5[0-27-9]|7[0]|7[8]|8[2-478])\\\\d{8}$\";\n/**\n * 中国联通：China Unicom\n * 130,131,132,145,152,155,156,1709,171,176,185,186\n */\nString CU = \"^1(3[0-2]|4[5]|5[56]|709|7[1]|7[6]|8[56])\\\\d{8}$\";\n/**\n * 中国电信：China Telecom\n * 133,134,153,1700,177,180,181,189\n */\nString CT = \"^1(3[34]|53|77|700|8[019])\\\\d{8}$\";\n```\n### IP地址\n```java\nString IPREGEXP = \"((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\";\n```\n### EMAIL地址\n```java\nEmail地址 = \"^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\";\n```\n### 域名\n```java\n域名 = \"[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?\";\nInternetURL = \"[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$\"\n```\n### 身份证\n```java\n身份证号(15位、18位数字) = \"^\\d{15}|\\d{18}$\"\n短身份证号码(数字、字母x结尾) = \"^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$\"\n```\n### 数字类校验\n```java\n数字 = \"^[0-9]*$\";\nn位的数字 = \"^\\d{n}$\";\n至少n位的数字 = \"^\\d{n,}$\";\nm-n位的数字 = \"^\\d{m,n}$\";\n零和非零开头的数字 = \"^(0|[1-9][0-9]*)$\";\n非零开头的最多带两位小数的数字 = \"^([1-9][0-9]*)+(.[0-9]{1,2})?$\";\n带1-2位小数的正数或负数 = \"^(\\-)?\\d+(\\.\\d{1,2})?$\";\n正数、负数、和小数 = \"^(\\-|\\+)?\\d+(\\.\\d+)?$\";\n有两位小数的正实数 = \"^[0-9]+(.[0-9]{2})?$\";\n有1~3位小数的正实数 = \"^[0-9]+(.[0-9]{1,3})?$\";\n非零的正整数 = \"^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$\";\n非零的负整数 = \"^\\-[1-9][]0-9\"*$\" 或 \"^-[1-9]\\d*$\";\n```","slug":"正则表达式详解","published":1,"updated":"2018-08-13T14:21:51.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwi6001crmuj28926dhb","content":"<h2 id=\"本文目标\"><a href=\"#本文目标\" class=\"headerlink\" title=\"本文目标\"></a>本文目标</h2><blockquote>\n<p>本文旨在更加简洁清晰的展现正则表达式， <code>第一部分</code> 是对正则表达式语法的简洁介绍， <code>第二部分</code> 则是常用正则表达式的示例。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"简介及语法\"><a href=\"#简介及语法\" class=\"headerlink\" title=\"简介及语法\"></a>简介及语法</h2><h3 id=\"正则表达式是什么\"><a href=\"#正则表达式是什么\" class=\"headerlink\" title=\"正则表达式是什么\"></a>正则表达式是什么</h3><blockquote>\n<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>\n<p>正则表达式语言由两种基本字符类型组成：原义（正常）<code>文本字符</code>和<code>元字符</code>。元字符使正则表达式具有处理能力。</p>\n</blockquote>\n<h3 id=\"常用元字符\"><a href=\"#常用元字符\" class=\"headerlink\" title=\"常用元字符\"></a>常用元字符</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">元字符</th>\n<th style=\"text-align:left\">做什么用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>.</code></td>\n<td style=\"text-align:left\">匹配除换行符以外的任意字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\w</code></td>\n<td style=\"text-align:left\">匹配字母或数字或下划线或汉字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\s</code></td>\n<td style=\"text-align:left\">匹配任意的空白符，包括空格，制表符（Tab），换行符，中文全角空格等）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\d</code></td>\n<td style=\"text-align:left\">匹配数字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\b</code></td>\n<td style=\"text-align:left\">匹配单词的开始或结束</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>^</code></td>\n<td style=\"text-align:left\">匹配字符串的开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>$</code></td>\n<td style=\"text-align:left\">匹配字符串的结束</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"字符转义\"><a href=\"#字符转义\" class=\"headerlink\" title=\"字符转义\"></a>字符转义</h3><blockquote>\n<p>如果你想查找元字符本身的话，比如你查找 <code>.</code> ,或者 <code>*</code> ,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用 <code>\\</code> 来取消这些字符的特殊意义。因此，你应该使用 <code>\\.</code> 和 <code>\\*</code> 。当然，要查找 <code>\\</code> 本身，你也得用 <code>\\\\</code> .<br>例如： <code>deerchao\\.net</code> 匹配 <strong>deerchao.net</strong>，<code>C:\\\\Windows</code> 匹配 <strong>C:\\Windows</strong> 。</p>\n</blockquote>\n<h3 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h3><blockquote>\n<p>你已经看过了前面的 <code>*</code> , <code>+</code> , <code>{2}</code> , <code>{5,12}</code> 这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">元字符</th>\n<th style=\"text-align:left\">做什么用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>*</code></td>\n<td style=\"text-align:left\">重复零次或更多次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>+</code></td>\n<td style=\"text-align:left\">重复一次或更多次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>?</code></td>\n<td style=\"text-align:left\">重复零次或一次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>{n}</code></td>\n<td style=\"text-align:left\">重复n次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>{n,}</code></td>\n<td style=\"text-align:left\">重复n次或更多次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>{n,m}</code></td>\n<td style=\"text-align:left\">重复n到m次</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>下面是一些重复的示例：<br><code>Windows\\d+</code> 匹配Windows后面跟1个或更多数字<br><code>^\\w+</code> 匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</p>\n</blockquote>\n<h3 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h3><blockquote>\n<p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？<br>很简单，你只需要在方括号里列出它们就行了，像 <code>[aeiou]</code> 就匹配任何一个英文元音字母， <code>[.?!]</code> 匹配标点符号(.或?或!)。<br>我们也可以轻松地指定一个字符范围，像 <code>[0-9]</code> 代表的含意与 <code>\\d</code> 就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于 <code>\\w</code> （如果只考虑英文的话）。<br>下面是一个更复杂的表达式： <code>\\(?0\\d{2}[) -]?\\d{8}</code> 。<br>这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。</p>\n</blockquote>\n<h3 id=\"分支条件\"><a href=\"#分支条件\" class=\"headerlink\" title=\"分支条件\"></a>分支条件</h3><blockquote>\n<p>正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。<br>示例： <code>0\\d{2}-\\d{8}|0\\d{3}-\\d{7}</code><br>这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。<br>示例： <code>\\d{5}-\\d{4}|\\d{5}</code><br>这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个示例是因为它能说明一个问题：<strong>使用分枝条件时，要注意各个条件的顺序</strong>。如果你把它改成 <code>\\d{5}|\\d{5}-\\d{4}</code> 的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>\n</blockquote>\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><blockquote>\n<p>重复单个字符，直接在字符后面加上限定符就行了。但如果想要重复多个字符，我们可以用小括号来指定 <strong>子表达式</strong>(也叫作<strong>分组</strong>)。<br><code>(\\d{1,3}\\.){3}\\d{1,3}</code> 是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它： <code>\\d{1,3}</code> 匹配1到3位的数字， <code>(\\d{1,3}\\.){3}</code> 匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字 <code>(\\d{1,3})</code> 。<br>不幸的是，它也将匹配 <em>256.300.888.999</em> 这种不可能存在的IP地址。我们只能使用冗长的分组，选择，字符串来描述一个 <strong>正确的IP地址：</strong> <code>((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)</code></p>\n</blockquote>\n<h3 id=\"反义\"><a href=\"#反义\" class=\"headerlink\" title=\"反义\"></a>反义</h3><blockquote>\n<p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">元字符</th>\n<th style=\"text-align:left\">做什么用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>\\W</code></td>\n<td style=\"text-align:left\">匹配任意不是字母，数字，下划线，汉字的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\S</code></td>\n<td style=\"text-align:left\">匹配任意不是空白符的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\D</code></td>\n<td style=\"text-align:left\">匹配任意非数字的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\B</code></td>\n<td style=\"text-align:left\">匹配不是单词开头或结束的位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>[^x]</code></td>\n<td style=\"text-align:left\">匹配除了x以外的任意字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>[^aeiou]</code></td>\n<td style=\"text-align:left\">匹配除了aeiou这几个字母以外的任意字符</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>示例： <code>\\S+</code> 匹配不包含空白符的字符串。 <code>&lt;a[^&gt;]+&gt;</code> 匹配用尖括号括起来的以a开头的字符串。</p>\n</blockquote>\n<h3 id=\"后向引用\"><a href=\"#后向引用\" class=\"headerlink\" title=\"后向引用\"></a>后向引用</h3><blockquote>\n<p>使用小括号指定一个子表达式后，<strong>匹配这个子表达式</strong> 的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个 <strong>组号</strong>，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。<br> <strong>后向引用</strong> 用于重复搜索前面某个分组匹配的文本。<br>示例： <code>\\b(\\w+)\\b\\s+\\1\\b</code> 可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字 <code>\\b(\\w+)\\b</code> ，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符<code>\\s+</code>，最后是分组1中捕获的内容（也就是前面匹配的那个单词） <code>\\1</code> 。<br>你也可以自己指定子表达式的 <strong>组名</strong>.要指定一个子表达式的组名，请使用这样的语法： <code>(?&lt;Word&gt;\\w+)</code> (或者把尖括号换成 <code>&#39;</code> 也行： <code>(?&#39;Word&#39;\\w+))</code>,这样就把<code>\\w+</code>的组名指定为 <strong>Word</strong> 了。要反向引用这个分组捕获的内容，你可以使用 <code>\\k&lt;Word&gt;</code> ,所以上一个示例也可以写成这样： <code>\\b(?&lt;Word&gt;\\w+)\\b\\s+\\k&lt;Word&gt;\\b</code> 。</p>\n</blockquote>\n<h3 id=\"零宽断言\"><a href=\"#零宽断言\" class=\"headerlink\" title=\"零宽断言\"></a>零宽断言</h3><blockquote>\n<p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为 <strong>零宽断言</strong>。<br><code>(?=exp)</code> 也叫 <strong>零宽度正预测先行断言</strong>，它断言自身出现的位置的后面能匹配表达式exp。比如<code>\\b\\w+(?=ing\\b)</code>，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找 <em>I’m singing while you’re dancing.</em> 时，它会匹配 sing 和 danc 。<br><code>(?&lt;=exp)</code> 也叫 <strong>零宽度正回顾后发断言</strong> ，它断言自身出现的位置的前面能匹配表达式exp。比如 <code>(?&lt;=\\bre)\\w+\\b</code> 会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找 <em>reading a book</em> 时，它匹配ading。<br>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分： <code>((?&lt;=\\d)\\d{3})+\\b</code> ，用它对1234567890进行查找时结果是234567890。<br>下面这个示例同时使用了这两种断言： <code>(?&lt;=\\s)\\d+(?=\\s)</code> 匹配以空白符间隔的数字( <strong>再次强调，不包括这些空白符</strong> )。</p>\n</blockquote>\n<h3 id=\"负向零宽断言\"><a href=\"#负向零宽断言\" class=\"headerlink\" title=\"负向零宽断言\"></a>负向零宽断言</h3><blockquote>\n<p>前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：<br><code>\\b\\w*q[^u]\\w*\\b</code> 匹配 <em>包含后面不是字母u的字母q的单词</em> 。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的 <code>\\w*\\b</code> 将会匹配下一个单词，于是 <code>\\b\\w*q[^u]\\w*\\b</code> 就能匹配整个Iraq fighting。<strong>负向零宽断言</strong> 能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题： <code>\\b\\w*q(?!u)\\w*\\b</code> 。<br><strong>零宽度负预测先行断言</strong>(?!exp)，断言此位置的后面不能匹配表达式exp。例如： <code>\\d{3}(?!\\d)</code> 匹配三位数字，而且这三位数字的后面不能是数字； <code>\\b((?!abc)\\w)+\\b</code> 匹配不包含连续字符串abc的单词。<br>同理，我们可以用(?&lt;!exp),<strong>零宽度负回顾后发断言来断言</strong> 此位置的前面不能匹配表达式exp：(?&lt;![a-z])\\d{7}匹配前面不是小写字母的七位数字。<br>一个更复杂的示例：<code>(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;)</code> 匹配不包含属性的简单HTML标签内里的内容。<code>(?&lt;=&lt;(\\w+)&gt;)</code> 指定了这样的 <strong>前缀</strong>：被尖括号括起来的单词(比如可能是<b>)，然后是. <code>*</code> (任意的字符串),最后是一个 <strong>后缀</strong> <code>(?=&lt;\\/\\1&gt;)</code>。注意后缀里的 \\/ ，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的 <code>(\\w+)</code> 匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。</b></p>\n</blockquote>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><blockquote>\n<p>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：<code>2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)</code>。<br>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：<br>      <code>(?&lt;=</code>    # 断言要匹配的文本的前缀<br>      <code>&lt;(\\w+)&gt;</code> # 查找尖括号括起来的字母或数字(即HTML/XML标签)<br>      <code>)</code>       # 前缀结束<br>      <code>.*</code>      # 匹配任意文本<br>      <code>(?=</code>     # 断言要匹配的文本的后缀<br>      <code>&lt;\\/\\1&gt;</code>  # 查找尖括号括起来的内容：前面是一个”/“，后面是先前捕获的标签<br>      <code>)</code>       # 后缀结束</p>\n</blockquote>\n<h3 id=\"贪婪与懒惰\"><a href=\"#贪婪与懒惰\" class=\"headerlink\" title=\"贪婪与懒惰\"></a>贪婪与懒惰</h3><blockquote>\n<p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配 <strong>尽可能多</strong> 的字符。以这个表达式为例： <code>a.*b</code> ，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为 <strong>贪婪匹配</strong>。<br>有时，我们更需要 <strong>懒惰匹配</strong>，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 ? 。这样 <code>.*?</code> 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。<br>示例： <code>a.*?b</code> 匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">语法</th>\n<th style=\"text-align:left\">做什么用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>*?</code></td>\n<td style=\"text-align:left\">重复任意次，但尽可能少重复</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>+?</code></td>\n<td style=\"text-align:left\">重复1次或更多次，但尽可能少重复</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>??</code></td>\n<td style=\"text-align:left\">重复0次或1次，但尽可能少重复</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>{n,m}?</code></td>\n<td style=\"text-align:left\">重复n到m次，但尽可能少重复</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>{n,}?</code></td>\n<td style=\"text-align:left\">重复n次以上，但尽可能少重复</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"其他元字符\"><a href=\"#其他元字符\" class=\"headerlink\" title=\"其他元字符\"></a>其他元字符</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">元字符</th>\n<th style=\"text-align:left\">做什么用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>\\a</code></td>\n<td style=\"text-align:left\">报警字符(打印它的效果是电脑嘀一声)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\b</code></td>\n<td style=\"text-align:left\">通常是单词分界位置，但如果在字符类里使用代表退格</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\t</code></td>\n<td style=\"text-align:left\">制表符，Tab</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\r</code></td>\n<td style=\"text-align:left\">回车</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\v</code></td>\n<td style=\"text-align:left\">竖向制表符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\f</code></td>\n<td style=\"text-align:left\">换页符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\n</code></td>\n<td style=\"text-align:left\">换行符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\e</code></td>\n<td style=\"text-align:left\">Escape</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\0nn</code></td>\n<td style=\"text-align:left\">ASCII代码中八进制代码为nn的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\xnn</code></td>\n<td style=\"text-align:left\">ASCII代码中十六进制代码为nn的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\unnnn</code></td>\n<td style=\"text-align:left\">Unicode代码中十六进制代码为nnnn的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\cN</code></td>\n<td style=\"text-align:left\">ASCII控制字符。比如\\cC代表Ctrl+C</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\A</code></td>\n<td style=\"text-align:left\">字符串开头(类似^，但不受处理多行选项的影响)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\Z</code></td>\n<td style=\"text-align:left\">字符串结尾或行尾(不受处理多行选项的影响)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\z</code></td>\n<td style=\"text-align:left\">字符串结尾(类似$，但不受处理多行选项的影响)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\G</code></td>\n<td style=\"text-align:left\">当前搜索的开头</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\p{name}</code></td>\n<td style=\"text-align:left\">Unicode中命名为name的字符类，例如\\p{IsGreek}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>(?&gt;exp)</code></td>\n<td style=\"text-align:left\">贪婪子表达式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>(?&lt;x&gt;-&lt;y&gt;exp)</code></td>\n<td style=\"text-align:left\">平衡组</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>(?im-nsx:exp)</code></td>\n<td style=\"text-align:left\">在子表达式exp中改变处理选项</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>(?im-nsx)</code></td>\n<td style=\"text-align:left\">为表达式后面的部分改变处理选项</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[1]</td>\n<td style=\"text-align:left\">把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>(?(exp)yes)</code></td>\n<td style=\"text-align:left\">同上，只是使用空表达式作为no</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[2]</td>\n<td style=\"text-align:left\">如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>(?(name)yes)</code></td>\n<td style=\"text-align:left\">同上，只是使用空表达式作为no</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>[1]:<code>(?(exp)yes|no)</code></p>\n<p>[2]:<code>(?(name)yes|no)</code></p>\n</blockquote>\n<h2 id=\"正则表达式常用实例\"><a href=\"#正则表达式常用实例\" class=\"headerlink\" title=\"正则表达式常用实例\"></a>正则表达式常用实例</h2><h3 id=\"账号-密码\"><a href=\"#账号-密码\" class=\"headerlink\" title=\"账号/密码\"></a>账号/密码</h3><pre><code class=\"java\">帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线) = &quot;^[a-zA-Z][a-zA-Z0-9_]{4,15}$&quot;\n密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线) = &quot;^[a-zA-Z]\\w{5,17}$&quot;\n强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间) = &quot;^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$&quot;\n</code></pre>\n<h3 id=\"字符串校验\"><a href=\"#字符串校验\" class=\"headerlink\" title=\"字符串校验\"></a>字符串校验</h3><pre><code class=\"java\">汉字 = &quot;^[\\u4e00-\\u9fa5]{0,}$&quot;;\n英文和数字 = &quot;^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$&quot;;\n长度为3-20的所有字符 = &quot;^.{3,20}$&quot;；\n由26个英文字母组成的字符串 = &quot;^[A-Za-z]+$&quot;；\n由26个大写英文字母组成的字符串 = &quot;^[A-Z]+$&quot;；\n由26个小写英文字母组成的字符串 = &quot;^[a-z]+$&quot;；\n由数字和26个英文字母组成的字符串 = &quot;^[A-Za-z0-9]+$&quot;；\n由数字、26个英文字母或者下划线组成的字符串 = &quot;^\\w+$ 或 ^\\w{3,20}$&quot;；\n中文、英文、数字包括下划线 = &quot;^[\\u4E00-\\u9FA5A-Za-z0-9_]+$&quot;；\n中文、英文、数字但不包括下划线等符号 = &quot;^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$&quot;；\n禁止输入含有~的字符 = &quot;[^~\\x22]+&quot;；\n</code></pre>\n<h3 id=\"手机号\"><a href=\"#手机号\" class=\"headerlink\" title=\"手机号\"></a>手机号</h3><pre><code class=\"java\">/**\n * 手机号码\n * 移动：134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188\n * 联通：130,131,132,145,152,155,156,1709,171,176,185,186\n * 电信：133,134,153,1700,177,180,181,189\n */\nString MOBILE = &quot;^1(3[0-9]|4[57]|5[0-35-9]|7[01678]|8[0-9])\\\\d{8}$&quot;;\n/**\n * 中国移动：China Mobile\n * 134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188\n */\nString CM = &quot;^1(3[4-9]|4[7]|5[0-27-9]|7[0]|7[8]|8[2-478])\\\\d{8}$&quot;;\n/**\n * 中国联通：China Unicom\n * 130,131,132,145,152,155,156,1709,171,176,185,186\n */\nString CU = &quot;^1(3[0-2]|4[5]|5[56]|709|7[1]|7[6]|8[56])\\\\d{8}$&quot;;\n/**\n * 中国电信：China Telecom\n * 133,134,153,1700,177,180,181,189\n */\nString CT = &quot;^1(3[34]|53|77|700|8[019])\\\\d{8}$&quot;;\n</code></pre>\n<h3 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h3><pre><code class=\"java\">String IPREGEXP = &quot;((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)&quot;;\n</code></pre>\n<h3 id=\"EMAIL地址\"><a href=\"#EMAIL地址\" class=\"headerlink\" title=\"EMAIL地址\"></a>EMAIL地址</h3><pre><code class=\"java\">Email地址 = &quot;^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$&quot;;\n</code></pre>\n<h3 id=\"域名\"><a href=\"#域名\" class=\"headerlink\" title=\"域名\"></a>域名</h3><pre><code class=\"java\">域名 = &quot;[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?&quot;;\nInternetURL = &quot;[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$&quot;\n</code></pre>\n<h3 id=\"身份证\"><a href=\"#身份证\" class=\"headerlink\" title=\"身份证\"></a>身份证</h3><pre><code class=\"java\">身份证号(15位、18位数字) = &quot;^\\d{15}|\\d{18}$&quot;\n短身份证号码(数字、字母x结尾) = &quot;^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$&quot;\n</code></pre>\n<h3 id=\"数字类校验\"><a href=\"#数字类校验\" class=\"headerlink\" title=\"数字类校验\"></a>数字类校验</h3><pre><code class=\"java\">数字 = &quot;^[0-9]*$&quot;;\nn位的数字 = &quot;^\\d{n}$&quot;;\n至少n位的数字 = &quot;^\\d{n,}$&quot;;\nm-n位的数字 = &quot;^\\d{m,n}$&quot;;\n零和非零开头的数字 = &quot;^(0|[1-9][0-9]*)$&quot;;\n非零开头的最多带两位小数的数字 = &quot;^([1-9][0-9]*)+(.[0-9]{1,2})?$&quot;;\n带1-2位小数的正数或负数 = &quot;^(\\-)?\\d+(\\.\\d{1,2})?$&quot;;\n正数、负数、和小数 = &quot;^(\\-|\\+)?\\d+(\\.\\d+)?$&quot;;\n有两位小数的正实数 = &quot;^[0-9]+(.[0-9]{2})?$&quot;;\n有1~3位小数的正实数 = &quot;^[0-9]+(.[0-9]{1,3})?$&quot;;\n非零的正整数 = &quot;^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$&quot;;\n非零的负整数 = &quot;^\\-[1-9][]0-9&quot;*$&quot; 或 &quot;^-[1-9]\\d*$&quot;;\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"本文目标\"><a href=\"#本文目标\" class=\"headerlink\" title=\"本文目标\"></a>本文目标</h2><blockquote>\n<p>本文旨在更加简洁清晰的展现正则表达式， <code>第一部分</code> 是对正则表达式语法的简洁介绍， <code>第二部分</code> 则是常用正则表达式的示例。</p>\n</blockquote>","more":"<h2 id=\"简介及语法\"><a href=\"#简介及语法\" class=\"headerlink\" title=\"简介及语法\"></a>简介及语法</h2><h3 id=\"正则表达式是什么\"><a href=\"#正则表达式是什么\" class=\"headerlink\" title=\"正则表达式是什么\"></a>正则表达式是什么</h3><blockquote>\n<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>\n<p>正则表达式语言由两种基本字符类型组成：原义（正常）<code>文本字符</code>和<code>元字符</code>。元字符使正则表达式具有处理能力。</p>\n</blockquote>\n<h3 id=\"常用元字符\"><a href=\"#常用元字符\" class=\"headerlink\" title=\"常用元字符\"></a>常用元字符</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">元字符</th>\n<th style=\"text-align:left\">做什么用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>.</code></td>\n<td style=\"text-align:left\">匹配除换行符以外的任意字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\w</code></td>\n<td style=\"text-align:left\">匹配字母或数字或下划线或汉字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\s</code></td>\n<td style=\"text-align:left\">匹配任意的空白符，包括空格，制表符（Tab），换行符，中文全角空格等）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\d</code></td>\n<td style=\"text-align:left\">匹配数字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\b</code></td>\n<td style=\"text-align:left\">匹配单词的开始或结束</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>^</code></td>\n<td style=\"text-align:left\">匹配字符串的开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>$</code></td>\n<td style=\"text-align:left\">匹配字符串的结束</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"字符转义\"><a href=\"#字符转义\" class=\"headerlink\" title=\"字符转义\"></a>字符转义</h3><blockquote>\n<p>如果你想查找元字符本身的话，比如你查找 <code>.</code> ,或者 <code>*</code> ,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用 <code>\\</code> 来取消这些字符的特殊意义。因此，你应该使用 <code>\\.</code> 和 <code>\\*</code> 。当然，要查找 <code>\\</code> 本身，你也得用 <code>\\\\</code> .<br>例如： <code>deerchao\\.net</code> 匹配 <strong>deerchao.net</strong>，<code>C:\\\\Windows</code> 匹配 <strong>C:\\Windows</strong> 。</p>\n</blockquote>\n<h3 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h3><blockquote>\n<p>你已经看过了前面的 <code>*</code> , <code>+</code> , <code>{2}</code> , <code>{5,12}</code> 这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">元字符</th>\n<th style=\"text-align:left\">做什么用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>*</code></td>\n<td style=\"text-align:left\">重复零次或更多次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>+</code></td>\n<td style=\"text-align:left\">重复一次或更多次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>?</code></td>\n<td style=\"text-align:left\">重复零次或一次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>{n}</code></td>\n<td style=\"text-align:left\">重复n次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>{n,}</code></td>\n<td style=\"text-align:left\">重复n次或更多次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>{n,m}</code></td>\n<td style=\"text-align:left\">重复n到m次</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>下面是一些重复的示例：<br><code>Windows\\d+</code> 匹配Windows后面跟1个或更多数字<br><code>^\\w+</code> 匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</p>\n</blockquote>\n<h3 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h3><blockquote>\n<p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？<br>很简单，你只需要在方括号里列出它们就行了，像 <code>[aeiou]</code> 就匹配任何一个英文元音字母， <code>[.?!]</code> 匹配标点符号(.或?或!)。<br>我们也可以轻松地指定一个字符范围，像 <code>[0-9]</code> 代表的含意与 <code>\\d</code> 就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于 <code>\\w</code> （如果只考虑英文的话）。<br>下面是一个更复杂的表达式： <code>\\(?0\\d{2}[) -]?\\d{8}</code> 。<br>这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。</p>\n</blockquote>\n<h3 id=\"分支条件\"><a href=\"#分支条件\" class=\"headerlink\" title=\"分支条件\"></a>分支条件</h3><blockquote>\n<p>正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。<br>示例： <code>0\\d{2}-\\d{8}|0\\d{3}-\\d{7}</code><br>这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。<br>示例： <code>\\d{5}-\\d{4}|\\d{5}</code><br>这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个示例是因为它能说明一个问题：<strong>使用分枝条件时，要注意各个条件的顺序</strong>。如果你把它改成 <code>\\d{5}|\\d{5}-\\d{4}</code> 的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>\n</blockquote>\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><blockquote>\n<p>重复单个字符，直接在字符后面加上限定符就行了。但如果想要重复多个字符，我们可以用小括号来指定 <strong>子表达式</strong>(也叫作<strong>分组</strong>)。<br><code>(\\d{1,3}\\.){3}\\d{1,3}</code> 是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它： <code>\\d{1,3}</code> 匹配1到3位的数字， <code>(\\d{1,3}\\.){3}</code> 匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字 <code>(\\d{1,3})</code> 。<br>不幸的是，它也将匹配 <em>256.300.888.999</em> 这种不可能存在的IP地址。我们只能使用冗长的分组，选择，字符串来描述一个 <strong>正确的IP地址：</strong> <code>((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)</code></p>\n</blockquote>\n<h3 id=\"反义\"><a href=\"#反义\" class=\"headerlink\" title=\"反义\"></a>反义</h3><blockquote>\n<p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">元字符</th>\n<th style=\"text-align:left\">做什么用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>\\W</code></td>\n<td style=\"text-align:left\">匹配任意不是字母，数字，下划线，汉字的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\S</code></td>\n<td style=\"text-align:left\">匹配任意不是空白符的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\D</code></td>\n<td style=\"text-align:left\">匹配任意非数字的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\B</code></td>\n<td style=\"text-align:left\">匹配不是单词开头或结束的位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>[^x]</code></td>\n<td style=\"text-align:left\">匹配除了x以外的任意字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>[^aeiou]</code></td>\n<td style=\"text-align:left\">匹配除了aeiou这几个字母以外的任意字符</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>示例： <code>\\S+</code> 匹配不包含空白符的字符串。 <code>&lt;a[^&gt;]+&gt;</code> 匹配用尖括号括起来的以a开头的字符串。</p>\n</blockquote>\n<h3 id=\"后向引用\"><a href=\"#后向引用\" class=\"headerlink\" title=\"后向引用\"></a>后向引用</h3><blockquote>\n<p>使用小括号指定一个子表达式后，<strong>匹配这个子表达式</strong> 的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个 <strong>组号</strong>，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。<br> <strong>后向引用</strong> 用于重复搜索前面某个分组匹配的文本。<br>示例： <code>\\b(\\w+)\\b\\s+\\1\\b</code> 可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字 <code>\\b(\\w+)\\b</code> ，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符<code>\\s+</code>，最后是分组1中捕获的内容（也就是前面匹配的那个单词） <code>\\1</code> 。<br>你也可以自己指定子表达式的 <strong>组名</strong>.要指定一个子表达式的组名，请使用这样的语法： <code>(?&lt;Word&gt;\\w+)</code> (或者把尖括号换成 <code>&#39;</code> 也行： <code>(?&#39;Word&#39;\\w+))</code>,这样就把<code>\\w+</code>的组名指定为 <strong>Word</strong> 了。要反向引用这个分组捕获的内容，你可以使用 <code>\\k&lt;Word&gt;</code> ,所以上一个示例也可以写成这样： <code>\\b(?&lt;Word&gt;\\w+)\\b\\s+\\k&lt;Word&gt;\\b</code> 。</p>\n</blockquote>\n<h3 id=\"零宽断言\"><a href=\"#零宽断言\" class=\"headerlink\" title=\"零宽断言\"></a>零宽断言</h3><blockquote>\n<p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为 <strong>零宽断言</strong>。<br><code>(?=exp)</code> 也叫 <strong>零宽度正预测先行断言</strong>，它断言自身出现的位置的后面能匹配表达式exp。比如<code>\\b\\w+(?=ing\\b)</code>，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找 <em>I’m singing while you’re dancing.</em> 时，它会匹配 sing 和 danc 。<br><code>(?&lt;=exp)</code> 也叫 <strong>零宽度正回顾后发断言</strong> ，它断言自身出现的位置的前面能匹配表达式exp。比如 <code>(?&lt;=\\bre)\\w+\\b</code> 会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找 <em>reading a book</em> 时，它匹配ading。<br>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分： <code>((?&lt;=\\d)\\d{3})+\\b</code> ，用它对1234567890进行查找时结果是234567890。<br>下面这个示例同时使用了这两种断言： <code>(?&lt;=\\s)\\d+(?=\\s)</code> 匹配以空白符间隔的数字( <strong>再次强调，不包括这些空白符</strong> )。</p>\n</blockquote>\n<h3 id=\"负向零宽断言\"><a href=\"#负向零宽断言\" class=\"headerlink\" title=\"负向零宽断言\"></a>负向零宽断言</h3><blockquote>\n<p>前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：<br><code>\\b\\w*q[^u]\\w*\\b</code> 匹配 <em>包含后面不是字母u的字母q的单词</em> 。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的 <code>\\w*\\b</code> 将会匹配下一个单词，于是 <code>\\b\\w*q[^u]\\w*\\b</code> 就能匹配整个Iraq fighting。<strong>负向零宽断言</strong> 能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题： <code>\\b\\w*q(?!u)\\w*\\b</code> 。<br><strong>零宽度负预测先行断言</strong>(?!exp)，断言此位置的后面不能匹配表达式exp。例如： <code>\\d{3}(?!\\d)</code> 匹配三位数字，而且这三位数字的后面不能是数字； <code>\\b((?!abc)\\w)+\\b</code> 匹配不包含连续字符串abc的单词。<br>同理，我们可以用(?&lt;!exp),<strong>零宽度负回顾后发断言来断言</strong> 此位置的前面不能匹配表达式exp：(?&lt;![a-z])\\d{7}匹配前面不是小写字母的七位数字。<br>一个更复杂的示例：<code>(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;)</code> 匹配不包含属性的简单HTML标签内里的内容。<code>(?&lt;=&lt;(\\w+)&gt;)</code> 指定了这样的 <strong>前缀</strong>：被尖括号括起来的单词(比如可能是<b>)，然后是. <code>*</code> (任意的字符串),最后是一个 <strong>后缀</strong> <code>(?=&lt;\\/\\1&gt;)</code>。注意后缀里的 \\/ ，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的 <code>(\\w+)</code> 匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。</b></p>\n</blockquote>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><blockquote>\n<p>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：<code>2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)</code>。<br>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：<br>      <code>(?&lt;=</code>    # 断言要匹配的文本的前缀<br>      <code>&lt;(\\w+)&gt;</code> # 查找尖括号括起来的字母或数字(即HTML/XML标签)<br>      <code>)</code>       # 前缀结束<br>      <code>.*</code>      # 匹配任意文本<br>      <code>(?=</code>     # 断言要匹配的文本的后缀<br>      <code>&lt;\\/\\1&gt;</code>  # 查找尖括号括起来的内容：前面是一个”/“，后面是先前捕获的标签<br>      <code>)</code>       # 后缀结束</p>\n</blockquote>\n<h3 id=\"贪婪与懒惰\"><a href=\"#贪婪与懒惰\" class=\"headerlink\" title=\"贪婪与懒惰\"></a>贪婪与懒惰</h3><blockquote>\n<p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配 <strong>尽可能多</strong> 的字符。以这个表达式为例： <code>a.*b</code> ，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为 <strong>贪婪匹配</strong>。<br>有时，我们更需要 <strong>懒惰匹配</strong>，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 ? 。这样 <code>.*?</code> 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。<br>示例： <code>a.*?b</code> 匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">语法</th>\n<th style=\"text-align:left\">做什么用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>*?</code></td>\n<td style=\"text-align:left\">重复任意次，但尽可能少重复</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>+?</code></td>\n<td style=\"text-align:left\">重复1次或更多次，但尽可能少重复</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>??</code></td>\n<td style=\"text-align:left\">重复0次或1次，但尽可能少重复</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>{n,m}?</code></td>\n<td style=\"text-align:left\">重复n到m次，但尽可能少重复</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>{n,}?</code></td>\n<td style=\"text-align:left\">重复n次以上，但尽可能少重复</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"其他元字符\"><a href=\"#其他元字符\" class=\"headerlink\" title=\"其他元字符\"></a>其他元字符</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">元字符</th>\n<th style=\"text-align:left\">做什么用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>\\a</code></td>\n<td style=\"text-align:left\">报警字符(打印它的效果是电脑嘀一声)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\b</code></td>\n<td style=\"text-align:left\">通常是单词分界位置，但如果在字符类里使用代表退格</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\t</code></td>\n<td style=\"text-align:left\">制表符，Tab</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\r</code></td>\n<td style=\"text-align:left\">回车</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\v</code></td>\n<td style=\"text-align:left\">竖向制表符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\f</code></td>\n<td style=\"text-align:left\">换页符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\n</code></td>\n<td style=\"text-align:left\">换行符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\e</code></td>\n<td style=\"text-align:left\">Escape</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\0nn</code></td>\n<td style=\"text-align:left\">ASCII代码中八进制代码为nn的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\xnn</code></td>\n<td style=\"text-align:left\">ASCII代码中十六进制代码为nn的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\unnnn</code></td>\n<td style=\"text-align:left\">Unicode代码中十六进制代码为nnnn的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\cN</code></td>\n<td style=\"text-align:left\">ASCII控制字符。比如\\cC代表Ctrl+C</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\A</code></td>\n<td style=\"text-align:left\">字符串开头(类似^，但不受处理多行选项的影响)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\Z</code></td>\n<td style=\"text-align:left\">字符串结尾或行尾(不受处理多行选项的影响)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\z</code></td>\n<td style=\"text-align:left\">字符串结尾(类似$，但不受处理多行选项的影响)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\G</code></td>\n<td style=\"text-align:left\">当前搜索的开头</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>\\p{name}</code></td>\n<td style=\"text-align:left\">Unicode中命名为name的字符类，例如\\p{IsGreek}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>(?&gt;exp)</code></td>\n<td style=\"text-align:left\">贪婪子表达式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>(?&lt;x&gt;-&lt;y&gt;exp)</code></td>\n<td style=\"text-align:left\">平衡组</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>(?im-nsx:exp)</code></td>\n<td style=\"text-align:left\">在子表达式exp中改变处理选项</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>(?im-nsx)</code></td>\n<td style=\"text-align:left\">为表达式后面的部分改变处理选项</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[1]</td>\n<td style=\"text-align:left\">把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>(?(exp)yes)</code></td>\n<td style=\"text-align:left\">同上，只是使用空表达式作为no</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[2]</td>\n<td style=\"text-align:left\">如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>(?(name)yes)</code></td>\n<td style=\"text-align:left\">同上，只是使用空表达式作为no</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>[1]:<code>(?(exp)yes|no)</code></p>\n<p>[2]:<code>(?(name)yes|no)</code></p>\n</blockquote>\n<h2 id=\"正则表达式常用实例\"><a href=\"#正则表达式常用实例\" class=\"headerlink\" title=\"正则表达式常用实例\"></a>正则表达式常用实例</h2><h3 id=\"账号-密码\"><a href=\"#账号-密码\" class=\"headerlink\" title=\"账号/密码\"></a>账号/密码</h3><pre><code class=\"java\">帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线) = &quot;^[a-zA-Z][a-zA-Z0-9_]{4,15}$&quot;\n密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线) = &quot;^[a-zA-Z]\\w{5,17}$&quot;\n强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间) = &quot;^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$&quot;\n</code></pre>\n<h3 id=\"字符串校验\"><a href=\"#字符串校验\" class=\"headerlink\" title=\"字符串校验\"></a>字符串校验</h3><pre><code class=\"java\">汉字 = &quot;^[\\u4e00-\\u9fa5]{0,}$&quot;;\n英文和数字 = &quot;^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$&quot;;\n长度为3-20的所有字符 = &quot;^.{3,20}$&quot;；\n由26个英文字母组成的字符串 = &quot;^[A-Za-z]+$&quot;；\n由26个大写英文字母组成的字符串 = &quot;^[A-Z]+$&quot;；\n由26个小写英文字母组成的字符串 = &quot;^[a-z]+$&quot;；\n由数字和26个英文字母组成的字符串 = &quot;^[A-Za-z0-9]+$&quot;；\n由数字、26个英文字母或者下划线组成的字符串 = &quot;^\\w+$ 或 ^\\w{3,20}$&quot;；\n中文、英文、数字包括下划线 = &quot;^[\\u4E00-\\u9FA5A-Za-z0-9_]+$&quot;；\n中文、英文、数字但不包括下划线等符号 = &quot;^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$&quot;；\n禁止输入含有~的字符 = &quot;[^~\\x22]+&quot;；\n</code></pre>\n<h3 id=\"手机号\"><a href=\"#手机号\" class=\"headerlink\" title=\"手机号\"></a>手机号</h3><pre><code class=\"java\">/**\n * 手机号码\n * 移动：134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188\n * 联通：130,131,132,145,152,155,156,1709,171,176,185,186\n * 电信：133,134,153,1700,177,180,181,189\n */\nString MOBILE = &quot;^1(3[0-9]|4[57]|5[0-35-9]|7[01678]|8[0-9])\\\\d{8}$&quot;;\n/**\n * 中国移动：China Mobile\n * 134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188\n */\nString CM = &quot;^1(3[4-9]|4[7]|5[0-27-9]|7[0]|7[8]|8[2-478])\\\\d{8}$&quot;;\n/**\n * 中国联通：China Unicom\n * 130,131,132,145,152,155,156,1709,171,176,185,186\n */\nString CU = &quot;^1(3[0-2]|4[5]|5[56]|709|7[1]|7[6]|8[56])\\\\d{8}$&quot;;\n/**\n * 中国电信：China Telecom\n * 133,134,153,1700,177,180,181,189\n */\nString CT = &quot;^1(3[34]|53|77|700|8[019])\\\\d{8}$&quot;;\n</code></pre>\n<h3 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h3><pre><code class=\"java\">String IPREGEXP = &quot;((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)&quot;;\n</code></pre>\n<h3 id=\"EMAIL地址\"><a href=\"#EMAIL地址\" class=\"headerlink\" title=\"EMAIL地址\"></a>EMAIL地址</h3><pre><code class=\"java\">Email地址 = &quot;^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$&quot;;\n</code></pre>\n<h3 id=\"域名\"><a href=\"#域名\" class=\"headerlink\" title=\"域名\"></a>域名</h3><pre><code class=\"java\">域名 = &quot;[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?&quot;;\nInternetURL = &quot;[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$&quot;\n</code></pre>\n<h3 id=\"身份证\"><a href=\"#身份证\" class=\"headerlink\" title=\"身份证\"></a>身份证</h3><pre><code class=\"java\">身份证号(15位、18位数字) = &quot;^\\d{15}|\\d{18}$&quot;\n短身份证号码(数字、字母x结尾) = &quot;^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$&quot;\n</code></pre>\n<h3 id=\"数字类校验\"><a href=\"#数字类校验\" class=\"headerlink\" title=\"数字类校验\"></a>数字类校验</h3><pre><code class=\"java\">数字 = &quot;^[0-9]*$&quot;;\nn位的数字 = &quot;^\\d{n}$&quot;;\n至少n位的数字 = &quot;^\\d{n,}$&quot;;\nm-n位的数字 = &quot;^\\d{m,n}$&quot;;\n零和非零开头的数字 = &quot;^(0|[1-9][0-9]*)$&quot;;\n非零开头的最多带两位小数的数字 = &quot;^([1-9][0-9]*)+(.[0-9]{1,2})?$&quot;;\n带1-2位小数的正数或负数 = &quot;^(\\-)?\\d+(\\.\\d{1,2})?$&quot;;\n正数、负数、和小数 = &quot;^(\\-|\\+)?\\d+(\\.\\d+)?$&quot;;\n有两位小数的正实数 = &quot;^[0-9]+(.[0-9]{2})?$&quot;;\n有1~3位小数的正实数 = &quot;^[0-9]+(.[0-9]{1,3})?$&quot;;\n非零的正整数 = &quot;^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$&quot;;\n非零的负整数 = &quot;^\\-[1-9][]0-9&quot;*$&quot; 或 &quot;^-[1-9]\\d*$&quot;;\n</code></pre>"},{"title":"001-Food politics in America","date":"2018-01-22T13:14:37.000Z","_content":"\n# 美国的食品政策\n\n## How to wage war against “Big Soda”\n## 如何发动对“软饮料”的战争\n\nSoda Politics: Taking on Big Soda (and Winning). By Marion Nestle. Oxford University Press; 508 pages; $29.95 and £19.99.\n\n软饮料策略：对付软饮料（然后取得胜利）。作者马里昂•奈斯特。牛津大学出版社。508页。29.95美元，19.99英镑。\n\n&ensp;&ensp;&ensp;&ensp;MARION NESTLE’S heavyweight polemic against Coca-Cola and PepsiCo comes at an odd moment for the industry. Americans are drinking fewer sugary sodas—in 2012 production was 23% below what it had been a decade earlier. Even sales of diet drinks are losing their fizz, as consumers question the merits of artificial sweeteners. From one angle, it would seem that health advocates such as Ms Nestle have won. Yet in America companies still produce 30 gallons of regular (not diet) fizzy drinks per person per year. In many countries, particularly developing ones, consumption is on the rise.\n\n&ensp;&ensp;&ensp;&ensp;软饮料工业正处不尴不尬之际，马里昂•奈斯特对口可口可乐以及百事可乐的抨击颇具影响力。越来越少的美国人选择饮用含糖碳酸饮料----与十年前相比，2012年含糖碳酸饮料的生产减少了23%。人们甚至也失去了对膳食饮料的亲睐，因为消费者们对饮料中是否添加人工甜味剂提出了质疑。从某个角度来看，像奈斯特女士这样的健康倡导者似乎赢得了胜利。然而，美国软饮料公司每年生产的常规碳酸饮料（而非膳食饮料）人均多达30加仑。在许多国家，尤其是发展中国家，常规碳酸饮料的消费仍呈上涨趋势。\n\n\n&ensp;&ensp;&ensp;&ensp;Ms Nestle, a professor at New York University, is both heartened by recent progress and dissatisfied with it. That is no surprise. Her first book, “Food Politics” (2002), remains a bible for those who bewail the power of food companies. In her new book she attacks the industry’s most widely consumed, least healthy product. “Soda Politics”, she says, is a book “to inspire readers to action”. As a rallying cry, it is verbose. When readers learn on page 238 that she will pick up a particular subject in chapter 25, it is with no little dismay that they realise they are only on chapter 17. But what the author wants most is to craft a meticulous guide to the producers’ alleged transgressions, and how to stop them.\n\n&ensp;&ensp;&ensp;&ensp;对于最近取得的进展，奈斯特女士，这位纽约大学的教授颇受鼓舞，但并不满足于此。这也不足为奇。她的第一本书“粮食政策”依旧被那些哀叹食品企业权势的人们奉为经典。在新书中，奈斯特女士对软饮料行业消费最广，最有害健康的产品进行了抨击。《软饮料策略》这本书旨在激励人们采取行动，奈斯特说到。然而作为战斗口号，却显得颇为繁冗。读者们在第238页了解到奈斯特将在第25章讲述一个特别的主题，却意识到自己才看到第17章，但他们并没有因此而沮丧。作者最想做的是拟定一份详细的指南，指出生产商曾经的过失，并想方设法阻止他们的这种行为。\n\n\n&ensp;&ensp;&ensp;&ensp;Ms Nestle says she would have no quibbles with sweet fizzy drinks if they were sipped occasionally, as a treat. However, for millions of people in many countries, they are not. In Mexico companies sold 372 cans of fizzy drinks per person in 2012. About half of Americans do not drink them regularly, but those who do are disproportionately poor, less educated, male, Hispanic or black. Ten per cent of Americans down more than four cans a day.\n\n&ensp;&ensp;&ensp;&ensp;奈斯特说如果人们只是在吃饭招待的时候偶尔饮用加了甜味剂的碳酸饮料，她不会提出异议。但实际上许多国家，成千上万的人们都在喝这种饮料。2012年，仅墨西哥人均消费的碳酸饮料就高达372罐。大约一半的美国人不会经常性地饮用碳酸饮料，但是那些选择碳酸饮料的人多半是些穷困潦倒，未接受良好教育的西班牙或者黑人男性。百分之十的美国人平均每天要喝掉至少4罐碳酸饮料。\n\n\n&ensp;&ensp;&ensp;&ensp;Drinking a lot of sweet fizzy drinks is plainly unhealthy. Unlike a Big Mac, they have no nutritional value; nor do their calories satisfy hunger. One large study found that for each can added to a person’s daily diet, the risk of diabetes jumped by 22%. There are also links between sugar and heart disease, stroke and cancer. Drinking lots of sodas imposes clear costs on individuals, Ms Nestle argues, but it has a broader cost, too. American taxpayers subsidise corn production (and thereby corn syrup) and let the poor use government food vouchers to buy fizzy drinks. More important, taxpayers foot the health bill for those who develop chronic disease.\n\n&ensp;&ensp;&ensp;&ensp;很显然，过度饮用碳酸饮料对身体健康是有害的。与巨无霸不同的是，这些碳酸饮料毫无营养价值，它们产生的热量也无法抵抗饥饿。一项大型研究表明，如果在日常饮食中加入碳酸饮料，那么人们罹患糖尿病的风险就会增加22%。心脏病，中风以及癌症与过多的糖分摄入不无关系。奈斯特说，大量饮用碳酸饮料会增加个人开支，但实际上个人花费要远大于此。美国的纳税人为玉米生产做出了贡献（也就是为玉米糖浆的生产做出了贡献），同时，他们让穷人用政府提供的食品券来购买碳酸饮料。更重要的是，纳税人为那些罹患慢性疾病的人支付医疗帐单。\n\n\n&ensp;&ensp;&ensp;&ensp;Encouraging people to drink fewer fizzy drinks, however, is fiendishly difficult. Soda companies spend billions on marketing; it is a tribute to the admen that Coca-Cola is one of the world’s best-loved brands, despite selling what is essentially fattening sugar-water. (Think of Coca-Cola’s encouragements to “open happiness” and PepsiCo’s exuberant spokeswoman, Beyoncé Knowles.) Once people get used to consuming sugary drinks, they are loth to give them up. There is evidence suggesting that sugar is addictive—some laboratory animals prefer sugar to cocaine.\n\n&ensp;&ensp;&ensp;&ensp;然而，鼓励人们尽量少喝碳酸饮料却出奇的难。碳酸饮料企业在营销上花费巨资。尽管可口可乐售卖的实际上是令人增肥的糖水饮料，但可口可乐无疑是世界上最受消费者青睐的品牌之一。而这对于广告人而言，是件可喜可贺的事情。（想想可口可乐颇具鼓动性的广告语“开启幸福”，百事可乐活力四射的代言人碧昂丝•诺利斯。）人们一旦习惯了消费含糖饮料，便很难戒掉。有证据表明食糖是会上瘾的----与可卡因相比，实验室的动物们更喜欢食糖。\n\n\n&ensp;&ensp;&ensp;&ensp;Most interesting, fizzy-drink companies are skilled at swatting away attempts at regulation. Ms Nestle describes an extraordinarily broad team of allies. That includes obvious friends, such as employees, bottlers and distributors, as well as the restaurants, cinemas, shops and sports stadiums that sell their products. But the companies are also astute philanthropists. When Michael Bloomberg, then mayor of New York, tried to block the use of government vouchers to buy sodas in 2010, the congressional black caucus was among those to lobby against it. The caucus’s foundation has received money from both Coke and Pepsi. In 2011 Philadelphia was considering a soda tax. After the soda lobby offered a big donation to the city’s children’s hospital, the idea fizzled out.\n\n&ensp;&ensp;&ensp;&ensp;更有趣的是，碳酸饮料企业对规避规范化的尝试颇有一套。奈斯特将其描述为一个非比寻常的庞大联盟。很显然，这个联盟包括了这些企业的盟友们，比如雇员，瓶装工，经销商，那些出售他们商品的饭店，电影院，商店以及体育场。但这些碳酸饮料企业同时也是非常精明的慈善家。2010年，当时的纽约市市长迈克尔•布隆伯格试图阻止人们用政府代金券购买碳酸饮料，但却遭到了包括美国国会黑人同盟在内的多数人的反对。2011年，费城考虑是否要征收碳酸饮料税，但在碳酸饮料游说集团出资捐助了一家当地的儿童医院之后，这项提议未能实施。\n\n\n&ensp;&ensp;&ensp;&ensp;Coca-Cola and PepsiCo do have a few notable adversaries. Mr Bloomberg, a billionaire, remains their single biggest foe. It is telling that in two rare instances when a soda tax has been passed—in Berkeley, California and in Mexico—it was with the help of cash from Mr Bloomberg. Drinks companies must also reckon with a small army of health advocates, among which Ms Nestle is a major-general.\n\n&ensp;&ensp;&ensp;&ensp;可口可乐和百事可乐确实有一些颇为出名的对手。布隆伯格，这位亿万富翁是他们最大的对手。据说在两个颇为罕见的通过征收碳酸饮料税的例子中----一个是加利福尼亚的伯克利市，另一个是墨西哥----都是在布隆伯格的资金帮助下通过了碳酸饮料税法案。饮料公司还得去对付那些以奈斯特为首的健康军团。\n\n\n&ensp;&ensp;&ensp;&ensp;With the slow decline of soda in America, she and her allies are advancing. Coca-Cola and PepsiCo are peddling healthier drinks, such as bottled water. However, as they try to face down a long-term threat while maintaining near-term profits, they are still pushing their syrupy fare.\n\n&ensp;&ensp;&ensp;&ensp;随着美国人慢慢地拒绝碳酸饮料，奈斯特和她的盟友们正向成功一步步迈进。可口可乐和百事可乐正忙于推销更健康的饮料，如瓶装水。然而，他们仍旧努力推动碳酸饮料事业的发展，试图在维持短期利润的同时，努力克服长期以来的威胁。\n\n\n&ensp;&ensp;&ensp;&ensp;Ms Nestle is impatient. To the casual reader, her suggestions can seem extreme. She writes enthusiastically about adorning soda cans with warning labels, such as pictures of a diabetic’s foot ulcer. She suggests that parents should teach their children about fizzy drinks by gently boiling down a Coke or a Pepsi into sludge, which sounds rather fun, and asking them to calculate the precise length of grocery shelves bearing sodas, which sounds less so. This zeal threatens to overshadow her stronger points: fizzy drinks offer no nutritional benefit and impose clear costs—on individuals’ health and on society.\n\n&ensp;&ensp;&ensp;&ensp;奈斯特女士可没那么好的耐心。对于一般的读者，她给的建议似乎很极端。在书中她强烈建议碳酸饮料瓶上面必须贴有糖尿病患者脚部溃烂诸如此类的警示标志。她建议父母们在向孩子们介绍碳酸饮料时，将可口可乐和百事可乐说成是垃圾，这看上去颇为有趣，并要求孩子们去算算杂货店摆满碳酸饮料的货架究竟有多长，这听上去似乎没那么好笑了。这份热情让斯耐特关于碳酸饮料的观点显得不那么重要了：碳酸饮料没有任何营养价值，对个人的健康没有好处，而且还增加了社会的负担。\n","source":"_posts/英语/Food-politics-in-America.md","raw":"---\ntitle: 001-Food politics in America\npermalink: food-politics-in-America\ncategories:\n  - 英语\ntags:\n  - english\ndate: 2018-01-22 21:14:37\n---\n\n# 美国的食品政策\n\n## How to wage war against “Big Soda”\n## 如何发动对“软饮料”的战争\n\nSoda Politics: Taking on Big Soda (and Winning). By Marion Nestle. Oxford University Press; 508 pages; $29.95 and £19.99.\n\n软饮料策略：对付软饮料（然后取得胜利）。作者马里昂•奈斯特。牛津大学出版社。508页。29.95美元，19.99英镑。\n\n&ensp;&ensp;&ensp;&ensp;MARION NESTLE’S heavyweight polemic against Coca-Cola and PepsiCo comes at an odd moment for the industry. Americans are drinking fewer sugary sodas—in 2012 production was 23% below what it had been a decade earlier. Even sales of diet drinks are losing their fizz, as consumers question the merits of artificial sweeteners. From one angle, it would seem that health advocates such as Ms Nestle have won. Yet in America companies still produce 30 gallons of regular (not diet) fizzy drinks per person per year. In many countries, particularly developing ones, consumption is on the rise.\n\n&ensp;&ensp;&ensp;&ensp;软饮料工业正处不尴不尬之际，马里昂•奈斯特对口可口可乐以及百事可乐的抨击颇具影响力。越来越少的美国人选择饮用含糖碳酸饮料----与十年前相比，2012年含糖碳酸饮料的生产减少了23%。人们甚至也失去了对膳食饮料的亲睐，因为消费者们对饮料中是否添加人工甜味剂提出了质疑。从某个角度来看，像奈斯特女士这样的健康倡导者似乎赢得了胜利。然而，美国软饮料公司每年生产的常规碳酸饮料（而非膳食饮料）人均多达30加仑。在许多国家，尤其是发展中国家，常规碳酸饮料的消费仍呈上涨趋势。\n\n\n&ensp;&ensp;&ensp;&ensp;Ms Nestle, a professor at New York University, is both heartened by recent progress and dissatisfied with it. That is no surprise. Her first book, “Food Politics” (2002), remains a bible for those who bewail the power of food companies. In her new book she attacks the industry’s most widely consumed, least healthy product. “Soda Politics”, she says, is a book “to inspire readers to action”. As a rallying cry, it is verbose. When readers learn on page 238 that she will pick up a particular subject in chapter 25, it is with no little dismay that they realise they are only on chapter 17. But what the author wants most is to craft a meticulous guide to the producers’ alleged transgressions, and how to stop them.\n\n&ensp;&ensp;&ensp;&ensp;对于最近取得的进展，奈斯特女士，这位纽约大学的教授颇受鼓舞，但并不满足于此。这也不足为奇。她的第一本书“粮食政策”依旧被那些哀叹食品企业权势的人们奉为经典。在新书中，奈斯特女士对软饮料行业消费最广，最有害健康的产品进行了抨击。《软饮料策略》这本书旨在激励人们采取行动，奈斯特说到。然而作为战斗口号，却显得颇为繁冗。读者们在第238页了解到奈斯特将在第25章讲述一个特别的主题，却意识到自己才看到第17章，但他们并没有因此而沮丧。作者最想做的是拟定一份详细的指南，指出生产商曾经的过失，并想方设法阻止他们的这种行为。\n\n\n&ensp;&ensp;&ensp;&ensp;Ms Nestle says she would have no quibbles with sweet fizzy drinks if they were sipped occasionally, as a treat. However, for millions of people in many countries, they are not. In Mexico companies sold 372 cans of fizzy drinks per person in 2012. About half of Americans do not drink them regularly, but those who do are disproportionately poor, less educated, male, Hispanic or black. Ten per cent of Americans down more than four cans a day.\n\n&ensp;&ensp;&ensp;&ensp;奈斯特说如果人们只是在吃饭招待的时候偶尔饮用加了甜味剂的碳酸饮料，她不会提出异议。但实际上许多国家，成千上万的人们都在喝这种饮料。2012年，仅墨西哥人均消费的碳酸饮料就高达372罐。大约一半的美国人不会经常性地饮用碳酸饮料，但是那些选择碳酸饮料的人多半是些穷困潦倒，未接受良好教育的西班牙或者黑人男性。百分之十的美国人平均每天要喝掉至少4罐碳酸饮料。\n\n\n&ensp;&ensp;&ensp;&ensp;Drinking a lot of sweet fizzy drinks is plainly unhealthy. Unlike a Big Mac, they have no nutritional value; nor do their calories satisfy hunger. One large study found that for each can added to a person’s daily diet, the risk of diabetes jumped by 22%. There are also links between sugar and heart disease, stroke and cancer. Drinking lots of sodas imposes clear costs on individuals, Ms Nestle argues, but it has a broader cost, too. American taxpayers subsidise corn production (and thereby corn syrup) and let the poor use government food vouchers to buy fizzy drinks. More important, taxpayers foot the health bill for those who develop chronic disease.\n\n&ensp;&ensp;&ensp;&ensp;很显然，过度饮用碳酸饮料对身体健康是有害的。与巨无霸不同的是，这些碳酸饮料毫无营养价值，它们产生的热量也无法抵抗饥饿。一项大型研究表明，如果在日常饮食中加入碳酸饮料，那么人们罹患糖尿病的风险就会增加22%。心脏病，中风以及癌症与过多的糖分摄入不无关系。奈斯特说，大量饮用碳酸饮料会增加个人开支，但实际上个人花费要远大于此。美国的纳税人为玉米生产做出了贡献（也就是为玉米糖浆的生产做出了贡献），同时，他们让穷人用政府提供的食品券来购买碳酸饮料。更重要的是，纳税人为那些罹患慢性疾病的人支付医疗帐单。\n\n\n&ensp;&ensp;&ensp;&ensp;Encouraging people to drink fewer fizzy drinks, however, is fiendishly difficult. Soda companies spend billions on marketing; it is a tribute to the admen that Coca-Cola is one of the world’s best-loved brands, despite selling what is essentially fattening sugar-water. (Think of Coca-Cola’s encouragements to “open happiness” and PepsiCo’s exuberant spokeswoman, Beyoncé Knowles.) Once people get used to consuming sugary drinks, they are loth to give them up. There is evidence suggesting that sugar is addictive—some laboratory animals prefer sugar to cocaine.\n\n&ensp;&ensp;&ensp;&ensp;然而，鼓励人们尽量少喝碳酸饮料却出奇的难。碳酸饮料企业在营销上花费巨资。尽管可口可乐售卖的实际上是令人增肥的糖水饮料，但可口可乐无疑是世界上最受消费者青睐的品牌之一。而这对于广告人而言，是件可喜可贺的事情。（想想可口可乐颇具鼓动性的广告语“开启幸福”，百事可乐活力四射的代言人碧昂丝•诺利斯。）人们一旦习惯了消费含糖饮料，便很难戒掉。有证据表明食糖是会上瘾的----与可卡因相比，实验室的动物们更喜欢食糖。\n\n\n&ensp;&ensp;&ensp;&ensp;Most interesting, fizzy-drink companies are skilled at swatting away attempts at regulation. Ms Nestle describes an extraordinarily broad team of allies. That includes obvious friends, such as employees, bottlers and distributors, as well as the restaurants, cinemas, shops and sports stadiums that sell their products. But the companies are also astute philanthropists. When Michael Bloomberg, then mayor of New York, tried to block the use of government vouchers to buy sodas in 2010, the congressional black caucus was among those to lobby against it. The caucus’s foundation has received money from both Coke and Pepsi. In 2011 Philadelphia was considering a soda tax. After the soda lobby offered a big donation to the city’s children’s hospital, the idea fizzled out.\n\n&ensp;&ensp;&ensp;&ensp;更有趣的是，碳酸饮料企业对规避规范化的尝试颇有一套。奈斯特将其描述为一个非比寻常的庞大联盟。很显然，这个联盟包括了这些企业的盟友们，比如雇员，瓶装工，经销商，那些出售他们商品的饭店，电影院，商店以及体育场。但这些碳酸饮料企业同时也是非常精明的慈善家。2010年，当时的纽约市市长迈克尔•布隆伯格试图阻止人们用政府代金券购买碳酸饮料，但却遭到了包括美国国会黑人同盟在内的多数人的反对。2011年，费城考虑是否要征收碳酸饮料税，但在碳酸饮料游说集团出资捐助了一家当地的儿童医院之后，这项提议未能实施。\n\n\n&ensp;&ensp;&ensp;&ensp;Coca-Cola and PepsiCo do have a few notable adversaries. Mr Bloomberg, a billionaire, remains their single biggest foe. It is telling that in two rare instances when a soda tax has been passed—in Berkeley, California and in Mexico—it was with the help of cash from Mr Bloomberg. Drinks companies must also reckon with a small army of health advocates, among which Ms Nestle is a major-general.\n\n&ensp;&ensp;&ensp;&ensp;可口可乐和百事可乐确实有一些颇为出名的对手。布隆伯格，这位亿万富翁是他们最大的对手。据说在两个颇为罕见的通过征收碳酸饮料税的例子中----一个是加利福尼亚的伯克利市，另一个是墨西哥----都是在布隆伯格的资金帮助下通过了碳酸饮料税法案。饮料公司还得去对付那些以奈斯特为首的健康军团。\n\n\n&ensp;&ensp;&ensp;&ensp;With the slow decline of soda in America, she and her allies are advancing. Coca-Cola and PepsiCo are peddling healthier drinks, such as bottled water. However, as they try to face down a long-term threat while maintaining near-term profits, they are still pushing their syrupy fare.\n\n&ensp;&ensp;&ensp;&ensp;随着美国人慢慢地拒绝碳酸饮料，奈斯特和她的盟友们正向成功一步步迈进。可口可乐和百事可乐正忙于推销更健康的饮料，如瓶装水。然而，他们仍旧努力推动碳酸饮料事业的发展，试图在维持短期利润的同时，努力克服长期以来的威胁。\n\n\n&ensp;&ensp;&ensp;&ensp;Ms Nestle is impatient. To the casual reader, her suggestions can seem extreme. She writes enthusiastically about adorning soda cans with warning labels, such as pictures of a diabetic’s foot ulcer. She suggests that parents should teach their children about fizzy drinks by gently boiling down a Coke or a Pepsi into sludge, which sounds rather fun, and asking them to calculate the precise length of grocery shelves bearing sodas, which sounds less so. This zeal threatens to overshadow her stronger points: fizzy drinks offer no nutritional benefit and impose clear costs—on individuals’ health and on society.\n\n&ensp;&ensp;&ensp;&ensp;奈斯特女士可没那么好的耐心。对于一般的读者，她给的建议似乎很极端。在书中她强烈建议碳酸饮料瓶上面必须贴有糖尿病患者脚部溃烂诸如此类的警示标志。她建议父母们在向孩子们介绍碳酸饮料时，将可口可乐和百事可乐说成是垃圾，这看上去颇为有趣，并要求孩子们去算算杂货店摆满碳酸饮料的货架究竟有多长，这听上去似乎没那么好笑了。这份热情让斯耐特关于碳酸饮料的观点显得不那么重要了：碳酸饮料没有任何营养价值，对个人的健康没有好处，而且还增加了社会的负担。\n","slug":"food-politics-in-America","published":1,"updated":"2018-08-13T06:23:24.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl22jwi7001frmuj6udhzjq0","content":"<h1 id=\"美国的食品政策\"><a href=\"#美国的食品政策\" class=\"headerlink\" title=\"美国的食品政策\"></a>美国的食品政策</h1><h2 id=\"How-to-wage-war-against-“Big-Soda”\"><a href=\"#How-to-wage-war-against-“Big-Soda”\" class=\"headerlink\" title=\"How to wage war against “Big Soda”\"></a>How to wage war against “Big Soda”</h2><h2 id=\"如何发动对“软饮料”的战争\"><a href=\"#如何发动对“软饮料”的战争\" class=\"headerlink\" title=\"如何发动对“软饮料”的战争\"></a>如何发动对“软饮料”的战争</h2><p>Soda Politics: Taking on Big Soda (and Winning). By Marion Nestle. Oxford University Press; 508 pages; $29.95 and £19.99.</p>\n<p>软饮料策略：对付软饮料（然后取得胜利）。作者马里昂•奈斯特。牛津大学出版社。508页。29.95美元，19.99英镑。</p>\n<p>&ensp;&ensp;&ensp;&ensp;MARION NESTLE’S heavyweight polemic against Coca-Cola and PepsiCo comes at an odd moment for the industry. Americans are drinking fewer sugary sodas—in 2012 production was 23% below what it had been a decade earlier. Even sales of diet drinks are losing their fizz, as consumers question the merits of artificial sweeteners. From one angle, it would seem that health advocates such as Ms Nestle have won. Yet in America companies still produce 30 gallons of regular (not diet) fizzy drinks per person per year. In many countries, particularly developing ones, consumption is on the rise.</p>\n<p>&ensp;&ensp;&ensp;&ensp;软饮料工业正处不尴不尬之际，马里昂•奈斯特对口可口可乐以及百事可乐的抨击颇具影响力。越来越少的美国人选择饮用含糖碳酸饮料—-与十年前相比，2012年含糖碳酸饮料的生产减少了23%。人们甚至也失去了对膳食饮料的亲睐，因为消费者们对饮料中是否添加人工甜味剂提出了质疑。从某个角度来看，像奈斯特女士这样的健康倡导者似乎赢得了胜利。然而，美国软饮料公司每年生产的常规碳酸饮料（而非膳食饮料）人均多达30加仑。在许多国家，尤其是发展中国家，常规碳酸饮料的消费仍呈上涨趋势。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Ms Nestle, a professor at New York University, is both heartened by recent progress and dissatisfied with it. That is no surprise. Her first book, “Food Politics” (2002), remains a bible for those who bewail the power of food companies. In her new book she attacks the industry’s most widely consumed, least healthy product. “Soda Politics”, she says, is a book “to inspire readers to action”. As a rallying cry, it is verbose. When readers learn on page 238 that she will pick up a particular subject in chapter 25, it is with no little dismay that they realise they are only on chapter 17. But what the author wants most is to craft a meticulous guide to the producers’ alleged transgressions, and how to stop them.</p>\n<p>&ensp;&ensp;&ensp;&ensp;对于最近取得的进展，奈斯特女士，这位纽约大学的教授颇受鼓舞，但并不满足于此。这也不足为奇。她的第一本书“粮食政策”依旧被那些哀叹食品企业权势的人们奉为经典。在新书中，奈斯特女士对软饮料行业消费最广，最有害健康的产品进行了抨击。《软饮料策略》这本书旨在激励人们采取行动，奈斯特说到。然而作为战斗口号，却显得颇为繁冗。读者们在第238页了解到奈斯特将在第25章讲述一个特别的主题，却意识到自己才看到第17章，但他们并没有因此而沮丧。作者最想做的是拟定一份详细的指南，指出生产商曾经的过失，并想方设法阻止他们的这种行为。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Ms Nestle says she would have no quibbles with sweet fizzy drinks if they were sipped occasionally, as a treat. However, for millions of people in many countries, they are not. In Mexico companies sold 372 cans of fizzy drinks per person in 2012. About half of Americans do not drink them regularly, but those who do are disproportionately poor, less educated, male, Hispanic or black. Ten per cent of Americans down more than four cans a day.</p>\n<p>&ensp;&ensp;&ensp;&ensp;奈斯特说如果人们只是在吃饭招待的时候偶尔饮用加了甜味剂的碳酸饮料，她不会提出异议。但实际上许多国家，成千上万的人们都在喝这种饮料。2012年，仅墨西哥人均消费的碳酸饮料就高达372罐。大约一半的美国人不会经常性地饮用碳酸饮料，但是那些选择碳酸饮料的人多半是些穷困潦倒，未接受良好教育的西班牙或者黑人男性。百分之十的美国人平均每天要喝掉至少4罐碳酸饮料。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Drinking a lot of sweet fizzy drinks is plainly unhealthy. Unlike a Big Mac, they have no nutritional value; nor do their calories satisfy hunger. One large study found that for each can added to a person’s daily diet, the risk of diabetes jumped by 22%. There are also links between sugar and heart disease, stroke and cancer. Drinking lots of sodas imposes clear costs on individuals, Ms Nestle argues, but it has a broader cost, too. American taxpayers subsidise corn production (and thereby corn syrup) and let the poor use government food vouchers to buy fizzy drinks. More important, taxpayers foot the health bill for those who develop chronic disease.</p>\n<p>&ensp;&ensp;&ensp;&ensp;很显然，过度饮用碳酸饮料对身体健康是有害的。与巨无霸不同的是，这些碳酸饮料毫无营养价值，它们产生的热量也无法抵抗饥饿。一项大型研究表明，如果在日常饮食中加入碳酸饮料，那么人们罹患糖尿病的风险就会增加22%。心脏病，中风以及癌症与过多的糖分摄入不无关系。奈斯特说，大量饮用碳酸饮料会增加个人开支，但实际上个人花费要远大于此。美国的纳税人为玉米生产做出了贡献（也就是为玉米糖浆的生产做出了贡献），同时，他们让穷人用政府提供的食品券来购买碳酸饮料。更重要的是，纳税人为那些罹患慢性疾病的人支付医疗帐单。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Encouraging people to drink fewer fizzy drinks, however, is fiendishly difficult. Soda companies spend billions on marketing; it is a tribute to the admen that Coca-Cola is one of the world’s best-loved brands, despite selling what is essentially fattening sugar-water. (Think of Coca-Cola’s encouragements to “open happiness” and PepsiCo’s exuberant spokeswoman, Beyoncé Knowles.) Once people get used to consuming sugary drinks, they are loth to give them up. There is evidence suggesting that sugar is addictive—some laboratory animals prefer sugar to cocaine.</p>\n<p>&ensp;&ensp;&ensp;&ensp;然而，鼓励人们尽量少喝碳酸饮料却出奇的难。碳酸饮料企业在营销上花费巨资。尽管可口可乐售卖的实际上是令人增肥的糖水饮料，但可口可乐无疑是世界上最受消费者青睐的品牌之一。而这对于广告人而言，是件可喜可贺的事情。（想想可口可乐颇具鼓动性的广告语“开启幸福”，百事可乐活力四射的代言人碧昂丝•诺利斯。）人们一旦习惯了消费含糖饮料，便很难戒掉。有证据表明食糖是会上瘾的—-与可卡因相比，实验室的动物们更喜欢食糖。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Most interesting, fizzy-drink companies are skilled at swatting away attempts at regulation. Ms Nestle describes an extraordinarily broad team of allies. That includes obvious friends, such as employees, bottlers and distributors, as well as the restaurants, cinemas, shops and sports stadiums that sell their products. But the companies are also astute philanthropists. When Michael Bloomberg, then mayor of New York, tried to block the use of government vouchers to buy sodas in 2010, the congressional black caucus was among those to lobby against it. The caucus’s foundation has received money from both Coke and Pepsi. In 2011 Philadelphia was considering a soda tax. After the soda lobby offered a big donation to the city’s children’s hospital, the idea fizzled out.</p>\n<p>&ensp;&ensp;&ensp;&ensp;更有趣的是，碳酸饮料企业对规避规范化的尝试颇有一套。奈斯特将其描述为一个非比寻常的庞大联盟。很显然，这个联盟包括了这些企业的盟友们，比如雇员，瓶装工，经销商，那些出售他们商品的饭店，电影院，商店以及体育场。但这些碳酸饮料企业同时也是非常精明的慈善家。2010年，当时的纽约市市长迈克尔•布隆伯格试图阻止人们用政府代金券购买碳酸饮料，但却遭到了包括美国国会黑人同盟在内的多数人的反对。2011年，费城考虑是否要征收碳酸饮料税，但在碳酸饮料游说集团出资捐助了一家当地的儿童医院之后，这项提议未能实施。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Coca-Cola and PepsiCo do have a few notable adversaries. Mr Bloomberg, a billionaire, remains their single biggest foe. It is telling that in two rare instances when a soda tax has been passed—in Berkeley, California and in Mexico—it was with the help of cash from Mr Bloomberg. Drinks companies must also reckon with a small army of health advocates, among which Ms Nestle is a major-general.</p>\n<p>&ensp;&ensp;&ensp;&ensp;可口可乐和百事可乐确实有一些颇为出名的对手。布隆伯格，这位亿万富翁是他们最大的对手。据说在两个颇为罕见的通过征收碳酸饮料税的例子中—-一个是加利福尼亚的伯克利市，另一个是墨西哥—-都是在布隆伯格的资金帮助下通过了碳酸饮料税法案。饮料公司还得去对付那些以奈斯特为首的健康军团。</p>\n<p>&ensp;&ensp;&ensp;&ensp;With the slow decline of soda in America, she and her allies are advancing. Coca-Cola and PepsiCo are peddling healthier drinks, such as bottled water. However, as they try to face down a long-term threat while maintaining near-term profits, they are still pushing their syrupy fare.</p>\n<p>&ensp;&ensp;&ensp;&ensp;随着美国人慢慢地拒绝碳酸饮料，奈斯特和她的盟友们正向成功一步步迈进。可口可乐和百事可乐正忙于推销更健康的饮料，如瓶装水。然而，他们仍旧努力推动碳酸饮料事业的发展，试图在维持短期利润的同时，努力克服长期以来的威胁。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Ms Nestle is impatient. To the casual reader, her suggestions can seem extreme. She writes enthusiastically about adorning soda cans with warning labels, such as pictures of a diabetic’s foot ulcer. She suggests that parents should teach their children about fizzy drinks by gently boiling down a Coke or a Pepsi into sludge, which sounds rather fun, and asking them to calculate the precise length of grocery shelves bearing sodas, which sounds less so. This zeal threatens to overshadow her stronger points: fizzy drinks offer no nutritional benefit and impose clear costs—on individuals’ health and on society.</p>\n<p>&ensp;&ensp;&ensp;&ensp;奈斯特女士可没那么好的耐心。对于一般的读者，她给的建议似乎很极端。在书中她强烈建议碳酸饮料瓶上面必须贴有糖尿病患者脚部溃烂诸如此类的警示标志。她建议父母们在向孩子们介绍碳酸饮料时，将可口可乐和百事可乐说成是垃圾，这看上去颇为有趣，并要求孩子们去算算杂货店摆满碳酸饮料的货架究竟有多长，这听上去似乎没那么好笑了。这份热情让斯耐特关于碳酸饮料的观点显得不那么重要了：碳酸饮料没有任何营养价值，对个人的健康没有好处，而且还增加了社会的负担。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"美国的食品政策\"><a href=\"#美国的食品政策\" class=\"headerlink\" title=\"美国的食品政策\"></a>美国的食品政策</h1><h2 id=\"How-to-wage-war-against-“Big-Soda”\"><a href=\"#How-to-wage-war-against-“Big-Soda”\" class=\"headerlink\" title=\"How to wage war against “Big Soda”\"></a>How to wage war against “Big Soda”</h2><h2 id=\"如何发动对“软饮料”的战争\"><a href=\"#如何发动对“软饮料”的战争\" class=\"headerlink\" title=\"如何发动对“软饮料”的战争\"></a>如何发动对“软饮料”的战争</h2><p>Soda Politics: Taking on Big Soda (and Winning). By Marion Nestle. Oxford University Press; 508 pages; $29.95 and £19.99.</p>\n<p>软饮料策略：对付软饮料（然后取得胜利）。作者马里昂•奈斯特。牛津大学出版社。508页。29.95美元，19.99英镑。</p>\n<p>&ensp;&ensp;&ensp;&ensp;MARION NESTLE’S heavyweight polemic against Coca-Cola and PepsiCo comes at an odd moment for the industry. Americans are drinking fewer sugary sodas—in 2012 production was 23% below what it had been a decade earlier. Even sales of diet drinks are losing their fizz, as consumers question the merits of artificial sweeteners. From one angle, it would seem that health advocates such as Ms Nestle have won. Yet in America companies still produce 30 gallons of regular (not diet) fizzy drinks per person per year. In many countries, particularly developing ones, consumption is on the rise.</p>\n<p>&ensp;&ensp;&ensp;&ensp;软饮料工业正处不尴不尬之际，马里昂•奈斯特对口可口可乐以及百事可乐的抨击颇具影响力。越来越少的美国人选择饮用含糖碳酸饮料—-与十年前相比，2012年含糖碳酸饮料的生产减少了23%。人们甚至也失去了对膳食饮料的亲睐，因为消费者们对饮料中是否添加人工甜味剂提出了质疑。从某个角度来看，像奈斯特女士这样的健康倡导者似乎赢得了胜利。然而，美国软饮料公司每年生产的常规碳酸饮料（而非膳食饮料）人均多达30加仑。在许多国家，尤其是发展中国家，常规碳酸饮料的消费仍呈上涨趋势。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Ms Nestle, a professor at New York University, is both heartened by recent progress and dissatisfied with it. That is no surprise. Her first book, “Food Politics” (2002), remains a bible for those who bewail the power of food companies. In her new book she attacks the industry’s most widely consumed, least healthy product. “Soda Politics”, she says, is a book “to inspire readers to action”. As a rallying cry, it is verbose. When readers learn on page 238 that she will pick up a particular subject in chapter 25, it is with no little dismay that they realise they are only on chapter 17. But what the author wants most is to craft a meticulous guide to the producers’ alleged transgressions, and how to stop them.</p>\n<p>&ensp;&ensp;&ensp;&ensp;对于最近取得的进展，奈斯特女士，这位纽约大学的教授颇受鼓舞，但并不满足于此。这也不足为奇。她的第一本书“粮食政策”依旧被那些哀叹食品企业权势的人们奉为经典。在新书中，奈斯特女士对软饮料行业消费最广，最有害健康的产品进行了抨击。《软饮料策略》这本书旨在激励人们采取行动，奈斯特说到。然而作为战斗口号，却显得颇为繁冗。读者们在第238页了解到奈斯特将在第25章讲述一个特别的主题，却意识到自己才看到第17章，但他们并没有因此而沮丧。作者最想做的是拟定一份详细的指南，指出生产商曾经的过失，并想方设法阻止他们的这种行为。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Ms Nestle says she would have no quibbles with sweet fizzy drinks if they were sipped occasionally, as a treat. However, for millions of people in many countries, they are not. In Mexico companies sold 372 cans of fizzy drinks per person in 2012. About half of Americans do not drink them regularly, but those who do are disproportionately poor, less educated, male, Hispanic or black. Ten per cent of Americans down more than four cans a day.</p>\n<p>&ensp;&ensp;&ensp;&ensp;奈斯特说如果人们只是在吃饭招待的时候偶尔饮用加了甜味剂的碳酸饮料，她不会提出异议。但实际上许多国家，成千上万的人们都在喝这种饮料。2012年，仅墨西哥人均消费的碳酸饮料就高达372罐。大约一半的美国人不会经常性地饮用碳酸饮料，但是那些选择碳酸饮料的人多半是些穷困潦倒，未接受良好教育的西班牙或者黑人男性。百分之十的美国人平均每天要喝掉至少4罐碳酸饮料。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Drinking a lot of sweet fizzy drinks is plainly unhealthy. Unlike a Big Mac, they have no nutritional value; nor do their calories satisfy hunger. One large study found that for each can added to a person’s daily diet, the risk of diabetes jumped by 22%. There are also links between sugar and heart disease, stroke and cancer. Drinking lots of sodas imposes clear costs on individuals, Ms Nestle argues, but it has a broader cost, too. American taxpayers subsidise corn production (and thereby corn syrup) and let the poor use government food vouchers to buy fizzy drinks. More important, taxpayers foot the health bill for those who develop chronic disease.</p>\n<p>&ensp;&ensp;&ensp;&ensp;很显然，过度饮用碳酸饮料对身体健康是有害的。与巨无霸不同的是，这些碳酸饮料毫无营养价值，它们产生的热量也无法抵抗饥饿。一项大型研究表明，如果在日常饮食中加入碳酸饮料，那么人们罹患糖尿病的风险就会增加22%。心脏病，中风以及癌症与过多的糖分摄入不无关系。奈斯特说，大量饮用碳酸饮料会增加个人开支，但实际上个人花费要远大于此。美国的纳税人为玉米生产做出了贡献（也就是为玉米糖浆的生产做出了贡献），同时，他们让穷人用政府提供的食品券来购买碳酸饮料。更重要的是，纳税人为那些罹患慢性疾病的人支付医疗帐单。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Encouraging people to drink fewer fizzy drinks, however, is fiendishly difficult. Soda companies spend billions on marketing; it is a tribute to the admen that Coca-Cola is one of the world’s best-loved brands, despite selling what is essentially fattening sugar-water. (Think of Coca-Cola’s encouragements to “open happiness” and PepsiCo’s exuberant spokeswoman, Beyoncé Knowles.) Once people get used to consuming sugary drinks, they are loth to give them up. There is evidence suggesting that sugar is addictive—some laboratory animals prefer sugar to cocaine.</p>\n<p>&ensp;&ensp;&ensp;&ensp;然而，鼓励人们尽量少喝碳酸饮料却出奇的难。碳酸饮料企业在营销上花费巨资。尽管可口可乐售卖的实际上是令人增肥的糖水饮料，但可口可乐无疑是世界上最受消费者青睐的品牌之一。而这对于广告人而言，是件可喜可贺的事情。（想想可口可乐颇具鼓动性的广告语“开启幸福”，百事可乐活力四射的代言人碧昂丝•诺利斯。）人们一旦习惯了消费含糖饮料，便很难戒掉。有证据表明食糖是会上瘾的—-与可卡因相比，实验室的动物们更喜欢食糖。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Most interesting, fizzy-drink companies are skilled at swatting away attempts at regulation. Ms Nestle describes an extraordinarily broad team of allies. That includes obvious friends, such as employees, bottlers and distributors, as well as the restaurants, cinemas, shops and sports stadiums that sell their products. But the companies are also astute philanthropists. When Michael Bloomberg, then mayor of New York, tried to block the use of government vouchers to buy sodas in 2010, the congressional black caucus was among those to lobby against it. The caucus’s foundation has received money from both Coke and Pepsi. In 2011 Philadelphia was considering a soda tax. After the soda lobby offered a big donation to the city’s children’s hospital, the idea fizzled out.</p>\n<p>&ensp;&ensp;&ensp;&ensp;更有趣的是，碳酸饮料企业对规避规范化的尝试颇有一套。奈斯特将其描述为一个非比寻常的庞大联盟。很显然，这个联盟包括了这些企业的盟友们，比如雇员，瓶装工，经销商，那些出售他们商品的饭店，电影院，商店以及体育场。但这些碳酸饮料企业同时也是非常精明的慈善家。2010年，当时的纽约市市长迈克尔•布隆伯格试图阻止人们用政府代金券购买碳酸饮料，但却遭到了包括美国国会黑人同盟在内的多数人的反对。2011年，费城考虑是否要征收碳酸饮料税，但在碳酸饮料游说集团出资捐助了一家当地的儿童医院之后，这项提议未能实施。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Coca-Cola and PepsiCo do have a few notable adversaries. Mr Bloomberg, a billionaire, remains their single biggest foe. It is telling that in two rare instances when a soda tax has been passed—in Berkeley, California and in Mexico—it was with the help of cash from Mr Bloomberg. Drinks companies must also reckon with a small army of health advocates, among which Ms Nestle is a major-general.</p>\n<p>&ensp;&ensp;&ensp;&ensp;可口可乐和百事可乐确实有一些颇为出名的对手。布隆伯格，这位亿万富翁是他们最大的对手。据说在两个颇为罕见的通过征收碳酸饮料税的例子中—-一个是加利福尼亚的伯克利市，另一个是墨西哥—-都是在布隆伯格的资金帮助下通过了碳酸饮料税法案。饮料公司还得去对付那些以奈斯特为首的健康军团。</p>\n<p>&ensp;&ensp;&ensp;&ensp;With the slow decline of soda in America, she and her allies are advancing. Coca-Cola and PepsiCo are peddling healthier drinks, such as bottled water. However, as they try to face down a long-term threat while maintaining near-term profits, they are still pushing their syrupy fare.</p>\n<p>&ensp;&ensp;&ensp;&ensp;随着美国人慢慢地拒绝碳酸饮料，奈斯特和她的盟友们正向成功一步步迈进。可口可乐和百事可乐正忙于推销更健康的饮料，如瓶装水。然而，他们仍旧努力推动碳酸饮料事业的发展，试图在维持短期利润的同时，努力克服长期以来的威胁。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Ms Nestle is impatient. To the casual reader, her suggestions can seem extreme. She writes enthusiastically about adorning soda cans with warning labels, such as pictures of a diabetic’s foot ulcer. She suggests that parents should teach their children about fizzy drinks by gently boiling down a Coke or a Pepsi into sludge, which sounds rather fun, and asking them to calculate the precise length of grocery shelves bearing sodas, which sounds less so. This zeal threatens to overshadow her stronger points: fizzy drinks offer no nutritional benefit and impose clear costs—on individuals’ health and on society.</p>\n<p>&ensp;&ensp;&ensp;&ensp;奈斯特女士可没那么好的耐心。对于一般的读者，她给的建议似乎很极端。在书中她强烈建议碳酸饮料瓶上面必须贴有糖尿病患者脚部溃烂诸如此类的警示标志。她建议父母们在向孩子们介绍碳酸饮料时，将可口可乐和百事可乐说成是垃圾，这看上去颇为有趣，并要求孩子们去算算杂货店摆满碳酸饮料的货架究竟有多长，这听上去似乎没那么好笑了。这份热情让斯耐特关于碳酸饮料的观点显得不那么重要了：碳酸饮料没有任何营养价值，对个人的健康没有好处，而且还增加了社会的负担。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjl22jwhm0000rmujkaoaj1pk","category_id":"cjl22jwhq0002rmujya8a31de","_id":"cjl22jwhw000crmuj34tp6n2p"},{"post_id":"cjl22jwhu0009rmuja3jro71b","category_id":"cjl22jwhq0002rmujya8a31de","_id":"cjl22jwhz000irmujz5jpw1et"},{"post_id":"cjl22jwhp0001rmujf21lx0cz","category_id":"cjl22jwhq0002rmujya8a31de","_id":"cjl22jwi0000nrmujl378481r"},{"post_id":"cjl22jwhv000armujf8jbtzw5","category_id":"cjl22jwhq0002rmujya8a31de","_id":"cjl22jwi1000qrmujz9c8pby1"},{"post_id":"cjl22jwhw000frmujyyqaj9lw","category_id":"cjl22jwhq0002rmujya8a31de","_id":"cjl22jwi2000vrmuj2n8psqe5"},{"post_id":"cjl22jwhr0004rmujao0rcmwa","category_id":"cjl22jwhq0002rmujya8a31de","_id":"cjl22jwi3000yrmujgon3jpyq"},{"post_id":"cjl22jwhy000hrmujnr5qvdon","category_id":"cjl22jwhq0002rmujya8a31de","_id":"cjl22jwi40012rmujdt6nqpm0"},{"post_id":"cjl22jwhz000mrmujxq7hbru7","category_id":"cjl22jwhq0002rmujya8a31de","_id":"cjl22jwi40016rmujzkdkpip2"},{"post_id":"cjl22jwhs0005rmujjb4p2imu","category_id":"cjl22jwhz000jrmujf2bhif0k","_id":"cjl22jwi60019rmujhfujqbwf"},{"post_id":"cjl22jwi0000prmujlb4p5tqb","category_id":"cjl22jwhq0002rmujya8a31de","_id":"cjl22jwi6001drmuj6raqfr87"},{"post_id":"cjl22jwht0006rmujfvzlfqpc","category_id":"cjl22jwhz000jrmujf2bhif0k","_id":"cjl22jwi7001grmuj26pcum2x"},{"post_id":"cjl22jwi2000xrmujp961mjls","category_id":"cjl22jwhz000jrmujf2bhif0k","_id":"cjl22jwi8001irmujh6t82173"},{"post_id":"cjl22jwi30011rmujusixx9vp","category_id":"cjl22jwhz000jrmujf2bhif0k","_id":"cjl22jwi8001krmuj6ccex7zc"},{"post_id":"cjl22jwi40015rmujfapvv4vm","category_id":"cjl22jwhz000jrmujf2bhif0k","_id":"cjl22jwi8001mrmuj4mxj1w72"},{"post_id":"cjl22jwi1000urmujkrn8ozeu","category_id":"cjl22jwi3000zrmuj0rjgm8ni","_id":"cjl22jwi8001ormujk7pd1d93"},{"post_id":"cjl22jwi50018rmujx4bywegy","category_id":"cjl22jwhz000jrmujf2bhif0k","_id":"cjl22jwi8001qrmujzd0kn59m"},{"post_id":"cjl22jwi6001crmuj28926dhb","category_id":"cjl22jwhz000jrmujf2bhif0k","_id":"cjl22jwi8001srmujujr1ibzf"},{"post_id":"cjl22jwi7001frmuj6udhzjq0","category_id":"cjl22jwi8001jrmujja7h7ya7","_id":"cjl22jwi9001trmujt5w5ofh1"}],"PostTag":[{"post_id":"cjl22jwhu0009rmuja3jro71b","tag_id":"cjl22jwhr0003rmujfkjbkqya","_id":"cjl22jwhw000ermujef94xz1e"},{"post_id":"cjl22jwhu0009rmuja3jro71b","tag_id":"cjl22jwht0008rmuj6pab2q26","_id":"cjl22jwhy000grmujda6c969f"},{"post_id":"cjl22jwhm0000rmujkaoaj1pk","tag_id":"cjl22jwhr0003rmujfkjbkqya","_id":"cjl22jwhz000lrmuj7hchnkcz"},{"post_id":"cjl22jwhm0000rmujkaoaj1pk","tag_id":"cjl22jwht0008rmuj6pab2q26","_id":"cjl22jwi0000ormuj7i9qkkj6"},{"post_id":"cjl22jwhw000frmujyyqaj9lw","tag_id":"cjl22jwhr0003rmujfkjbkqya","_id":"cjl22jwi1000srmujepdalpoc"},{"post_id":"cjl22jwhp0001rmujf21lx0cz","tag_id":"cjl22jwhw000drmujj306mt8e","_id":"cjl22jwi2000wrmujdu1zkrhr"},{"post_id":"cjl22jwhz000mrmujxq7hbru7","tag_id":"cjl22jwhr0003rmujfkjbkqya","_id":"cjl22jwi30010rmuj8weqxkyq"},{"post_id":"cjl22jwhz000mrmujxq7hbru7","tag_id":"cjl22jwht0008rmuj6pab2q26","_id":"cjl22jwi40014rmujw0ja6n2r"},{"post_id":"cjl22jwhr0004rmujao0rcmwa","tag_id":"cjl22jwhz000krmujgd2pz9ke","_id":"cjl22jwi50017rmuj8197umym"},{"post_id":"cjl22jwhr0004rmujao0rcmwa","tag_id":"cjl22jwi1000trmujq4ybrz22","_id":"cjl22jwi6001brmujzy9ydhzq"},{"post_id":"cjl22jwhs0005rmujjb4p2imu","tag_id":"cjl22jwi40013rmujlkjmbzbh","_id":"cjl22jwi7001ermuju2m70qij"},{"post_id":"cjl22jwht0006rmujfvzlfqpc","tag_id":"cjl22jwi6001armujsn33qihx","_id":"cjl22jwi8001nrmuj86tj1b4e"},{"post_id":"cjl22jwht0006rmujfvzlfqpc","tag_id":"cjl22jwi7001hrmujzz8zta11","_id":"cjl22jwi8001prmujhvlok0hl"},{"post_id":"cjl22jwhv000armujf8jbtzw5","tag_id":"cjl22jwhr0003rmujfkjbkqya","_id":"cjl22jwi9001vrmujkmb649ck"},{"post_id":"cjl22jwhv000armujf8jbtzw5","tag_id":"cjl22jwi8001lrmujvhu57ojh","_id":"cjl22jwi9001wrmujhfjdbsoi"},{"post_id":"cjl22jwhv000armujf8jbtzw5","tag_id":"cjl22jwi8001rrmujkx4euq4y","_id":"cjl22jwi9001yrmujbbe7r5m4"},{"post_id":"cjl22jwhy000hrmujnr5qvdon","tag_id":"cjl22jwhr0003rmujfkjbkqya","_id":"cjl22jwi9001zrmujgy5uw5lh"},{"post_id":"cjl22jwhy000hrmujnr5qvdon","tag_id":"cjl22jwi1000trmujq4ybrz22","_id":"cjl22jwia0021rmujc55hf5l6"},{"post_id":"cjl22jwhy000hrmujnr5qvdon","tag_id":"cjl22jwht0008rmuj6pab2q26","_id":"cjl22jwia0022rmujnyn9lhdb"},{"post_id":"cjl22jwi0000prmujlb4p5tqb","tag_id":"cjl22jwhr0003rmujfkjbkqya","_id":"cjl22jwia0024rmujz4k1m5ju"},{"post_id":"cjl22jwi0000prmujlb4p5tqb","tag_id":"cjl22jwi1000trmujq4ybrz22","_id":"cjl22jwia0025rmuj6nvfgnzc"},{"post_id":"cjl22jwi1000urmujkrn8ozeu","tag_id":"cjl22jwi90020rmujcfq6n7p3","_id":"cjl22jwia0027rmujjb6fbihu"},{"post_id":"cjl22jwi2000xrmujp961mjls","tag_id":"cjl22jwia0023rmujjyqpvwo9","_id":"cjl22jwib0029rmujpg6kvxc1"},{"post_id":"cjl22jwi2000xrmujp961mjls","tag_id":"cjl22jwia0026rmujtej1x1vq","_id":"cjl22jwib002armuj11glgeyp"},{"post_id":"cjl22jwi30011rmujusixx9vp","tag_id":"cjl22jwi90020rmujcfq6n7p3","_id":"cjl22jwib002crmujnbabzee1"},{"post_id":"cjl22jwi40015rmujfapvv4vm","tag_id":"cjl22jwi90020rmujcfq6n7p3","_id":"cjl22jwic002frmujmmfn66wd"},{"post_id":"cjl22jwi40015rmujfapvv4vm","tag_id":"cjl22jwib002drmujbfa933un","_id":"cjl22jwic002grmuj4kvr09tf"},{"post_id":"cjl22jwi50018rmujx4bywegy","tag_id":"cjl22jwia0023rmujjyqpvwo9","_id":"cjl22jwic002jrmujnc88hudw"},{"post_id":"cjl22jwi50018rmujx4bywegy","tag_id":"cjl22jwic002hrmujixb98x5i","_id":"cjl22jwic002krmujy9erqi8x"},{"post_id":"cjl22jwi6001crmuj28926dhb","tag_id":"cjl22jwic002irmujgp0xqr2u","_id":"cjl22jwic002mrmujj3ju9lup"},{"post_id":"cjl22jwi7001frmuj6udhzjq0","tag_id":"cjl22jwic002lrmujll30c9gr","_id":"cjl22jwic002nrmujc7dftog6"}],"Tag":[{"name":"android","_id":"cjl22jwhr0003rmujfkjbkqya"},{"name":"contacts","_id":"cjl22jwht0008rmuj6pab2q26"},{"name":"android2.3.1","_id":"cjl22jwhw000drmujj306mt8e"},{"name":"gradle","_id":"cjl22jwhz000krmujgd2pz9ke"},{"name":"面试","_id":"cjl22jwi1000trmujq4ybrz22"},{"name":"压缩","_id":"cjl22jwi40013rmujlkjmbzbh"},{"name":"chrome","_id":"cjl22jwi6001armujsn33qihx"},{"name":"chrome-plugin","_id":"cjl22jwi7001hrmujzz8zta11"},{"name":"cm","_id":"cjl22jwi8001lrmujvhu57ojh"},{"name":"lineageos","_id":"cjl22jwi8001rrmujkx4euq4y"},{"name":"tools","_id":"cjl22jwi90020rmujcfq6n7p3"},{"name":"hexo","_id":"cjl22jwia0023rmujjyqpvwo9"},{"name":"blog","_id":"cjl22jwia0026rmujtej1x1vq"},{"name":"keys","_id":"cjl22jwib002drmujbfa933un"},{"name":"3-hexo","_id":"cjl22jwic002hrmujixb98x5i"},{"name":"正则表达式","_id":"cjl22jwic002irmujgp0xqr2u"},{"name":"english","_id":"cjl22jwic002lrmujll30c9gr"}]}}