{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/bg.jpg","path":"img/bg.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","path":"js/jquery.autocomplete.min.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"fc82d21b7d4e8354f7e4f49dac9f3df769f79d82","modified":1534082372652},{"_id":"source/CNAME","hash":"c56f07d65fc8c6c7d83fc8019100cf09216768e6","modified":1533089251734},{"_id":"themes/3-hexo/.gitignore","hash":"5e85fe97e87211619c1db29fd3f3b0dbf16be4a7","modified":1534095722282},{"_id":"themes/3-hexo/README.md","hash":"794c03ffd0399d55d11b9dce610f8419c7106078","modified":1534095722282},{"_id":"themes/3-hexo/_config.yml","hash":"b5f684ea0d39b6f22d26eae0366fafc393ab81d1","modified":1534096337606},{"_id":"source/_posts/.DS_Store","hash":"ffca5efacd278752a3fb2721f701ed065998045d","modified":1534082372652},{"_id":"themes/3-hexo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1534095722278},{"_id":"themes/3-hexo/.git/config","hash":"01b66c1979dcfc0ab454bc7e595c4b0c367aae6f","modified":1534095722278},{"_id":"themes/3-hexo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1534095716674},{"_id":"themes/3-hexo/.git/index","hash":"111d4056658a103510a92e8ae6918bcb0aca166c","modified":1534095722286},{"_id":"themes/3-hexo/.git/packed-refs","hash":"8a7594a5b042c02227f3cd5bedcf675dfa986d33","modified":1534095722274},{"_id":"themes/3-hexo/layout/index.ejs","hash":"61842de9bda3f9a354d1f88d4289dfd0968320dd","modified":1534095722282},{"_id":"themes/3-hexo/layout/indexs.md","hash":"e98b27005c0fb0d7618ae3815654ac33f8c02313","modified":1534095722282},{"_id":"themes/3-hexo/layout/post.ejs","hash":"810f046277fc49f523a72d1552eab1e39d3c299c","modified":1534095722282},{"_id":"source/_posts/Android/Contacts源码结构分析.md","hash":"5349a9c945baa9d2340c19ed1d49128812f1d7df","modified":1534160516326},{"_id":"source/_posts/Android/为Nexus编译LineageOS.md","hash":"d8b1d9469a1e594fc4bdafa2dc1230b3c5dc77bd","modified":1533698824534},{"_id":"source/_posts/Android/合并重复联系人.md","hash":"00cdf3f900e72e148a726733d9faf15b620cadb1","modified":1534141891140},{"_id":"source/_posts/Android/多语言下，String子串可点击并实现跳转.md","hash":"f4e3796820e08a8b6c989ceba73c426cfd5d8dff","modified":1533089251734},{"_id":"source/_posts/Android/开机导入Sim卡联系人.md","hash":"c3edd67a95a82e872bb7948969053a3a3c36277d","modified":1533089251734},{"_id":"source/_posts/Android/联系人号码模糊查询.md","hash":"5ef8487d6dc813d42c261e7fb888515973e5aa53","modified":1533089251734},{"_id":"source/_posts/Android/跨进程通讯的4种方式.md","hash":"a30f0c281b8a4f4b7b196bae86ebda0a1fd1096a","modified":1533089251734},{"_id":"source/_posts/init/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1534082372652},{"_id":"source/_posts/init/blog-init.md","hash":"293266da5e64127a918ca6d7359e6ddffee356c1","modified":1534082372652},{"_id":"source/_posts/工具/.DS_Store","hash":"45b448be483388e2cc349366e249a2d531fbcea6","modified":1534082372652},{"_id":"source/_posts/工具/Hexo-GitHub-Pages搭建属于自己的blog.md","hash":"e18b3d9f28cb958ced95d98d70ddbb23c62955ec","modified":1533089251734},{"_id":"source/_posts/工具/工具软件-插件.md","hash":"df5f2be58924eca901f3a8fcaad5c12715fba5cd","modified":1533089251734},{"_id":"source/_posts/工具/工具软件keys.md","hash":"006adf560f28e1739a1a19369895eb08a8c3f8ac","modified":1533089251734},{"_id":"source/_posts/工具/快捷键.md","hash":"870265d63adbe730deb5cf381ebb69be9fc42252","modified":1533089251734},{"_id":"source/_posts/英语/Food-politics-in-America.md","hash":"3605c34cb6915cded4566fc8746a8415542ffedc","modified":1534141404200},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"f0d1fad4d14841cc3dd3b00c37e66ca9d2548020","modified":1533089251738},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1534095722282},{"_id":"themes/3-hexo/source/img/bg.jpg","hash":"331f382a62f46ac8819c3b408b21af4f92118cf7","modified":1533089251738},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1534095722282},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1534095722282},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"f0d1fad4d14841cc3dd3b00c37e66ca9d2548020","modified":1533089251738},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1534095722286},{"_id":"themes/3-hexo/source/js/script.js","hash":"311beeda0e450fc34943616c02da54e2229700a5","modified":1534095722286},{"_id":"themes/3-hexo/source/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1534095722286},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1534095722282},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"83e5569a58663f9322dda64d263a80153790ad68","modified":1534095722282},{"_id":"themes/3-hexo/source/css/style.styl","hash":"c7285882370f522c3bb17055cdf615cf92f48cd0","modified":1534095722282},{"_id":"themes/3-hexo/.git/hooks/applypatch-msg.sample","hash":"86b9655a9ebbde13ac8dd5795eb4d5b539edab0f","modified":1534095716670},{"_id":"themes/3-hexo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1534095716670},{"_id":"themes/3-hexo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1534095716670},{"_id":"themes/3-hexo/.git/hooks/pre-applypatch.sample","hash":"42fa41564917b44183a50c4d94bb03e1768ddad8","modified":1534095716670},{"_id":"themes/3-hexo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1534095716670},{"_id":"themes/3-hexo/.git/hooks/pre-push.sample","hash":"b4ad74c989616b7395dc6c9fce9871bb1e86dfb5","modified":1534095716670},{"_id":"themes/3-hexo/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1534095716674},{"_id":"themes/3-hexo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1534095716674},{"_id":"themes/3-hexo/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1534095716670},{"_id":"themes/3-hexo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1534095716674},{"_id":"themes/3-hexo/.git/logs/HEAD","hash":"79db9a12b43415a047210480843f746843b3792f","modified":1534095722278},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"864251708dac507bb041899d57e9a48759916476","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"5701b04252f113cc78dfde69bd6393fff6b1cce2","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"5507b4dfab2032345e012a0c5356f63b01395157","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"99ae7e411f8d24bed54a27be30bb71ef2041ff7b","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"a6714eed28ede8a50c186ef76798b410c2fb4f31","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"27ad82343ca09685b1a5adea2f3ead70a030a37e","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"7e6c50b6c24de864e0d6a106e6a8e423e312454a","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"7a31274da81c076021692ff7c80a1be3bbf6fa4c","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"866bb0d3964f2938dc5b5a22c24b05d32870820c","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"c2e5cef2377884cd79e5f686fe4f74b082744306","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"1bba114fd5685dadc595a4fdd9ac326c08d48244","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"55042bba47352551e16add7ecb679b4a59da2b9f","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"5f5015bfc77c013f92395a4ac3464d28ab40a2a6","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"da40cb48b6b1f24cbd7107f7c97b04f063e9c299","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"6406251dabda66ef686d4c15edbc3061b6d828b8","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/autocomplete.styl","hash":"f6847a2c6d35dbd6d06dc591bd34ed2019784048","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"cc0a862b31359a85d12579e49d2eca58d128275c","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f6447a2ac407228e1d53e3455db2919ac0e9f094","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"4f687cbc74caf8a0887f5e89250284a9bce8b5c1","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"6c94d274b11553a982283b16770e0d54405a7bd5","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"0ba318911afbbbffbd2473b472aedf2d3900e978","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"c27f65e1ee2521b4eebf81242369a0825ce5cd6e","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"65efbddd23a264e7d1e85f4073228526770e833c","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"b600536ee237936c9f09609d96bb0dbb4adfb59b","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"4b996440bba8ec755aa70bc6d074d7dbba55ec0c","modified":1534095722282},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"06d0b7a12ccc71cb693f5d07720602fb514c24eb","modified":1534095722282},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1534095722282},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1534095722282},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1534095722282},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1534095722282},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"57c7f100019d57b512aab509185cb0a6eb9aa4c8","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"69d184a682bcaeba2b180b437dc4431bc3be38aa","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1534095722282},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1534095722282},{"_id":"themes/3-hexo/.git/objects/pack/pack-89e6c4803dab60e48b51715c0a122630ce39f181.idx","hash":"f55b67e072205e255529ea92652dc59646fbcb13","modified":1534095722254},{"_id":"themes/3-hexo/.git/refs/heads/master","hash":"8e0af13ee7441fc51351f60e99c0cc477bc1b072","modified":1534095722278},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"359f73329b9821f3ca3554d306a04d6766110a5a","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"cd0022ce7e6d6efb07a00e87477cdf791f7f6703","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/comments/gentie.ejs","hash":"1d6eacdadeb247e3b349ca7168f797beae8ff4c5","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"fad1fcafef7a15f8fa486e87a7c28d5bcd7e1b86","modified":1534095722282},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"f8f9b49c7c7a00d16bd41bb72b90cca3d320d73e","modified":1534095722282},{"_id":"themes/3-hexo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1534095722274},{"_id":"themes/3-hexo/.git/logs/refs/heads/master","hash":"79db9a12b43415a047210480843f746843b3792f","modified":1534095722278},{"_id":"themes/3-hexo/.git/logs/refs/remotes/origin/HEAD","hash":"79db9a12b43415a047210480843f746843b3792f","modified":1534095722274},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"b864356fbd31b5d694ccc46db97ea78455daf84d","modified":1534095722286},{"_id":"themes/3-hexo/.git/objects/pack/pack-89e6c4803dab60e48b51715c0a122630ce39f181.pack","hash":"9906db63e080d02effe4859aedecf5ec2adc10b5","modified":1534095722254},{"_id":"public/search.xml","hash":"e15fb9f6ce1c3144c00546b1d8519950bdd0379a","modified":1534162218191},{"_id":"public/2018/01/23/tool-softwares-and-plugins/index.html","hash":"95dec9c6223f7f4614d8406b7173d92ccb928005","modified":1534162218201},{"_id":"public/2018/01/23/tool-software-keys/index.html","hash":"9c3bc22ec7ca5012455e63a2ea5dbeb467a216b4","modified":1534162218201},{"_id":"public/2018/01/22/food-politics-in-America/index.html","hash":"7c415fa1ae0a8b590c68f33d0c744a1e282a0641","modified":1534162218201},{"_id":"public/2018/01/22/substring-jump/index.html","hash":"3bc781a5d85095d783e020b61c6dc1bf8cb32661","modified":1534162218201},{"_id":"public/2018/01/22/contacts-source-structure-analysis/index.html","hash":"ded26c0db1c28c337acc1992ec2e00e14c68e946","modified":1534162218201},{"_id":"public/2018/01/16/merge-contacts/index.html","hash":"8564e4040e45d40c2eb3a743e95fb1254ca3d8b5","modified":1534162218201},{"_id":"public/2018/01/15/import-Sim-card-contacts-when-boot/index.html","hash":"87950b3a08c19e5c3b283b54e64e4cdb73e7a4e1","modified":1534162218201},{"_id":"public/2018/01/05/Build-LineageOS-for-Nexus-5/index.html","hash":"8406bea987638fd3871e565183d9114a7e0a00dd","modified":1534162218201},{"_id":"public/2018/01/03/Hexo-GitHub-Pages-Establish-blog/index.html","hash":"e2c6f42157c4c1d44e86b11722ca2dd60df869d2","modified":1534162218201},{"_id":"public/2018/01/01/contacts-phone-number-fuzzy-search/index.html","hash":"430baa3c9797dab10e40dd0a0a596f90ec7cffcf","modified":1534162218201},{"_id":"public/2017/12/30/3-hexo-shortcuts/index.html","hash":"25fb94a4498de272334b1c1589ff10049ed5cc4d","modified":1534162218201},{"_id":"public/2017/12/23/blog-init/index.html","hash":"288190987be14d1b2e44751119598097cbd490be","modified":1534162218201},{"_id":"public/2015/08/10/access-across-processes/index.html","hash":"993a6eb8de68905cf54109b482215bd112e12fcc","modified":1534162218202},{"_id":"public/categories/Android/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218202},{"_id":"public/categories/init/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218202},{"_id":"public/categories/工具/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218202},{"_id":"public/categories/英语/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218202},{"_id":"public/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218202},{"_id":"public/page/2/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218202},{"_id":"public/archives/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218202},{"_id":"public/archives/page/2/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218202},{"_id":"public/archives/2015/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218202},{"_id":"public/archives/2015/08/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218202},{"_id":"public/archives/2017/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218202},{"_id":"public/archives/2017/12/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218202},{"_id":"public/archives/2018/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218203},{"_id":"public/archives/2018/01/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218203},{"_id":"public/tags/android/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218203},{"_id":"public/tags/contacts/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218203},{"_id":"public/tags/cm/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218203},{"_id":"public/tags/lineageos/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218203},{"_id":"public/tags/面试/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218203},{"_id":"public/tags/tools/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218203},{"_id":"public/tags/hexo/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218203},{"_id":"public/tags/blog/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218203},{"_id":"public/tags/3-hexo/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218204},{"_id":"public/tags/keys/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218204},{"_id":"public/tags/english/index.html","hash":"d5126b21c5630f20e91161b25eb376bcb679c653","modified":1534162218204},{"_id":"public/CNAME","hash":"c56f07d65fc8c6c7d83fc8019100cf09216768e6","modified":1534162218206},{"_id":"public/img/alipay.jpg","hash":"f0d1fad4d14841cc3dd3b00c37e66ca9d2548020","modified":1534162218206},{"_id":"public/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1534162218206},{"_id":"public/img/bg.jpg","hash":"331f382a62f46ac8819c3b408b21af4f92118cf7","modified":1534162218206},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1534162218206},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1534162218206},{"_id":"public/img/weixin.jpg","hash":"f0d1fad4d14841cc3dd3b00c37e66ca9d2548020","modified":1534162218206},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1534162218206},{"_id":"public/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1534162218207},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1534162218207},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1534162218207},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1534162218532},{"_id":"public/css/mobile.css","hash":"102f04bcf1923b67882e1bb545ae6f331c1ce7cd","modified":1534162218532},{"_id":"public/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1534162218533},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1534162218533},{"_id":"public/css/hl_theme/atom-light.css","hash":"a3c8f3ee9a655594eff7ac545cb2e6914c1abcc2","modified":1534162218533},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1534162218533},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1534162218533},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1534162218533},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1534162218533},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1534162218533},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1534162218533},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1534162218533},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1534162218533},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1534162218533},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1534162218533},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1534162218533},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1534162218533},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1534162218534},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1534162218534},{"_id":"public/js/script.js","hash":"311beeda0e450fc34943616c02da54e2229700a5","modified":1534162218534},{"_id":"public/css/style.css","hash":"5409cea3e90bd900b5bb8137c36ea542875642d6","modified":1534162218534},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1534162218534},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1534162218534},{"_id":"public/js/gitalk.js","hash":"b864356fbd31b5d694ccc46db97ea78455daf84d","modified":1534162218535}],"Category":[{"name":"Android","_id":"cjks8kndg0002xwuj9pmmis7p"},{"name":"init","_id":"cjks8knds000mxwujlgsvwejy"},{"name":"工具","_id":"cjks8kndu000vxwujg2faxepe"},{"name":"英语","_id":"cjks8kndz001exwujleez1snq"}],"Data":[],"Page":[],"Post":[{"title":"Contacts源码结构分析","date":"2018-01-22T09:53:49.000Z","_content":"\n## 1.简介\n\n联系人模块主要记录用户的联系人数据，方便用户快捷的操作和使用，主要包括本机联系人和Sim卡联系人。\n\n本机联系人主要存储在手机内部存储空间，Android平台上是通过数据库进行存储，使用ContentProvider组件封装，提供复杂的字段用于表示联系人数据，并提供用户快捷的操作，比如增加，删除，修改，查询等等。\n\nSim卡联系人主要存储在Sim卡内部存储文件，包括adn、fdn、sdn。主要提供简单的字段用于表示联系人数据。并通过IccProvider提供的接口进行数据的增加、删除、修改、查询操作。\n\n## 2.软件架构\n联系人Contacts应用主要包括3个部分:\nContacts主要响应用户的请求和交互，数据显示。\nContactsProvider继承自Android四大组件之一的ContentProvider组件，封装了对底层数据库contact2.db的添删改查。\nSQLite在底层物理性地存储了联系人数据。\n\n\n主要交互流程如下图：\n\n![](https://user-images.githubusercontent.com/35097187/44019032-3b7392de-9f10-11e8-8567-d4189730b46e.png)\n\nContacts模块的主要7块功能：\n\n![](https://user-images.githubusercontent.com/35097187/44019045-3d496fe8-9f10-11e8-8077-89235449ccd4.png)\n\n## 3. 各功能模块分析\n### 3.1 联系人数据的显示\n#### 3.1.1 联系人列表显示 ####\n\n`简要说明：`\n\n```xml\n* PeopleActivity类负责联系人列表的显示。\n\n* PeopleActivity包含4个Fragment，每个Fragment包含一个ListView。\n\n* 各个Fragment中ListView的Adapter（BaseAdapter的子类）负责将数据填充到ListView。\n\n* 各个Fragment的Loader类（CursorLoader的子类）负责加载数据。\n\n* 实现LoadertManager接口负责管理这些CursorLoader。\n```\n\n![](https://user-images.githubusercontent.com/35097187/44019049-3dc1ee1e-9f10-11e8-89f3-14dac608ea42.png)\n\n**为什么使用Loader？**\n```xml\n1. Loaders确保所有的cursor操作是异步的，从而排除了UI线程中堵塞的可能性。\n2. 当通过LoaderManager来管理，Loaders还可以在activity实例中保持当前的cursor数据，也就是不需要重新查询（比如，当因为横竖屏切换需要重新启动activity时）。\n3. 当数据改变时，Loaders可以自动检测底层数据的更新和重新检索。\n```\n\n**数据加载流程概览：**\n\n![](https://user-images.githubusercontent.com/35097187/44019046-3d7130f0-9f10-11e8-945c-7a0eff02b65c.png)\n\n**流程具体分析：**\n\n先上图：\n![](https://user-images.githubusercontent.com/35097187/44019033-3ba1bba0-9f10-11e8-94f9-e41053c967b4.jpeg)\n\n进入Contacts应用，程序的主入口Activity是`PeopleActivity`。\n\n进入`onCreate`方法：\n\n`createViewsAndFragments(savedState);`\n\n此方法创建视图和Fragments，进入此方法：\n\n```java\nmFavoritesFragment = new ContactTileListFragment();\nmAllFragment = new DefaultContactBrowseListFragment();\nmGroupsFragment = new GroupBrowseListFragment();\n```\n\n发现创建了3个Fragment，分别是 收藏联系人列表、所有联系人列表、群组列表。\n\n进入`DefaultContactBrowseListFragment`：\n\n发现`DefaultContactBrowseListFragment`的祖父类是：\n\n`ContactEntryListFragment<T extends ContactEntryListAdapter>`\n\n首先分析此基类：\n\n发现此基类实现了`LoadManager`接口，实现了该接口3个重要的抽象方法：\n\n```java\npublic Loader<D> onCreateLoader(int id, Bundle args);//创建Loader\npublic void onLoadFinished(Loader<D> loader, D data);//数据加载完毕后的回调方法\npublic void onLoaderReset(Loader<D> loader);//数据重新加载\n```\n\n该类同时提供了重要的抽象方法：\n\n```java\nprotected abstract T createListAdapter();//创建适配器Adapter类。\n```\n\n这意味着,子类可以按需求创造自己的适配器Adapter类,完成各个子界面Listview的数据显示，如3.1节图1所示。\n\n然后回到`DefaultContactBrowseListFragment`类：\n\n在执行`onCreateView`之前，会执行父类的一些方法，顺序如下：\n\n```java\nonAttach()\nsetContext(activity);\nsetLoaderManager(super.getLoaderManager());\n```\n\n`setLoaderManager`中设置当前的LoaderManager实现类。 \n\n加载联系人列表数据的过程中，这个类是`ProfileandContactsLoader`。\n\n之后执行`onCreate`方法。\n\n进入`DefaultContactBrowseListFragment`的`onCreate(Bundle)`方法：\n\n```java\nmAdapter = createListAdapter();\n```\n\n发现在这里创建了`ListAdapter`：\n\n```java\nDefaultContactListAdapter adapter = \nnew DefaultContactListAdapter(getContext());\n```\n\n可以知道创建的`ListAdapter`类型是`DefaultContactListAdapter`并返回到`DefaultContactBrowseListFragment`类。\n\n执行完`onCreate`方法之后，\n\n执行`DefaultContactBrowseListFragment`的`onCreateView`方法。\n\n进入DefaultContactBrowseListFragment的onCreateView方法：\n\n```java\nmListView = (ListView)mView.findViewById(android.R.id.list);\nmListView.setAdapter(mAdapter);\n```\n\n首先获取了ListView用以填充联系人数据，然后设置了适配器，但是此时适配器中的数据是空的，直到后面才会加载数据更新UI。\n在`onCreateView`方法执行完之后，在UI可见之前回调执行`Activity`的`onStart`方法。\n\n进入`DefaultContactBrowseListFragment`的`onStart`方法：\n\n```java\nmContactsPrefs.registerChangeListener(mPreferencesChangeListener);\nstartLoading();\n```\n\n首先注册了一个`ContentObserv`e的子类监听数据变化。\n然后执行`startLoading`方法，**目测这应当就是开始加载数据的方法了！**\n\n进入`DefaultContactBrowseListFragment`的`startLoading`方法：\n\n```java\nint partitionCount = mAdapter.getPartitionCount();\nfor (int i = 0; i < partitionCount; i++) {\n……\nPartition partition = mAdapter.getPartition(i);\nstartLoadingDirectoryPartition(i);\n……}\n```\n\n`Partition`这个类持有一个`Cursor`对象，用来存储数据。\n`Adapter`持有的`Partition`，`Partition`类代表了当前需要加载的`Directory`，可以理解为一个联系人集合，比如说本地联系人、Google联系人……这里我们假设只加载本地联系人数据，所以`partitionCount=1`。\n\n从这里我们可以做出猜测：\n联系人数据不是想象中的分页（每次N条联系人数据）加载，也不是说一次性全部加载，而是一个账户一个账户加载联系人数据，加载完毕一个账户就在uI刷新并显示数据。\n\n进入`DefaultContactBrowseListFragment`的`startLoadingDirectoryPartition`方法：\n\n```java\nloadDirectoryPartition(partitionIndex, partition);\n```\n\n进入此方法：\n\n```java\ngetLoaderManager().restartLoader(partitionIndex, args, this);\n```\n\n这个方法是LoaderManager实现类的方法，参照文档解释：\n\n>这个方法会新建/重启一个当前LoaderManager中的Loader，将回调方法注册给他，并开始加载数据。也就是说会回调LoaderManager的onCreateLoader()方法。\n>Starts a new or restarts an existing android.content.Loader in this manager, registers the callbacks to it, and (if the activity/fragment is currently started) starts loading it\n\n进入`LoadManager`接口的实现类：`LoaderManagerImpl`的`restartLoader`方法内部：\n\n```java\nLoaderInfo info = mLoaders.get(id);\nCreate info=\ncreateAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks<Object>)callback);\n//进入createAndInstallLoader方法：\nLoaderInfo info = createLoader(id, args, callback);\ninstallLoader(info);\n//进入createLoader方法：\nLoaderInfo info = new LoaderInfo(id, args,  (LoaderManager.LoaderCallbacks<Object>)callback);\nLoader<Object> loader = callback.onCreateLoader(id, args);\n//关键方法出现了！LoadManager接口的抽象方法的onCreateLoader方法被回调了！\n//然后installLoader方法启动了这个Loader！\ninfo.start();\n```\n\n进入`ContactEntryListFragment`的`onCreateLoader`方法，位于`DefaultContactBrowseListFragment`的祖父类`ContactEntryListFragment`中：\n\n```java\nCursorLoader loader = createCursorLoader(mContext);//创建Loader\nmAdapter.configureLoader(loader, directoryId);//配置Loader\n```\n\n发现在此方法中，首先调用`createCursorLoader`方法创建了`Loader`。\n然后通过`configureLoader`方法配置`Loader`的`query`方法的查询参数，也就是配置SQL中select查询语句的参数。\n这也同时意味着，`ContactEntryListFragment`类的子类们可以重写`createCursorLoader`方法以提供适合自身的Loader，重写`configureLoader`方法为Loader配置合适的参数，适配各种自定义的查询获取数据。\n\n观察`createCursorLoader`方法在`DefaultContactBrowseListFragment`类中实现：\n\n```java\nreturn new ProfileAndContactsLoader(context);\n```\n\n直接返回了`DefaultContactBrowseListFragment`的数据加载器：`ProfileAndContactsLoader`\n这就是`DefaultContactBrowseListFragment`的Loader实现类（数据加载器）。\n\n然后再看一下`ProfileAndContactsLoader`类是如何加载数据的呢？\n发现它继承自`CursorLoader`，而`CursorLoader`又继承自`AsyncTaskLoader<D>`\n在关键的`LoadBackGround()`方法中：\n异步调用了ContentResolver的`query`方法：\n\n```java\nCursor cursor = getContext()\n.getContentResolver()\n.query(mUri, mProjection, mSelection,\n                    mSelectionArgs, mSortOrder, mCancellationSignal);\ncursor.registerContentObserver(mObserver);\n```\n\n通过这个Query方法，实现了对联系人数据的查询,返回Cursor数据。并绑定了数据监听器。\n\n\n那么问题来了\n\n```java\nquery(mUri, mProjection, mSelection,mSelectionArgs, mSortOrder, mCancellationSignal)\n```\n的这些参数那里指定的呢？\n`configureLoader`方法在`DefaultContactListAdapter`类中实现，实现了对`query`参数的配置：\n\n```java\nconfigureUri(loader, directoryId, filter);\nloader.setProjection(getProjection(false));\nconfigureSelection(loader, directoryId, filter);\nloader.setSortOrder(sortOrder);\n```\n\n可以看到，配置了Loader主要的几个参数：Uri，Projection，Selection，SortOrder。\n这些参数用于最后和ContactsProvider交互的方法Query方法中……\n\n最终查询`ContactsProvider2`的uri是：\n\n```xml\nUri：content://com.android.contacts/contacts?address_book_index_extras=true&directory=0\n```\n\n发现ContentProvider的服务类似一个网站，uri就是网址，而请求数据的方式类似使用Get方式获取数据。\n\n最后通过ContentProvider2构建的查询语句是这样的：\n\n```sql\nSELECT \n_id, display_name, agg_presence.mode AS contact_presence, \ncontacts_status_updates.status AS contact_status, photo_id, photo_thumb_uri, lookup, \nis_user_profile \nFROM view_contacts \nLEFT OUTER JOIN agg_presence ON (_id = agg_presence.presence_contact_id) LEFT OUTER JOIN \nstatus_updates contacts_status_updates ON\n(status_update_id=contacts_status_updates.status_update_data_id)\n```\n可以发现最后通过ContactsProvider2实现的查询，并不是直接查询相关的表（Contacts表、rawcontacts表，data表……），而是直接查询`view_contacts`视图，因为这样会有更加高的效率。\n这也就意味着如果想给联系人数据库新增一个字段供界面使用，仅修改对应的表结构是不行，还要修改对应的视图才能得到想要的效果。\n\n\n查询完毕后，回调`LoaderManager`的`onLoadFinished`方法，完成对UI界面的更新：\n\n```java\nonPartitionLoaded(loaderId, data);\n```\n\n接着进入`onPartitionLoaded`方法：\n\n```java\nmAdapter.changeCursor(partitionIndex, data);\n```\n\n进入这个`changeCursor`方法：\n\n```java\nmPartitions[partition].cursor = cursor;\nnotifyDataSetChanged();\n```\n\n发现在这里改变了`Adapter`的数据集`Cursor`，并发出通知数据已经改变，UI进行更新。\n\n至此，默认联系人数据的显示分析到此结束。\n\n其他`Fragment`的数据填充基本仍然类似此流程，所不同的只是各自的`Fragment`、`Adapter`、`CursorLoader`以及`CursorLoader`配置的参数（uri，projection,selection,args,order……）有所不同。\n\n可以参考下表：\n\n| Fragment | Adapter | CursorLoader |\n| :------: | :------: | :------: |\n|DefaultContactBrowseListFragment(默认联系人列表)|DefaultContactListAdapter|ProfileAndContactsLoader|\n|ContactTitleListFragment(收藏联系人列表)|ContactTileAdapter|ContactTileLoaderFactory StarredLoader|\n|ContactTitleFrequentFragment(常用联系人列表)|ContactTitleAdapter|ContactTileLoaderFactory FrequentLoader|\n|GroupBrowseListFragment(群组列表)|GroupBrowseLIstAdapter|GroupListLoader|\n|GroupDetailFragment(指定ID群组的联系人列表)|GroupMemberTileAdapter|GroupMemberLoader|\n|ContactDetailFragment(指定ID联系人信息)|ViewAdapter|ContactLoader| \n\n#### 3.1.2 联系人详细信息数据的显示 ####\n**关键类：**\n```java\nContactDetailActivity\n\nContactDetailFragment  \n\nContactLoaderFragment //不可见 负责加载联系人详细数据，集成LoadManager对象。\n\nContactLoader   //联系人详细信息Loader。\n\nContactDetailLayoutController     //布局控制类。\n```\n\n原理类似列表显示，如下简要说明： \n```xml\n* ContactLoaderFragment类创建了一个实现LoaderManager.LoaderCallbacks<Contact>接口的对象，数据类型指定为Contacts。负责创建、管理ContactLoader。\n \n* 得到当前用户选择的联系人URI，配置对应的ContactLoader。 \n\n* 后台数据查询完毕后，回调LoadManager的onLoadFinished()方法，并将数据以Contacts的数据类型返回，然后回调ContactDetailLoaderFragmentListener的onDetailsLoaded()方法。 \n\n* onDetailsLoaded()方法中，新开一个线程，通过ContactDetailLayoutController类的setContactData(Conatct)设置数据，刷新ContactDetailFragment。\n```\n\n### 3.2 联系人数据的编辑和存储\n\n#### 3.2.1 编辑界面相关####\n\n联系人数据所属的账号不同，加载的UI也是不同的，比如Sim卡联系人一般只有name，phone num，但是本地账号联系人可能就会有email，\n\naddress，website等信息…… \n\n联系人数据UI的加载是通过代码动态加载的，而不是xml文件写死的。\n\n那么问题来了， \n\n新建联系人的界面是如何设计？ \n\n![](https://user-images.githubusercontent.com/35097187/44019034-3bc9de0a-9f10-11e8-8f38-f764c64cc8e2.jpeg)\n\n先进入新建联系人界面：\n\n主界面PeopleActivity中点击新建联系人Button，触发onOptionsItemSelected方法中的\n\ncase R.id.menu_add_contact分支： \n\n执行`startActivity(intent);` \n\nstartActivity启动Intent，Intent的Action设置为android.intent.action.INSERT \n\n找到匹配此Action的Activity：`ContactEditorActivity`\n\n`ContactEditorActivity`的布局文件：\n \n`ContactEditorActivity`的`onCreate()`方法中找到布局： \n\n`setContentView(R.layout.contact_editor_activity);`\n\n在xml文件中找到这个布局：\n\n```xml\n<FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n <fragment class=\"com.android.contacts.editor.ContactEditorFragment\"\n            android:id=\"@+id/contact_editor_fragment\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\" />\n</FrameLayout>\n```\n\n只包含一个Fragment：`ContactEditorFragment`。程序解析Xml文件到这里就会执行`ContactEditorFragment`类。\n\n进入`ContactEditorFragment`的`onCreateView`方法：\n\n```xml\n//展开布局 \nfinal View view\n= inflater.inflate(R.layout.contact_editor_fragment, container, false);    \n//找到布局中的一个线性布局\n//关键的布局是contact_editor_fragment中的一个iD为editors的线性布局！\nmContent = (LinearLayout) view.findViewById(R.id.editors);\n```\n\n找到`contact_editor_fragment`：\n\n```xml\n<ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:fillViewport=\"true\"\n    android:fadingEdge=\"none\"\n    android:background=\"@color/background_primary\"\n>\n    <LinearLayout android:id=\"@+id/editors\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\"\n    />\n</ScrollView>\n```\n\n于是确认ContactEditorFragment的根布局就是一个id为editors的LinearLayout。 \n想到上一步的语句：\n\n```xml\nmContent = (LinearLayout) view.findViewById(R.id.editors);\n```\n\n所以关键就在于，接下来在代码中为mContent这个线性布局动态添加地了什么UI，而这些UI才是真正显示的东西。\n\n`ContactEditorFragment`的`onCreateView`方法执行完毕之后，会调用`onActivityCreate()`方法：\n\n```java\nif (Intent.ACTION_INSERT.equals(mAction)) {\nfinal Account account = mIntentExtras == null ? null : (Account) \nmIntentExtbindEditorsForNewContactras.getParcelable(Intents.Insert.ACCOUNT);\nfinal String dataSet = mIntentExtras == null ? null :\n                        mIntentExtras.getString(Intents.Insert.DATA_SET);\nif (account != null) {\n// Account specified in Intent\ncreateContact(new AccountWithDataSet(account.name, account.type, dataSet));\n}\n```\n\n上面代码首先取出了当前Account信息，数据信息。封装为一个AccountWithDataSet对象，作为createContact方法的参数。之前我们分析过，编辑界面和账户是高度相关的，所以对UI的动态操作必然和Account对象相关。进入createContact方法。\n\n看一下ContactEditorFragment中的createContact()到底对界面干了什么！！ \n\ncreateContact方法中调用了bindEditorsForNewContact(account, accountType): \n\n关键代码：\n```java\n……\nfinal RawContact rawContact = new RawContact();\n        if (newAccount != null) {\n            rawContact.setAccount(newAccount);\n        } else {\n            rawContact.setAccountToLocal();\n        }\nfinal ValuesDelta valuesDelta = ValuesDelta.fromAfter(rawContact.getValues());\nfinal RawContactDelta insert = new RawContactDelta(valuesDelta);\n……\nmState.add(insert);\nbindEditors();\n```\n\n数据存储相关\n\n### 3.3 Sim联系人数据的整合\nSim卡联系人数据的显示\n开机自动导入Sim卡联系人\ntelephony中IccProvider浅析\nSim卡联系人的手动导入导出\n\n### 3.4 SD卡备份/恢复联系人\n- SD卡备份/恢复联系人\n- 联系人数据导出到SD卡\n\n### 3.5 联系人搜索\n\n### 3.6 Google联系人同步\n\n### 3.7 其他零碎功能\n\n\n","source":"_posts/Android/Contacts源码结构分析.md","raw":"---\ntitle: Contacts源码结构分析\npermalink: contacts-source-structure-analysis\ncategories:\n  - Android\ntags:\n  - android\n  - contacts\ndate: 2018-01-22 17:53:49\n---\n\n## 1.简介\n\n联系人模块主要记录用户的联系人数据，方便用户快捷的操作和使用，主要包括本机联系人和Sim卡联系人。\n\n本机联系人主要存储在手机内部存储空间，Android平台上是通过数据库进行存储，使用ContentProvider组件封装，提供复杂的字段用于表示联系人数据，并提供用户快捷的操作，比如增加，删除，修改，查询等等。\n\nSim卡联系人主要存储在Sim卡内部存储文件，包括adn、fdn、sdn。主要提供简单的字段用于表示联系人数据。并通过IccProvider提供的接口进行数据的增加、删除、修改、查询操作。\n\n## 2.软件架构\n联系人Contacts应用主要包括3个部分:\nContacts主要响应用户的请求和交互，数据显示。\nContactsProvider继承自Android四大组件之一的ContentProvider组件，封装了对底层数据库contact2.db的添删改查。\nSQLite在底层物理性地存储了联系人数据。\n\n\n主要交互流程如下图：\n\n![](https://user-images.githubusercontent.com/35097187/44019032-3b7392de-9f10-11e8-8567-d4189730b46e.png)\n\nContacts模块的主要7块功能：\n\n![](https://user-images.githubusercontent.com/35097187/44019045-3d496fe8-9f10-11e8-8077-89235449ccd4.png)\n\n## 3. 各功能模块分析\n### 3.1 联系人数据的显示\n#### 3.1.1 联系人列表显示 ####\n\n`简要说明：`\n\n```xml\n* PeopleActivity类负责联系人列表的显示。\n\n* PeopleActivity包含4个Fragment，每个Fragment包含一个ListView。\n\n* 各个Fragment中ListView的Adapter（BaseAdapter的子类）负责将数据填充到ListView。\n\n* 各个Fragment的Loader类（CursorLoader的子类）负责加载数据。\n\n* 实现LoadertManager接口负责管理这些CursorLoader。\n```\n\n![](https://user-images.githubusercontent.com/35097187/44019049-3dc1ee1e-9f10-11e8-89f3-14dac608ea42.png)\n\n**为什么使用Loader？**\n```xml\n1. Loaders确保所有的cursor操作是异步的，从而排除了UI线程中堵塞的可能性。\n2. 当通过LoaderManager来管理，Loaders还可以在activity实例中保持当前的cursor数据，也就是不需要重新查询（比如，当因为横竖屏切换需要重新启动activity时）。\n3. 当数据改变时，Loaders可以自动检测底层数据的更新和重新检索。\n```\n\n**数据加载流程概览：**\n\n![](https://user-images.githubusercontent.com/35097187/44019046-3d7130f0-9f10-11e8-945c-7a0eff02b65c.png)\n\n**流程具体分析：**\n\n先上图：\n![](https://user-images.githubusercontent.com/35097187/44019033-3ba1bba0-9f10-11e8-94f9-e41053c967b4.jpeg)\n\n进入Contacts应用，程序的主入口Activity是`PeopleActivity`。\n\n进入`onCreate`方法：\n\n`createViewsAndFragments(savedState);`\n\n此方法创建视图和Fragments，进入此方法：\n\n```java\nmFavoritesFragment = new ContactTileListFragment();\nmAllFragment = new DefaultContactBrowseListFragment();\nmGroupsFragment = new GroupBrowseListFragment();\n```\n\n发现创建了3个Fragment，分别是 收藏联系人列表、所有联系人列表、群组列表。\n\n进入`DefaultContactBrowseListFragment`：\n\n发现`DefaultContactBrowseListFragment`的祖父类是：\n\n`ContactEntryListFragment<T extends ContactEntryListAdapter>`\n\n首先分析此基类：\n\n发现此基类实现了`LoadManager`接口，实现了该接口3个重要的抽象方法：\n\n```java\npublic Loader<D> onCreateLoader(int id, Bundle args);//创建Loader\npublic void onLoadFinished(Loader<D> loader, D data);//数据加载完毕后的回调方法\npublic void onLoaderReset(Loader<D> loader);//数据重新加载\n```\n\n该类同时提供了重要的抽象方法：\n\n```java\nprotected abstract T createListAdapter();//创建适配器Adapter类。\n```\n\n这意味着,子类可以按需求创造自己的适配器Adapter类,完成各个子界面Listview的数据显示，如3.1节图1所示。\n\n然后回到`DefaultContactBrowseListFragment`类：\n\n在执行`onCreateView`之前，会执行父类的一些方法，顺序如下：\n\n```java\nonAttach()\nsetContext(activity);\nsetLoaderManager(super.getLoaderManager());\n```\n\n`setLoaderManager`中设置当前的LoaderManager实现类。 \n\n加载联系人列表数据的过程中，这个类是`ProfileandContactsLoader`。\n\n之后执行`onCreate`方法。\n\n进入`DefaultContactBrowseListFragment`的`onCreate(Bundle)`方法：\n\n```java\nmAdapter = createListAdapter();\n```\n\n发现在这里创建了`ListAdapter`：\n\n```java\nDefaultContactListAdapter adapter = \nnew DefaultContactListAdapter(getContext());\n```\n\n可以知道创建的`ListAdapter`类型是`DefaultContactListAdapter`并返回到`DefaultContactBrowseListFragment`类。\n\n执行完`onCreate`方法之后，\n\n执行`DefaultContactBrowseListFragment`的`onCreateView`方法。\n\n进入DefaultContactBrowseListFragment的onCreateView方法：\n\n```java\nmListView = (ListView)mView.findViewById(android.R.id.list);\nmListView.setAdapter(mAdapter);\n```\n\n首先获取了ListView用以填充联系人数据，然后设置了适配器，但是此时适配器中的数据是空的，直到后面才会加载数据更新UI。\n在`onCreateView`方法执行完之后，在UI可见之前回调执行`Activity`的`onStart`方法。\n\n进入`DefaultContactBrowseListFragment`的`onStart`方法：\n\n```java\nmContactsPrefs.registerChangeListener(mPreferencesChangeListener);\nstartLoading();\n```\n\n首先注册了一个`ContentObserv`e的子类监听数据变化。\n然后执行`startLoading`方法，**目测这应当就是开始加载数据的方法了！**\n\n进入`DefaultContactBrowseListFragment`的`startLoading`方法：\n\n```java\nint partitionCount = mAdapter.getPartitionCount();\nfor (int i = 0; i < partitionCount; i++) {\n……\nPartition partition = mAdapter.getPartition(i);\nstartLoadingDirectoryPartition(i);\n……}\n```\n\n`Partition`这个类持有一个`Cursor`对象，用来存储数据。\n`Adapter`持有的`Partition`，`Partition`类代表了当前需要加载的`Directory`，可以理解为一个联系人集合，比如说本地联系人、Google联系人……这里我们假设只加载本地联系人数据，所以`partitionCount=1`。\n\n从这里我们可以做出猜测：\n联系人数据不是想象中的分页（每次N条联系人数据）加载，也不是说一次性全部加载，而是一个账户一个账户加载联系人数据，加载完毕一个账户就在uI刷新并显示数据。\n\n进入`DefaultContactBrowseListFragment`的`startLoadingDirectoryPartition`方法：\n\n```java\nloadDirectoryPartition(partitionIndex, partition);\n```\n\n进入此方法：\n\n```java\ngetLoaderManager().restartLoader(partitionIndex, args, this);\n```\n\n这个方法是LoaderManager实现类的方法，参照文档解释：\n\n>这个方法会新建/重启一个当前LoaderManager中的Loader，将回调方法注册给他，并开始加载数据。也就是说会回调LoaderManager的onCreateLoader()方法。\n>Starts a new or restarts an existing android.content.Loader in this manager, registers the callbacks to it, and (if the activity/fragment is currently started) starts loading it\n\n进入`LoadManager`接口的实现类：`LoaderManagerImpl`的`restartLoader`方法内部：\n\n```java\nLoaderInfo info = mLoaders.get(id);\nCreate info=\ncreateAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks<Object>)callback);\n//进入createAndInstallLoader方法：\nLoaderInfo info = createLoader(id, args, callback);\ninstallLoader(info);\n//进入createLoader方法：\nLoaderInfo info = new LoaderInfo(id, args,  (LoaderManager.LoaderCallbacks<Object>)callback);\nLoader<Object> loader = callback.onCreateLoader(id, args);\n//关键方法出现了！LoadManager接口的抽象方法的onCreateLoader方法被回调了！\n//然后installLoader方法启动了这个Loader！\ninfo.start();\n```\n\n进入`ContactEntryListFragment`的`onCreateLoader`方法，位于`DefaultContactBrowseListFragment`的祖父类`ContactEntryListFragment`中：\n\n```java\nCursorLoader loader = createCursorLoader(mContext);//创建Loader\nmAdapter.configureLoader(loader, directoryId);//配置Loader\n```\n\n发现在此方法中，首先调用`createCursorLoader`方法创建了`Loader`。\n然后通过`configureLoader`方法配置`Loader`的`query`方法的查询参数，也就是配置SQL中select查询语句的参数。\n这也同时意味着，`ContactEntryListFragment`类的子类们可以重写`createCursorLoader`方法以提供适合自身的Loader，重写`configureLoader`方法为Loader配置合适的参数，适配各种自定义的查询获取数据。\n\n观察`createCursorLoader`方法在`DefaultContactBrowseListFragment`类中实现：\n\n```java\nreturn new ProfileAndContactsLoader(context);\n```\n\n直接返回了`DefaultContactBrowseListFragment`的数据加载器：`ProfileAndContactsLoader`\n这就是`DefaultContactBrowseListFragment`的Loader实现类（数据加载器）。\n\n然后再看一下`ProfileAndContactsLoader`类是如何加载数据的呢？\n发现它继承自`CursorLoader`，而`CursorLoader`又继承自`AsyncTaskLoader<D>`\n在关键的`LoadBackGround()`方法中：\n异步调用了ContentResolver的`query`方法：\n\n```java\nCursor cursor = getContext()\n.getContentResolver()\n.query(mUri, mProjection, mSelection,\n                    mSelectionArgs, mSortOrder, mCancellationSignal);\ncursor.registerContentObserver(mObserver);\n```\n\n通过这个Query方法，实现了对联系人数据的查询,返回Cursor数据。并绑定了数据监听器。\n\n\n那么问题来了\n\n```java\nquery(mUri, mProjection, mSelection,mSelectionArgs, mSortOrder, mCancellationSignal)\n```\n的这些参数那里指定的呢？\n`configureLoader`方法在`DefaultContactListAdapter`类中实现，实现了对`query`参数的配置：\n\n```java\nconfigureUri(loader, directoryId, filter);\nloader.setProjection(getProjection(false));\nconfigureSelection(loader, directoryId, filter);\nloader.setSortOrder(sortOrder);\n```\n\n可以看到，配置了Loader主要的几个参数：Uri，Projection，Selection，SortOrder。\n这些参数用于最后和ContactsProvider交互的方法Query方法中……\n\n最终查询`ContactsProvider2`的uri是：\n\n```xml\nUri：content://com.android.contacts/contacts?address_book_index_extras=true&directory=0\n```\n\n发现ContentProvider的服务类似一个网站，uri就是网址，而请求数据的方式类似使用Get方式获取数据。\n\n最后通过ContentProvider2构建的查询语句是这样的：\n\n```sql\nSELECT \n_id, display_name, agg_presence.mode AS contact_presence, \ncontacts_status_updates.status AS contact_status, photo_id, photo_thumb_uri, lookup, \nis_user_profile \nFROM view_contacts \nLEFT OUTER JOIN agg_presence ON (_id = agg_presence.presence_contact_id) LEFT OUTER JOIN \nstatus_updates contacts_status_updates ON\n(status_update_id=contacts_status_updates.status_update_data_id)\n```\n可以发现最后通过ContactsProvider2实现的查询，并不是直接查询相关的表（Contacts表、rawcontacts表，data表……），而是直接查询`view_contacts`视图，因为这样会有更加高的效率。\n这也就意味着如果想给联系人数据库新增一个字段供界面使用，仅修改对应的表结构是不行，还要修改对应的视图才能得到想要的效果。\n\n\n查询完毕后，回调`LoaderManager`的`onLoadFinished`方法，完成对UI界面的更新：\n\n```java\nonPartitionLoaded(loaderId, data);\n```\n\n接着进入`onPartitionLoaded`方法：\n\n```java\nmAdapter.changeCursor(partitionIndex, data);\n```\n\n进入这个`changeCursor`方法：\n\n```java\nmPartitions[partition].cursor = cursor;\nnotifyDataSetChanged();\n```\n\n发现在这里改变了`Adapter`的数据集`Cursor`，并发出通知数据已经改变，UI进行更新。\n\n至此，默认联系人数据的显示分析到此结束。\n\n其他`Fragment`的数据填充基本仍然类似此流程，所不同的只是各自的`Fragment`、`Adapter`、`CursorLoader`以及`CursorLoader`配置的参数（uri，projection,selection,args,order……）有所不同。\n\n可以参考下表：\n\n| Fragment | Adapter | CursorLoader |\n| :------: | :------: | :------: |\n|DefaultContactBrowseListFragment(默认联系人列表)|DefaultContactListAdapter|ProfileAndContactsLoader|\n|ContactTitleListFragment(收藏联系人列表)|ContactTileAdapter|ContactTileLoaderFactory StarredLoader|\n|ContactTitleFrequentFragment(常用联系人列表)|ContactTitleAdapter|ContactTileLoaderFactory FrequentLoader|\n|GroupBrowseListFragment(群组列表)|GroupBrowseLIstAdapter|GroupListLoader|\n|GroupDetailFragment(指定ID群组的联系人列表)|GroupMemberTileAdapter|GroupMemberLoader|\n|ContactDetailFragment(指定ID联系人信息)|ViewAdapter|ContactLoader| \n\n#### 3.1.2 联系人详细信息数据的显示 ####\n**关键类：**\n```java\nContactDetailActivity\n\nContactDetailFragment  \n\nContactLoaderFragment //不可见 负责加载联系人详细数据，集成LoadManager对象。\n\nContactLoader   //联系人详细信息Loader。\n\nContactDetailLayoutController     //布局控制类。\n```\n\n原理类似列表显示，如下简要说明： \n```xml\n* ContactLoaderFragment类创建了一个实现LoaderManager.LoaderCallbacks<Contact>接口的对象，数据类型指定为Contacts。负责创建、管理ContactLoader。\n \n* 得到当前用户选择的联系人URI，配置对应的ContactLoader。 \n\n* 后台数据查询完毕后，回调LoadManager的onLoadFinished()方法，并将数据以Contacts的数据类型返回，然后回调ContactDetailLoaderFragmentListener的onDetailsLoaded()方法。 \n\n* onDetailsLoaded()方法中，新开一个线程，通过ContactDetailLayoutController类的setContactData(Conatct)设置数据，刷新ContactDetailFragment。\n```\n\n### 3.2 联系人数据的编辑和存储\n\n#### 3.2.1 编辑界面相关####\n\n联系人数据所属的账号不同，加载的UI也是不同的，比如Sim卡联系人一般只有name，phone num，但是本地账号联系人可能就会有email，\n\naddress，website等信息…… \n\n联系人数据UI的加载是通过代码动态加载的，而不是xml文件写死的。\n\n那么问题来了， \n\n新建联系人的界面是如何设计？ \n\n![](https://user-images.githubusercontent.com/35097187/44019034-3bc9de0a-9f10-11e8-8f38-f764c64cc8e2.jpeg)\n\n先进入新建联系人界面：\n\n主界面PeopleActivity中点击新建联系人Button，触发onOptionsItemSelected方法中的\n\ncase R.id.menu_add_contact分支： \n\n执行`startActivity(intent);` \n\nstartActivity启动Intent，Intent的Action设置为android.intent.action.INSERT \n\n找到匹配此Action的Activity：`ContactEditorActivity`\n\n`ContactEditorActivity`的布局文件：\n \n`ContactEditorActivity`的`onCreate()`方法中找到布局： \n\n`setContentView(R.layout.contact_editor_activity);`\n\n在xml文件中找到这个布局：\n\n```xml\n<FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n <fragment class=\"com.android.contacts.editor.ContactEditorFragment\"\n            android:id=\"@+id/contact_editor_fragment\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\" />\n</FrameLayout>\n```\n\n只包含一个Fragment：`ContactEditorFragment`。程序解析Xml文件到这里就会执行`ContactEditorFragment`类。\n\n进入`ContactEditorFragment`的`onCreateView`方法：\n\n```xml\n//展开布局 \nfinal View view\n= inflater.inflate(R.layout.contact_editor_fragment, container, false);    \n//找到布局中的一个线性布局\n//关键的布局是contact_editor_fragment中的一个iD为editors的线性布局！\nmContent = (LinearLayout) view.findViewById(R.id.editors);\n```\n\n找到`contact_editor_fragment`：\n\n```xml\n<ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:fillViewport=\"true\"\n    android:fadingEdge=\"none\"\n    android:background=\"@color/background_primary\"\n>\n    <LinearLayout android:id=\"@+id/editors\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\"\n    />\n</ScrollView>\n```\n\n于是确认ContactEditorFragment的根布局就是一个id为editors的LinearLayout。 \n想到上一步的语句：\n\n```xml\nmContent = (LinearLayout) view.findViewById(R.id.editors);\n```\n\n所以关键就在于，接下来在代码中为mContent这个线性布局动态添加地了什么UI，而这些UI才是真正显示的东西。\n\n`ContactEditorFragment`的`onCreateView`方法执行完毕之后，会调用`onActivityCreate()`方法：\n\n```java\nif (Intent.ACTION_INSERT.equals(mAction)) {\nfinal Account account = mIntentExtras == null ? null : (Account) \nmIntentExtbindEditorsForNewContactras.getParcelable(Intents.Insert.ACCOUNT);\nfinal String dataSet = mIntentExtras == null ? null :\n                        mIntentExtras.getString(Intents.Insert.DATA_SET);\nif (account != null) {\n// Account specified in Intent\ncreateContact(new AccountWithDataSet(account.name, account.type, dataSet));\n}\n```\n\n上面代码首先取出了当前Account信息，数据信息。封装为一个AccountWithDataSet对象，作为createContact方法的参数。之前我们分析过，编辑界面和账户是高度相关的，所以对UI的动态操作必然和Account对象相关。进入createContact方法。\n\n看一下ContactEditorFragment中的createContact()到底对界面干了什么！！ \n\ncreateContact方法中调用了bindEditorsForNewContact(account, accountType): \n\n关键代码：\n```java\n……\nfinal RawContact rawContact = new RawContact();\n        if (newAccount != null) {\n            rawContact.setAccount(newAccount);\n        } else {\n            rawContact.setAccountToLocal();\n        }\nfinal ValuesDelta valuesDelta = ValuesDelta.fromAfter(rawContact.getValues());\nfinal RawContactDelta insert = new RawContactDelta(valuesDelta);\n……\nmState.add(insert);\nbindEditors();\n```\n\n数据存储相关\n\n### 3.3 Sim联系人数据的整合\nSim卡联系人数据的显示\n开机自动导入Sim卡联系人\ntelephony中IccProvider浅析\nSim卡联系人的手动导入导出\n\n### 3.4 SD卡备份/恢复联系人\n- SD卡备份/恢复联系人\n- 联系人数据导出到SD卡\n\n### 3.5 联系人搜索\n\n### 3.6 Google联系人同步\n\n### 3.7 其他零碎功能\n\n\n","slug":"contacts-source-structure-analysis","published":1,"updated":"2018-08-13T11:41:56.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjks8kndb0000xwujrh0tfo5g","content":"<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h2><p>联系人模块主要记录用户的联系人数据，方便用户快捷的操作和使用，主要包括本机联系人和Sim卡联系人。</p>\n<p>本机联系人主要存储在手机内部存储空间，Android平台上是通过数据库进行存储，使用ContentProvider组件封装，提供复杂的字段用于表示联系人数据，并提供用户快捷的操作，比如增加，删除，修改，查询等等。</p>\n<p>Sim卡联系人主要存储在Sim卡内部存储文件，包括adn、fdn、sdn。主要提供简单的字段用于表示联系人数据。并通过IccProvider提供的接口进行数据的增加、删除、修改、查询操作。</p>\n<h2 id=\"2-软件架构\"><a href=\"#2-软件架构\" class=\"headerlink\" title=\"2.软件架构\"></a>2.软件架构</h2><p>联系人Contacts应用主要包括3个部分:<br>Contacts主要响应用户的请求和交互，数据显示。<br>ContactsProvider继承自Android四大组件之一的ContentProvider组件，封装了对底层数据库contact2.db的添删改查。<br>SQLite在底层物理性地存储了联系人数据。</p>\n<p>主要交互流程如下图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019032-3b7392de-9f10-11e8-8567-d4189730b46e.png\" alt=\"\"></p>\n<p>Contacts模块的主要7块功能：</p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019045-3d496fe8-9f10-11e8-8077-89235449ccd4.png\" alt=\"\"></p>\n<h2 id=\"3-各功能模块分析\"><a href=\"#3-各功能模块分析\" class=\"headerlink\" title=\"3. 各功能模块分析\"></a>3. 各功能模块分析</h2><h3 id=\"3-1-联系人数据的显示\"><a href=\"#3-1-联系人数据的显示\" class=\"headerlink\" title=\"3.1 联系人数据的显示\"></a>3.1 联系人数据的显示</h3><h4 id=\"3-1-1-联系人列表显示\"><a href=\"#3-1-1-联系人列表显示\" class=\"headerlink\" title=\"3.1.1 联系人列表显示\"></a>3.1.1 联系人列表显示</h4><p><code>简要说明：</code></p>\n<pre><code class=\"xml\">* PeopleActivity类负责联系人列表的显示。\n\n* PeopleActivity包含4个Fragment，每个Fragment包含一个ListView。\n\n* 各个Fragment中ListView的Adapter（BaseAdapter的子类）负责将数据填充到ListView。\n\n* 各个Fragment的Loader类（CursorLoader的子类）负责加载数据。\n\n* 实现LoadertManager接口负责管理这些CursorLoader。\n</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019049-3dc1ee1e-9f10-11e8-89f3-14dac608ea42.png\" alt=\"\"></p>\n<p><strong>为什么使用Loader？</strong></p>\n<pre><code class=\"xml\">1. Loaders确保所有的cursor操作是异步的，从而排除了UI线程中堵塞的可能性。\n2. 当通过LoaderManager来管理，Loaders还可以在activity实例中保持当前的cursor数据，也就是不需要重新查询（比如，当因为横竖屏切换需要重新启动activity时）。\n3. 当数据改变时，Loaders可以自动检测底层数据的更新和重新检索。\n</code></pre>\n<p><strong>数据加载流程概览：</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019046-3d7130f0-9f10-11e8-945c-7a0eff02b65c.png\" alt=\"\"></p>\n<p><strong>流程具体分析：</strong></p>\n<p>先上图：<br><img src=\"https://user-images.githubusercontent.com/35097187/44019033-3ba1bba0-9f10-11e8-94f9-e41053c967b4.jpeg\" alt=\"\"></p>\n<p>进入Contacts应用，程序的主入口Activity是<code>PeopleActivity</code>。</p>\n<p>进入<code>onCreate</code>方法：</p>\n<p><code>createViewsAndFragments(savedState);</code></p>\n<p>此方法创建视图和Fragments，进入此方法：</p>\n<pre><code class=\"java\">mFavoritesFragment = new ContactTileListFragment();\nmAllFragment = new DefaultContactBrowseListFragment();\nmGroupsFragment = new GroupBrowseListFragment();\n</code></pre>\n<p>发现创建了3个Fragment，分别是 收藏联系人列表、所有联系人列表、群组列表。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>：</p>\n<p>发现<code>DefaultContactBrowseListFragment</code>的祖父类是：</p>\n<p><code>ContactEntryListFragment&lt;T extends ContactEntryListAdapter&gt;</code></p>\n<p>首先分析此基类：</p>\n<p>发现此基类实现了<code>LoadManager</code>接口，实现了该接口3个重要的抽象方法：</p>\n<pre><code class=\"java\">public Loader&lt;D&gt; onCreateLoader(int id, Bundle args);//创建Loader\npublic void onLoadFinished(Loader&lt;D&gt; loader, D data);//数据加载完毕后的回调方法\npublic void onLoaderReset(Loader&lt;D&gt; loader);//数据重新加载\n</code></pre>\n<p>该类同时提供了重要的抽象方法：</p>\n<pre><code class=\"java\">protected abstract T createListAdapter();//创建适配器Adapter类。\n</code></pre>\n<p>这意味着,子类可以按需求创造自己的适配器Adapter类,完成各个子界面Listview的数据显示，如3.1节图1所示。</p>\n<p>然后回到<code>DefaultContactBrowseListFragment</code>类：</p>\n<p>在执行<code>onCreateView</code>之前，会执行父类的一些方法，顺序如下：</p>\n<pre><code class=\"java\">onAttach()\nsetContext(activity);\nsetLoaderManager(super.getLoaderManager());\n</code></pre>\n<p><code>setLoaderManager</code>中设置当前的LoaderManager实现类。 </p>\n<p>加载联系人列表数据的过程中，这个类是<code>ProfileandContactsLoader</code>。</p>\n<p>之后执行<code>onCreate</code>方法。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>onCreate(Bundle)</code>方法：</p>\n<pre><code class=\"java\">mAdapter = createListAdapter();\n</code></pre>\n<p>发现在这里创建了<code>ListAdapter</code>：</p>\n<pre><code class=\"java\">DefaultContactListAdapter adapter = \nnew DefaultContactListAdapter(getContext());\n</code></pre>\n<p>可以知道创建的<code>ListAdapter</code>类型是<code>DefaultContactListAdapter</code>并返回到<code>DefaultContactBrowseListFragment</code>类。</p>\n<p>执行完<code>onCreate</code>方法之后，</p>\n<p>执行<code>DefaultContactBrowseListFragment</code>的<code>onCreateView</code>方法。</p>\n<p>进入DefaultContactBrowseListFragment的onCreateView方法：</p>\n<pre><code class=\"java\">mListView = (ListView)mView.findViewById(android.R.id.list);\nmListView.setAdapter(mAdapter);\n</code></pre>\n<p>首先获取了ListView用以填充联系人数据，然后设置了适配器，但是此时适配器中的数据是空的，直到后面才会加载数据更新UI。<br>在<code>onCreateView</code>方法执行完之后，在UI可见之前回调执行<code>Activity</code>的<code>onStart</code>方法。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>onStart</code>方法：</p>\n<pre><code class=\"java\">mContactsPrefs.registerChangeListener(mPreferencesChangeListener);\nstartLoading();\n</code></pre>\n<p>首先注册了一个<code>ContentObserv</code>e的子类监听数据变化。<br>然后执行<code>startLoading</code>方法，<strong>目测这应当就是开始加载数据的方法了！</strong></p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>startLoading</code>方法：</p>\n<pre><code class=\"java\">int partitionCount = mAdapter.getPartitionCount();\nfor (int i = 0; i &lt; partitionCount; i++) {\n……\nPartition partition = mAdapter.getPartition(i);\nstartLoadingDirectoryPartition(i);\n……}\n</code></pre>\n<p><code>Partition</code>这个类持有一个<code>Cursor</code>对象，用来存储数据。<br><code>Adapter</code>持有的<code>Partition</code>，<code>Partition</code>类代表了当前需要加载的<code>Directory</code>，可以理解为一个联系人集合，比如说本地联系人、Google联系人……这里我们假设只加载本地联系人数据，所以<code>partitionCount=1</code>。</p>\n<p>从这里我们可以做出猜测：<br>联系人数据不是想象中的分页（每次N条联系人数据）加载，也不是说一次性全部加载，而是一个账户一个账户加载联系人数据，加载完毕一个账户就在uI刷新并显示数据。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>startLoadingDirectoryPartition</code>方法：</p>\n<pre><code class=\"java\">loadDirectoryPartition(partitionIndex, partition);\n</code></pre>\n<p>进入此方法：</p>\n<pre><code class=\"java\">getLoaderManager().restartLoader(partitionIndex, args, this);\n</code></pre>\n<p>这个方法是LoaderManager实现类的方法，参照文档解释：</p>\n<blockquote>\n<p>这个方法会新建/重启一个当前LoaderManager中的Loader，将回调方法注册给他，并开始加载数据。也就是说会回调LoaderManager的onCreateLoader()方法。<br>Starts a new or restarts an existing android.content.Loader in this manager, registers the callbacks to it, and (if the activity/fragment is currently started) starts loading it</p>\n</blockquote>\n<p>进入<code>LoadManager</code>接口的实现类：<code>LoaderManagerImpl</code>的<code>restartLoader</code>方法内部：</p>\n<pre><code class=\"java\">LoaderInfo info = mLoaders.get(id);\nCreate info=\ncreateAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);\n//进入createAndInstallLoader方法：\nLoaderInfo info = createLoader(id, args, callback);\ninstallLoader(info);\n//进入createLoader方法：\nLoaderInfo info = new LoaderInfo(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);\nLoader&lt;Object&gt; loader = callback.onCreateLoader(id, args);\n//关键方法出现了！LoadManager接口的抽象方法的onCreateLoader方法被回调了！\n//然后installLoader方法启动了这个Loader！\ninfo.start();\n</code></pre>\n<p>进入<code>ContactEntryListFragment</code>的<code>onCreateLoader</code>方法，位于<code>DefaultContactBrowseListFragment</code>的祖父类<code>ContactEntryListFragment</code>中：</p>\n<pre><code class=\"java\">CursorLoader loader = createCursorLoader(mContext);//创建Loader\nmAdapter.configureLoader(loader, directoryId);//配置Loader\n</code></pre>\n<p>发现在此方法中，首先调用<code>createCursorLoader</code>方法创建了<code>Loader</code>。<br>然后通过<code>configureLoader</code>方法配置<code>Loader</code>的<code>query</code>方法的查询参数，也就是配置SQL中select查询语句的参数。<br>这也同时意味着，<code>ContactEntryListFragment</code>类的子类们可以重写<code>createCursorLoader</code>方法以提供适合自身的Loader，重写<code>configureLoader</code>方法为Loader配置合适的参数，适配各种自定义的查询获取数据。</p>\n<p>观察<code>createCursorLoader</code>方法在<code>DefaultContactBrowseListFragment</code>类中实现：</p>\n<pre><code class=\"java\">return new ProfileAndContactsLoader(context);\n</code></pre>\n<p>直接返回了<code>DefaultContactBrowseListFragment</code>的数据加载器：<code>ProfileAndContactsLoader</code><br>这就是<code>DefaultContactBrowseListFragment</code>的Loader实现类（数据加载器）。</p>\n<p>然后再看一下<code>ProfileAndContactsLoader</code>类是如何加载数据的呢？<br>发现它继承自<code>CursorLoader</code>，而<code>CursorLoader</code>又继承自<code>AsyncTaskLoader&lt;D&gt;</code><br>在关键的<code>LoadBackGround()</code>方法中：<br>异步调用了ContentResolver的<code>query</code>方法：</p>\n<pre><code class=\"java\">Cursor cursor = getContext()\n.getContentResolver()\n.query(mUri, mProjection, mSelection,\n                    mSelectionArgs, mSortOrder, mCancellationSignal);\ncursor.registerContentObserver(mObserver);\n</code></pre>\n<p>通过这个Query方法，实现了对联系人数据的查询,返回Cursor数据。并绑定了数据监听器。</p>\n<p>那么问题来了</p>\n<pre><code class=\"java\">query(mUri, mProjection, mSelection,mSelectionArgs, mSortOrder, mCancellationSignal)\n</code></pre>\n<p>的这些参数那里指定的呢？<br><code>configureLoader</code>方法在<code>DefaultContactListAdapter</code>类中实现，实现了对<code>query</code>参数的配置：</p>\n<pre><code class=\"java\">configureUri(loader, directoryId, filter);\nloader.setProjection(getProjection(false));\nconfigureSelection(loader, directoryId, filter);\nloader.setSortOrder(sortOrder);\n</code></pre>\n<p>可以看到，配置了Loader主要的几个参数：Uri，Projection，Selection，SortOrder。<br>这些参数用于最后和ContactsProvider交互的方法Query方法中……</p>\n<p>最终查询<code>ContactsProvider2</code>的uri是：</p>\n<pre><code class=\"xml\">Uri：content://com.android.contacts/contacts?address_book_index_extras=true&amp;directory=0\n</code></pre>\n<p>发现ContentProvider的服务类似一个网站，uri就是网址，而请求数据的方式类似使用Get方式获取数据。</p>\n<p>最后通过ContentProvider2构建的查询语句是这样的：</p>\n<pre><code class=\"sql\">SELECT \n_id, display_name, agg_presence.mode AS contact_presence, \ncontacts_status_updates.status AS contact_status, photo_id, photo_thumb_uri, lookup, \nis_user_profile \nFROM view_contacts \nLEFT OUTER JOIN agg_presence ON (_id = agg_presence.presence_contact_id) LEFT OUTER JOIN \nstatus_updates contacts_status_updates ON\n(status_update_id=contacts_status_updates.status_update_data_id)\n</code></pre>\n<p>可以发现最后通过ContactsProvider2实现的查询，并不是直接查询相关的表（Contacts表、rawcontacts表，data表……），而是直接查询<code>view_contacts</code>视图，因为这样会有更加高的效率。<br>这也就意味着如果想给联系人数据库新增一个字段供界面使用，仅修改对应的表结构是不行，还要修改对应的视图才能得到想要的效果。</p>\n<p>查询完毕后，回调<code>LoaderManager</code>的<code>onLoadFinished</code>方法，完成对UI界面的更新：</p>\n<pre><code class=\"java\">onPartitionLoaded(loaderId, data);\n</code></pre>\n<p>接着进入<code>onPartitionLoaded</code>方法：</p>\n<pre><code class=\"java\">mAdapter.changeCursor(partitionIndex, data);\n</code></pre>\n<p>进入这个<code>changeCursor</code>方法：</p>\n<pre><code class=\"java\">mPartitions[partition].cursor = cursor;\nnotifyDataSetChanged();\n</code></pre>\n<p>发现在这里改变了<code>Adapter</code>的数据集<code>Cursor</code>，并发出通知数据已经改变，UI进行更新。</p>\n<p>至此，默认联系人数据的显示分析到此结束。</p>\n<p>其他<code>Fragment</code>的数据填充基本仍然类似此流程，所不同的只是各自的<code>Fragment</code>、<code>Adapter</code>、<code>CursorLoader</code>以及<code>CursorLoader</code>配置的参数（uri，projection,selection,args,order……）有所不同。</p>\n<p>可以参考下表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Fragment</th>\n<th style=\"text-align:center\">Adapter</th>\n<th style=\"text-align:center\">CursorLoader</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">DefaultContactBrowseListFragment(默认联系人列表)</td>\n<td style=\"text-align:center\">DefaultContactListAdapter</td>\n<td style=\"text-align:center\">ProfileAndContactsLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ContactTitleListFragment(收藏联系人列表)</td>\n<td style=\"text-align:center\">ContactTileAdapter</td>\n<td style=\"text-align:center\">ContactTileLoaderFactory StarredLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ContactTitleFrequentFragment(常用联系人列表)</td>\n<td style=\"text-align:center\">ContactTitleAdapter</td>\n<td style=\"text-align:center\">ContactTileLoaderFactory FrequentLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GroupBrowseListFragment(群组列表)</td>\n<td style=\"text-align:center\">GroupBrowseLIstAdapter</td>\n<td style=\"text-align:center\">GroupListLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GroupDetailFragment(指定ID群组的联系人列表)</td>\n<td style=\"text-align:center\">GroupMemberTileAdapter</td>\n<td style=\"text-align:center\">GroupMemberLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ContactDetailFragment(指定ID联系人信息)</td>\n<td style=\"text-align:center\">ViewAdapter</td>\n<td style=\"text-align:center\">ContactLoader</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-1-2-联系人详细信息数据的显示\"><a href=\"#3-1-2-联系人详细信息数据的显示\" class=\"headerlink\" title=\"3.1.2 联系人详细信息数据的显示\"></a>3.1.2 联系人详细信息数据的显示</h4><p><strong>关键类：</strong></p>\n<pre><code class=\"java\">ContactDetailActivity\n\nContactDetailFragment  \n\nContactLoaderFragment //不可见 负责加载联系人详细数据，集成LoadManager对象。\n\nContactLoader   //联系人详细信息Loader。\n\nContactDetailLayoutController     //布局控制类。\n</code></pre>\n<p>原理类似列表显示，如下简要说明： </p>\n<pre><code class=\"xml\">* ContactLoaderFragment类创建了一个实现LoaderManager.LoaderCallbacks&lt;Contact&gt;接口的对象，数据类型指定为Contacts。负责创建、管理ContactLoader。\n\n* 得到当前用户选择的联系人URI，配置对应的ContactLoader。 \n\n* 后台数据查询完毕后，回调LoadManager的onLoadFinished()方法，并将数据以Contacts的数据类型返回，然后回调ContactDetailLoaderFragmentListener的onDetailsLoaded()方法。 \n\n* onDetailsLoaded()方法中，新开一个线程，通过ContactDetailLayoutController类的setContactData(Conatct)设置数据，刷新ContactDetailFragment。\n</code></pre>\n<h3 id=\"3-2-联系人数据的编辑和存储\"><a href=\"#3-2-联系人数据的编辑和存储\" class=\"headerlink\" title=\"3.2 联系人数据的编辑和存储\"></a>3.2 联系人数据的编辑和存储</h3><h4 id=\"3-2-1-编辑界面相关\"><a href=\"#3-2-1-编辑界面相关\" class=\"headerlink\" title=\"3.2.1 编辑界面相关\"></a>3.2.1 编辑界面相关</h4><p>联系人数据所属的账号不同，加载的UI也是不同的，比如Sim卡联系人一般只有name，phone num，但是本地账号联系人可能就会有email，</p>\n<p>address，website等信息…… </p>\n<p>联系人数据UI的加载是通过代码动态加载的，而不是xml文件写死的。</p>\n<p>那么问题来了， </p>\n<p>新建联系人的界面是如何设计？ </p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019034-3bc9de0a-9f10-11e8-8f38-f764c64cc8e2.jpeg\" alt=\"\"></p>\n<p>先进入新建联系人界面：</p>\n<p>主界面PeopleActivity中点击新建联系人Button，触发onOptionsItemSelected方法中的</p>\n<p>case R.id.menu_add_contact分支： </p>\n<p>执行<code>startActivity(intent);</code> </p>\n<p>startActivity启动Intent，Intent的Action设置为android.intent.action.INSERT </p>\n<p>找到匹配此Action的Activity：<code>ContactEditorActivity</code></p>\n<p><code>ContactEditorActivity</code>的布局文件：</p>\n<p><code>ContactEditorActivity</code>的<code>onCreate()</code>方法中找到布局： </p>\n<p><code>setContentView(R.layout.contact_editor_activity);</code></p>\n<p>在xml文件中找到这个布局：</p>\n<pre><code class=\"xml\">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n &lt;fragment class=&quot;com.android.contacts.editor.ContactEditorFragment&quot;\n            android:id=&quot;@+id/contact_editor_fragment&quot;\n            android:layout_width=&quot;match_parent&quot;\n            android:layout_height=&quot;match_parent&quot; /&gt;\n&lt;/FrameLayout&gt;\n</code></pre>\n<p>只包含一个Fragment：<code>ContactEditorFragment</code>。程序解析Xml文件到这里就会执行<code>ContactEditorFragment</code>类。</p>\n<p>进入<code>ContactEditorFragment</code>的<code>onCreateView</code>方法：</p>\n<pre><code class=\"xml\">//展开布局 \nfinal View view\n= inflater.inflate(R.layout.contact_editor_fragment, container, false);    \n//找到布局中的一个线性布局\n//关键的布局是contact_editor_fragment中的一个iD为editors的线性布局！\nmContent = (LinearLayout) view.findViewById(R.id.editors);\n</code></pre>\n<p>找到<code>contact_editor_fragment</code>：</p>\n<pre><code class=\"xml\">&lt;ScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:fillViewport=&quot;true&quot;\n    android:fadingEdge=&quot;none&quot;\n    android:background=&quot;@color/background_primary&quot;\n&gt;\n    &lt;LinearLayout android:id=&quot;@+id/editors&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:orientation=&quot;vertical&quot;\n    /&gt;\n&lt;/ScrollView&gt;\n</code></pre>\n<p>于是确认ContactEditorFragment的根布局就是一个id为editors的LinearLayout。<br>想到上一步的语句：</p>\n<pre><code class=\"xml\">mContent = (LinearLayout) view.findViewById(R.id.editors);\n</code></pre>\n<p>所以关键就在于，接下来在代码中为mContent这个线性布局动态添加地了什么UI，而这些UI才是真正显示的东西。</p>\n<p><code>ContactEditorFragment</code>的<code>onCreateView</code>方法执行完毕之后，会调用<code>onActivityCreate()</code>方法：</p>\n<pre><code class=\"java\">if (Intent.ACTION_INSERT.equals(mAction)) {\nfinal Account account = mIntentExtras == null ? null : (Account) \nmIntentExtbindEditorsForNewContactras.getParcelable(Intents.Insert.ACCOUNT);\nfinal String dataSet = mIntentExtras == null ? null :\n                        mIntentExtras.getString(Intents.Insert.DATA_SET);\nif (account != null) {\n// Account specified in Intent\ncreateContact(new AccountWithDataSet(account.name, account.type, dataSet));\n}\n</code></pre>\n<p>上面代码首先取出了当前Account信息，数据信息。封装为一个AccountWithDataSet对象，作为createContact方法的参数。之前我们分析过，编辑界面和账户是高度相关的，所以对UI的动态操作必然和Account对象相关。进入createContact方法。</p>\n<p>看一下ContactEditorFragment中的createContact()到底对界面干了什么！！ </p>\n<p>createContact方法中调用了bindEditorsForNewContact(account, accountType): </p>\n<p>关键代码：</p>\n<pre><code class=\"java\">……\nfinal RawContact rawContact = new RawContact();\n        if (newAccount != null) {\n            rawContact.setAccount(newAccount);\n        } else {\n            rawContact.setAccountToLocal();\n        }\nfinal ValuesDelta valuesDelta = ValuesDelta.fromAfter(rawContact.getValues());\nfinal RawContactDelta insert = new RawContactDelta(valuesDelta);\n……\nmState.add(insert);\nbindEditors();\n</code></pre>\n<p>数据存储相关</p>\n<h3 id=\"3-3-Sim联系人数据的整合\"><a href=\"#3-3-Sim联系人数据的整合\" class=\"headerlink\" title=\"3.3 Sim联系人数据的整合\"></a>3.3 Sim联系人数据的整合</h3><p>Sim卡联系人数据的显示<br>开机自动导入Sim卡联系人<br>telephony中IccProvider浅析<br>Sim卡联系人的手动导入导出</p>\n<h3 id=\"3-4-SD卡备份-恢复联系人\"><a href=\"#3-4-SD卡备份-恢复联系人\" class=\"headerlink\" title=\"3.4 SD卡备份/恢复联系人\"></a>3.4 SD卡备份/恢复联系人</h3><ul>\n<li>SD卡备份/恢复联系人</li>\n<li>联系人数据导出到SD卡</li>\n</ul>\n<h3 id=\"3-5-联系人搜索\"><a href=\"#3-5-联系人搜索\" class=\"headerlink\" title=\"3.5 联系人搜索\"></a>3.5 联系人搜索</h3><h3 id=\"3-6-Google联系人同步\"><a href=\"#3-6-Google联系人同步\" class=\"headerlink\" title=\"3.6 Google联系人同步\"></a>3.6 Google联系人同步</h3><h3 id=\"3-7-其他零碎功能\"><a href=\"#3-7-其他零碎功能\" class=\"headerlink\" title=\"3.7 其他零碎功能\"></a>3.7 其他零碎功能</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h2><p>联系人模块主要记录用户的联系人数据，方便用户快捷的操作和使用，主要包括本机联系人和Sim卡联系人。</p>\n<p>本机联系人主要存储在手机内部存储空间，Android平台上是通过数据库进行存储，使用ContentProvider组件封装，提供复杂的字段用于表示联系人数据，并提供用户快捷的操作，比如增加，删除，修改，查询等等。</p>\n<p>Sim卡联系人主要存储在Sim卡内部存储文件，包括adn、fdn、sdn。主要提供简单的字段用于表示联系人数据。并通过IccProvider提供的接口进行数据的增加、删除、修改、查询操作。</p>\n<h2 id=\"2-软件架构\"><a href=\"#2-软件架构\" class=\"headerlink\" title=\"2.软件架构\"></a>2.软件架构</h2><p>联系人Contacts应用主要包括3个部分:<br>Contacts主要响应用户的请求和交互，数据显示。<br>ContactsProvider继承自Android四大组件之一的ContentProvider组件，封装了对底层数据库contact2.db的添删改查。<br>SQLite在底层物理性地存储了联系人数据。</p>\n<p>主要交互流程如下图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019032-3b7392de-9f10-11e8-8567-d4189730b46e.png\" alt=\"\"></p>\n<p>Contacts模块的主要7块功能：</p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019045-3d496fe8-9f10-11e8-8077-89235449ccd4.png\" alt=\"\"></p>\n<h2 id=\"3-各功能模块分析\"><a href=\"#3-各功能模块分析\" class=\"headerlink\" title=\"3. 各功能模块分析\"></a>3. 各功能模块分析</h2><h3 id=\"3-1-联系人数据的显示\"><a href=\"#3-1-联系人数据的显示\" class=\"headerlink\" title=\"3.1 联系人数据的显示\"></a>3.1 联系人数据的显示</h3><h4 id=\"3-1-1-联系人列表显示\"><a href=\"#3-1-1-联系人列表显示\" class=\"headerlink\" title=\"3.1.1 联系人列表显示\"></a>3.1.1 联系人列表显示</h4><p><code>简要说明：</code></p>\n<pre><code class=\"xml\">* PeopleActivity类负责联系人列表的显示。\n\n* PeopleActivity包含4个Fragment，每个Fragment包含一个ListView。\n\n* 各个Fragment中ListView的Adapter（BaseAdapter的子类）负责将数据填充到ListView。\n\n* 各个Fragment的Loader类（CursorLoader的子类）负责加载数据。\n\n* 实现LoadertManager接口负责管理这些CursorLoader。\n</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019049-3dc1ee1e-9f10-11e8-89f3-14dac608ea42.png\" alt=\"\"></p>\n<p><strong>为什么使用Loader？</strong></p>\n<pre><code class=\"xml\">1. Loaders确保所有的cursor操作是异步的，从而排除了UI线程中堵塞的可能性。\n2. 当通过LoaderManager来管理，Loaders还可以在activity实例中保持当前的cursor数据，也就是不需要重新查询（比如，当因为横竖屏切换需要重新启动activity时）。\n3. 当数据改变时，Loaders可以自动检测底层数据的更新和重新检索。\n</code></pre>\n<p><strong>数据加载流程概览：</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019046-3d7130f0-9f10-11e8-945c-7a0eff02b65c.png\" alt=\"\"></p>\n<p><strong>流程具体分析：</strong></p>\n<p>先上图：<br><img src=\"https://user-images.githubusercontent.com/35097187/44019033-3ba1bba0-9f10-11e8-94f9-e41053c967b4.jpeg\" alt=\"\"></p>\n<p>进入Contacts应用，程序的主入口Activity是<code>PeopleActivity</code>。</p>\n<p>进入<code>onCreate</code>方法：</p>\n<p><code>createViewsAndFragments(savedState);</code></p>\n<p>此方法创建视图和Fragments，进入此方法：</p>\n<pre><code class=\"java\">mFavoritesFragment = new ContactTileListFragment();\nmAllFragment = new DefaultContactBrowseListFragment();\nmGroupsFragment = new GroupBrowseListFragment();\n</code></pre>\n<p>发现创建了3个Fragment，分别是 收藏联系人列表、所有联系人列表、群组列表。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>：</p>\n<p>发现<code>DefaultContactBrowseListFragment</code>的祖父类是：</p>\n<p><code>ContactEntryListFragment&lt;T extends ContactEntryListAdapter&gt;</code></p>\n<p>首先分析此基类：</p>\n<p>发现此基类实现了<code>LoadManager</code>接口，实现了该接口3个重要的抽象方法：</p>\n<pre><code class=\"java\">public Loader&lt;D&gt; onCreateLoader(int id, Bundle args);//创建Loader\npublic void onLoadFinished(Loader&lt;D&gt; loader, D data);//数据加载完毕后的回调方法\npublic void onLoaderReset(Loader&lt;D&gt; loader);//数据重新加载\n</code></pre>\n<p>该类同时提供了重要的抽象方法：</p>\n<pre><code class=\"java\">protected abstract T createListAdapter();//创建适配器Adapter类。\n</code></pre>\n<p>这意味着,子类可以按需求创造自己的适配器Adapter类,完成各个子界面Listview的数据显示，如3.1节图1所示。</p>\n<p>然后回到<code>DefaultContactBrowseListFragment</code>类：</p>\n<p>在执行<code>onCreateView</code>之前，会执行父类的一些方法，顺序如下：</p>\n<pre><code class=\"java\">onAttach()\nsetContext(activity);\nsetLoaderManager(super.getLoaderManager());\n</code></pre>\n<p><code>setLoaderManager</code>中设置当前的LoaderManager实现类。 </p>\n<p>加载联系人列表数据的过程中，这个类是<code>ProfileandContactsLoader</code>。</p>\n<p>之后执行<code>onCreate</code>方法。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>onCreate(Bundle)</code>方法：</p>\n<pre><code class=\"java\">mAdapter = createListAdapter();\n</code></pre>\n<p>发现在这里创建了<code>ListAdapter</code>：</p>\n<pre><code class=\"java\">DefaultContactListAdapter adapter = \nnew DefaultContactListAdapter(getContext());\n</code></pre>\n<p>可以知道创建的<code>ListAdapter</code>类型是<code>DefaultContactListAdapter</code>并返回到<code>DefaultContactBrowseListFragment</code>类。</p>\n<p>执行完<code>onCreate</code>方法之后，</p>\n<p>执行<code>DefaultContactBrowseListFragment</code>的<code>onCreateView</code>方法。</p>\n<p>进入DefaultContactBrowseListFragment的onCreateView方法：</p>\n<pre><code class=\"java\">mListView = (ListView)mView.findViewById(android.R.id.list);\nmListView.setAdapter(mAdapter);\n</code></pre>\n<p>首先获取了ListView用以填充联系人数据，然后设置了适配器，但是此时适配器中的数据是空的，直到后面才会加载数据更新UI。<br>在<code>onCreateView</code>方法执行完之后，在UI可见之前回调执行<code>Activity</code>的<code>onStart</code>方法。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>onStart</code>方法：</p>\n<pre><code class=\"java\">mContactsPrefs.registerChangeListener(mPreferencesChangeListener);\nstartLoading();\n</code></pre>\n<p>首先注册了一个<code>ContentObserv</code>e的子类监听数据变化。<br>然后执行<code>startLoading</code>方法，<strong>目测这应当就是开始加载数据的方法了！</strong></p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>startLoading</code>方法：</p>\n<pre><code class=\"java\">int partitionCount = mAdapter.getPartitionCount();\nfor (int i = 0; i &lt; partitionCount; i++) {\n……\nPartition partition = mAdapter.getPartition(i);\nstartLoadingDirectoryPartition(i);\n……}\n</code></pre>\n<p><code>Partition</code>这个类持有一个<code>Cursor</code>对象，用来存储数据。<br><code>Adapter</code>持有的<code>Partition</code>，<code>Partition</code>类代表了当前需要加载的<code>Directory</code>，可以理解为一个联系人集合，比如说本地联系人、Google联系人……这里我们假设只加载本地联系人数据，所以<code>partitionCount=1</code>。</p>\n<p>从这里我们可以做出猜测：<br>联系人数据不是想象中的分页（每次N条联系人数据）加载，也不是说一次性全部加载，而是一个账户一个账户加载联系人数据，加载完毕一个账户就在uI刷新并显示数据。</p>\n<p>进入<code>DefaultContactBrowseListFragment</code>的<code>startLoadingDirectoryPartition</code>方法：</p>\n<pre><code class=\"java\">loadDirectoryPartition(partitionIndex, partition);\n</code></pre>\n<p>进入此方法：</p>\n<pre><code class=\"java\">getLoaderManager().restartLoader(partitionIndex, args, this);\n</code></pre>\n<p>这个方法是LoaderManager实现类的方法，参照文档解释：</p>\n<blockquote>\n<p>这个方法会新建/重启一个当前LoaderManager中的Loader，将回调方法注册给他，并开始加载数据。也就是说会回调LoaderManager的onCreateLoader()方法。<br>Starts a new or restarts an existing android.content.Loader in this manager, registers the callbacks to it, and (if the activity/fragment is currently started) starts loading it</p>\n</blockquote>\n<p>进入<code>LoadManager</code>接口的实现类：<code>LoaderManagerImpl</code>的<code>restartLoader</code>方法内部：</p>\n<pre><code class=\"java\">LoaderInfo info = mLoaders.get(id);\nCreate info=\ncreateAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);\n//进入createAndInstallLoader方法：\nLoaderInfo info = createLoader(id, args, callback);\ninstallLoader(info);\n//进入createLoader方法：\nLoaderInfo info = new LoaderInfo(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);\nLoader&lt;Object&gt; loader = callback.onCreateLoader(id, args);\n//关键方法出现了！LoadManager接口的抽象方法的onCreateLoader方法被回调了！\n//然后installLoader方法启动了这个Loader！\ninfo.start();\n</code></pre>\n<p>进入<code>ContactEntryListFragment</code>的<code>onCreateLoader</code>方法，位于<code>DefaultContactBrowseListFragment</code>的祖父类<code>ContactEntryListFragment</code>中：</p>\n<pre><code class=\"java\">CursorLoader loader = createCursorLoader(mContext);//创建Loader\nmAdapter.configureLoader(loader, directoryId);//配置Loader\n</code></pre>\n<p>发现在此方法中，首先调用<code>createCursorLoader</code>方法创建了<code>Loader</code>。<br>然后通过<code>configureLoader</code>方法配置<code>Loader</code>的<code>query</code>方法的查询参数，也就是配置SQL中select查询语句的参数。<br>这也同时意味着，<code>ContactEntryListFragment</code>类的子类们可以重写<code>createCursorLoader</code>方法以提供适合自身的Loader，重写<code>configureLoader</code>方法为Loader配置合适的参数，适配各种自定义的查询获取数据。</p>\n<p>观察<code>createCursorLoader</code>方法在<code>DefaultContactBrowseListFragment</code>类中实现：</p>\n<pre><code class=\"java\">return new ProfileAndContactsLoader(context);\n</code></pre>\n<p>直接返回了<code>DefaultContactBrowseListFragment</code>的数据加载器：<code>ProfileAndContactsLoader</code><br>这就是<code>DefaultContactBrowseListFragment</code>的Loader实现类（数据加载器）。</p>\n<p>然后再看一下<code>ProfileAndContactsLoader</code>类是如何加载数据的呢？<br>发现它继承自<code>CursorLoader</code>，而<code>CursorLoader</code>又继承自<code>AsyncTaskLoader&lt;D&gt;</code><br>在关键的<code>LoadBackGround()</code>方法中：<br>异步调用了ContentResolver的<code>query</code>方法：</p>\n<pre><code class=\"java\">Cursor cursor = getContext()\n.getContentResolver()\n.query(mUri, mProjection, mSelection,\n                    mSelectionArgs, mSortOrder, mCancellationSignal);\ncursor.registerContentObserver(mObserver);\n</code></pre>\n<p>通过这个Query方法，实现了对联系人数据的查询,返回Cursor数据。并绑定了数据监听器。</p>\n<p>那么问题来了</p>\n<pre><code class=\"java\">query(mUri, mProjection, mSelection,mSelectionArgs, mSortOrder, mCancellationSignal)\n</code></pre>\n<p>的这些参数那里指定的呢？<br><code>configureLoader</code>方法在<code>DefaultContactListAdapter</code>类中实现，实现了对<code>query</code>参数的配置：</p>\n<pre><code class=\"java\">configureUri(loader, directoryId, filter);\nloader.setProjection(getProjection(false));\nconfigureSelection(loader, directoryId, filter);\nloader.setSortOrder(sortOrder);\n</code></pre>\n<p>可以看到，配置了Loader主要的几个参数：Uri，Projection，Selection，SortOrder。<br>这些参数用于最后和ContactsProvider交互的方法Query方法中……</p>\n<p>最终查询<code>ContactsProvider2</code>的uri是：</p>\n<pre><code class=\"xml\">Uri：content://com.android.contacts/contacts?address_book_index_extras=true&amp;directory=0\n</code></pre>\n<p>发现ContentProvider的服务类似一个网站，uri就是网址，而请求数据的方式类似使用Get方式获取数据。</p>\n<p>最后通过ContentProvider2构建的查询语句是这样的：</p>\n<pre><code class=\"sql\">SELECT \n_id, display_name, agg_presence.mode AS contact_presence, \ncontacts_status_updates.status AS contact_status, photo_id, photo_thumb_uri, lookup, \nis_user_profile \nFROM view_contacts \nLEFT OUTER JOIN agg_presence ON (_id = agg_presence.presence_contact_id) LEFT OUTER JOIN \nstatus_updates contacts_status_updates ON\n(status_update_id=contacts_status_updates.status_update_data_id)\n</code></pre>\n<p>可以发现最后通过ContactsProvider2实现的查询，并不是直接查询相关的表（Contacts表、rawcontacts表，data表……），而是直接查询<code>view_contacts</code>视图，因为这样会有更加高的效率。<br>这也就意味着如果想给联系人数据库新增一个字段供界面使用，仅修改对应的表结构是不行，还要修改对应的视图才能得到想要的效果。</p>\n<p>查询完毕后，回调<code>LoaderManager</code>的<code>onLoadFinished</code>方法，完成对UI界面的更新：</p>\n<pre><code class=\"java\">onPartitionLoaded(loaderId, data);\n</code></pre>\n<p>接着进入<code>onPartitionLoaded</code>方法：</p>\n<pre><code class=\"java\">mAdapter.changeCursor(partitionIndex, data);\n</code></pre>\n<p>进入这个<code>changeCursor</code>方法：</p>\n<pre><code class=\"java\">mPartitions[partition].cursor = cursor;\nnotifyDataSetChanged();\n</code></pre>\n<p>发现在这里改变了<code>Adapter</code>的数据集<code>Cursor</code>，并发出通知数据已经改变，UI进行更新。</p>\n<p>至此，默认联系人数据的显示分析到此结束。</p>\n<p>其他<code>Fragment</code>的数据填充基本仍然类似此流程，所不同的只是各自的<code>Fragment</code>、<code>Adapter</code>、<code>CursorLoader</code>以及<code>CursorLoader</code>配置的参数（uri，projection,selection,args,order……）有所不同。</p>\n<p>可以参考下表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Fragment</th>\n<th style=\"text-align:center\">Adapter</th>\n<th style=\"text-align:center\">CursorLoader</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">DefaultContactBrowseListFragment(默认联系人列表)</td>\n<td style=\"text-align:center\">DefaultContactListAdapter</td>\n<td style=\"text-align:center\">ProfileAndContactsLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ContactTitleListFragment(收藏联系人列表)</td>\n<td style=\"text-align:center\">ContactTileAdapter</td>\n<td style=\"text-align:center\">ContactTileLoaderFactory StarredLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ContactTitleFrequentFragment(常用联系人列表)</td>\n<td style=\"text-align:center\">ContactTitleAdapter</td>\n<td style=\"text-align:center\">ContactTileLoaderFactory FrequentLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GroupBrowseListFragment(群组列表)</td>\n<td style=\"text-align:center\">GroupBrowseLIstAdapter</td>\n<td style=\"text-align:center\">GroupListLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GroupDetailFragment(指定ID群组的联系人列表)</td>\n<td style=\"text-align:center\">GroupMemberTileAdapter</td>\n<td style=\"text-align:center\">GroupMemberLoader</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ContactDetailFragment(指定ID联系人信息)</td>\n<td style=\"text-align:center\">ViewAdapter</td>\n<td style=\"text-align:center\">ContactLoader</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-1-2-联系人详细信息数据的显示\"><a href=\"#3-1-2-联系人详细信息数据的显示\" class=\"headerlink\" title=\"3.1.2 联系人详细信息数据的显示\"></a>3.1.2 联系人详细信息数据的显示</h4><p><strong>关键类：</strong></p>\n<pre><code class=\"java\">ContactDetailActivity\n\nContactDetailFragment  \n\nContactLoaderFragment //不可见 负责加载联系人详细数据，集成LoadManager对象。\n\nContactLoader   //联系人详细信息Loader。\n\nContactDetailLayoutController     //布局控制类。\n</code></pre>\n<p>原理类似列表显示，如下简要说明： </p>\n<pre><code class=\"xml\">* ContactLoaderFragment类创建了一个实现LoaderManager.LoaderCallbacks&lt;Contact&gt;接口的对象，数据类型指定为Contacts。负责创建、管理ContactLoader。\n\n* 得到当前用户选择的联系人URI，配置对应的ContactLoader。 \n\n* 后台数据查询完毕后，回调LoadManager的onLoadFinished()方法，并将数据以Contacts的数据类型返回，然后回调ContactDetailLoaderFragmentListener的onDetailsLoaded()方法。 \n\n* onDetailsLoaded()方法中，新开一个线程，通过ContactDetailLayoutController类的setContactData(Conatct)设置数据，刷新ContactDetailFragment。\n</code></pre>\n<h3 id=\"3-2-联系人数据的编辑和存储\"><a href=\"#3-2-联系人数据的编辑和存储\" class=\"headerlink\" title=\"3.2 联系人数据的编辑和存储\"></a>3.2 联系人数据的编辑和存储</h3><h4 id=\"3-2-1-编辑界面相关\"><a href=\"#3-2-1-编辑界面相关\" class=\"headerlink\" title=\"3.2.1 编辑界面相关\"></a>3.2.1 编辑界面相关</h4><p>联系人数据所属的账号不同，加载的UI也是不同的，比如Sim卡联系人一般只有name，phone num，但是本地账号联系人可能就会有email，</p>\n<p>address，website等信息…… </p>\n<p>联系人数据UI的加载是通过代码动态加载的，而不是xml文件写死的。</p>\n<p>那么问题来了， </p>\n<p>新建联系人的界面是如何设计？ </p>\n<p><img src=\"https://user-images.githubusercontent.com/35097187/44019034-3bc9de0a-9f10-11e8-8f38-f764c64cc8e2.jpeg\" alt=\"\"></p>\n<p>先进入新建联系人界面：</p>\n<p>主界面PeopleActivity中点击新建联系人Button，触发onOptionsItemSelected方法中的</p>\n<p>case R.id.menu_add_contact分支： </p>\n<p>执行<code>startActivity(intent);</code> </p>\n<p>startActivity启动Intent，Intent的Action设置为android.intent.action.INSERT </p>\n<p>找到匹配此Action的Activity：<code>ContactEditorActivity</code></p>\n<p><code>ContactEditorActivity</code>的布局文件：</p>\n<p><code>ContactEditorActivity</code>的<code>onCreate()</code>方法中找到布局： </p>\n<p><code>setContentView(R.layout.contact_editor_activity);</code></p>\n<p>在xml文件中找到这个布局：</p>\n<pre><code class=\"xml\">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n &lt;fragment class=&quot;com.android.contacts.editor.ContactEditorFragment&quot;\n            android:id=&quot;@+id/contact_editor_fragment&quot;\n            android:layout_width=&quot;match_parent&quot;\n            android:layout_height=&quot;match_parent&quot; /&gt;\n&lt;/FrameLayout&gt;\n</code></pre>\n<p>只包含一个Fragment：<code>ContactEditorFragment</code>。程序解析Xml文件到这里就会执行<code>ContactEditorFragment</code>类。</p>\n<p>进入<code>ContactEditorFragment</code>的<code>onCreateView</code>方法：</p>\n<pre><code class=\"xml\">//展开布局 \nfinal View view\n= inflater.inflate(R.layout.contact_editor_fragment, container, false);    \n//找到布局中的一个线性布局\n//关键的布局是contact_editor_fragment中的一个iD为editors的线性布局！\nmContent = (LinearLayout) view.findViewById(R.id.editors);\n</code></pre>\n<p>找到<code>contact_editor_fragment</code>：</p>\n<pre><code class=\"xml\">&lt;ScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:fillViewport=&quot;true&quot;\n    android:fadingEdge=&quot;none&quot;\n    android:background=&quot;@color/background_primary&quot;\n&gt;\n    &lt;LinearLayout android:id=&quot;@+id/editors&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:orientation=&quot;vertical&quot;\n    /&gt;\n&lt;/ScrollView&gt;\n</code></pre>\n<p>于是确认ContactEditorFragment的根布局就是一个id为editors的LinearLayout。<br>想到上一步的语句：</p>\n<pre><code class=\"xml\">mContent = (LinearLayout) view.findViewById(R.id.editors);\n</code></pre>\n<p>所以关键就在于，接下来在代码中为mContent这个线性布局动态添加地了什么UI，而这些UI才是真正显示的东西。</p>\n<p><code>ContactEditorFragment</code>的<code>onCreateView</code>方法执行完毕之后，会调用<code>onActivityCreate()</code>方法：</p>\n<pre><code class=\"java\">if (Intent.ACTION_INSERT.equals(mAction)) {\nfinal Account account = mIntentExtras == null ? null : (Account) \nmIntentExtbindEditorsForNewContactras.getParcelable(Intents.Insert.ACCOUNT);\nfinal String dataSet = mIntentExtras == null ? null :\n                        mIntentExtras.getString(Intents.Insert.DATA_SET);\nif (account != null) {\n// Account specified in Intent\ncreateContact(new AccountWithDataSet(account.name, account.type, dataSet));\n}\n</code></pre>\n<p>上面代码首先取出了当前Account信息，数据信息。封装为一个AccountWithDataSet对象，作为createContact方法的参数。之前我们分析过，编辑界面和账户是高度相关的，所以对UI的动态操作必然和Account对象相关。进入createContact方法。</p>\n<p>看一下ContactEditorFragment中的createContact()到底对界面干了什么！！ </p>\n<p>createContact方法中调用了bindEditorsForNewContact(account, accountType): </p>\n<p>关键代码：</p>\n<pre><code class=\"java\">……\nfinal RawContact rawContact = new RawContact();\n        if (newAccount != null) {\n            rawContact.setAccount(newAccount);\n        } else {\n            rawContact.setAccountToLocal();\n        }\nfinal ValuesDelta valuesDelta = ValuesDelta.fromAfter(rawContact.getValues());\nfinal RawContactDelta insert = new RawContactDelta(valuesDelta);\n……\nmState.add(insert);\nbindEditors();\n</code></pre>\n<p>数据存储相关</p>\n<h3 id=\"3-3-Sim联系人数据的整合\"><a href=\"#3-3-Sim联系人数据的整合\" class=\"headerlink\" title=\"3.3 Sim联系人数据的整合\"></a>3.3 Sim联系人数据的整合</h3><p>Sim卡联系人数据的显示<br>开机自动导入Sim卡联系人<br>telephony中IccProvider浅析<br>Sim卡联系人的手动导入导出</p>\n<h3 id=\"3-4-SD卡备份-恢复联系人\"><a href=\"#3-4-SD卡备份-恢复联系人\" class=\"headerlink\" title=\"3.4 SD卡备份/恢复联系人\"></a>3.4 SD卡备份/恢复联系人</h3><ul>\n<li>SD卡备份/恢复联系人</li>\n<li>联系人数据导出到SD卡</li>\n</ul>\n<h3 id=\"3-5-联系人搜索\"><a href=\"#3-5-联系人搜索\" class=\"headerlink\" title=\"3.5 联系人搜索\"></a>3.5 联系人搜索</h3><h3 id=\"3-6-Google联系人同步\"><a href=\"#3-6-Google联系人同步\" class=\"headerlink\" title=\"3.6 Google联系人同步\"></a>3.6 Google联系人同步</h3><h3 id=\"3-7-其他零碎功能\"><a href=\"#3-7-其他零碎功能\" class=\"headerlink\" title=\"3.7 其他零碎功能\"></a>3.7 其他零碎功能</h3>"},{"title":"Build LineageOS for Nexus 5","date":"2018-01-05T04:05:21.000Z","_content":"\n## dependences\nTo build LineageOS, you’ll need:\n\nFor Ubuntu 14.04:\n`\nbc bison build-essential ccache curl flex g++-multilib gcc-multilib git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev libesd0-dev liblz4-tool libncurses5-dev libsdl1.2-dev libssl-dev libwxgtk2.8-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev\n`\n\nFor Ubuntu 16.04 (xenial), substitute:\n`\nlibwxgtk3.0-dev → libwxgtk2.8-dev\n`\n**Java**\nDifferent versions of LineageOS require different JDK (Java Development Kit) versions.\n\nLineageOS 14.1: OpenJDK 1.8 (install openjdk-8-jdk)\nLineageOS 11.0-13.0: OpenJDK 1.7 (install openjdk-7-jdk)\n\n**Enter the following to download the repo binary and make it executable (runnable):**\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\nchmod a+x ~/bin/repo\n\n\n## Get source code\n```bash\n$ repo init -u https://github.com/LineageOS/android.git -b cm-14.1\n$ repo sync\n```\n\n**Prepare the device-specific code**\n```bash\n$ source build/envsetup.sh\n$ breakfast hammerhead\n```\n\n\n\n**Turn on caching to speed up build**\n\nMake use of ccache if you want to speed up subsequent builds by running:\n```bash\n$ export USE_CCACHE=1\n```\nand adding that line to your ~/.bashrc file. Then, specify the maximum amount of disk space you want ccache to use by typing this:\n```bash\n$ ccache -M 50G\n```\n\n## 添加私有库\nvim .repo/local_manifests/lge.xml\n\n```\n<!-- nexus5 -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<manifest>\n  <project name=\"TheMuppets/proprietary_vendor_lge.git\" path=\"vendor/lge\" remote=\"github\" />\n</manifest>\n```\n\n```\n<!-- nexus6p -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<manifest>\n  <project name=\"TheMuppets/proprietary_vendor_huawei.git\" path=\"vendor/huawei\" remote=\"github\" />\n</manifest>\n```\n之后再 repo sync 一次。\n\n## 编译\n```bash\nexport WITH_SU=true //打开root\nbrunch hammerhead\n```\n\n## 刷机\n```bash\nadb reboot bootloader\nsource build/envsetup.sh\n\n#fastboot oem ramdump enable //如果bootloader download 模式未打开\nbreakfast hammerhead\nfastboot -w flashall\n```\n\nPS:\n关于科学上网:\n1.将repo文件 https://android.googlesource.com/ 全部使用 https://aosp.tuna.tsinghua.edu.cn/ 代替。\n2.替换已有的 AOSP 源代码的 remote，将 .repo/manifest.xml 把其中的 aosp 这个 remote 的 fetch 从 https://android.googlesource.com 改为 https://aosp.tuna.tsinghua.edu.cn/。\n```\n<manifest>\n   <remote  name=\"aosp\"\n-           fetch=\"https://android.googlesource.com\"\n+           fetch=\"https://aosp.tuna.tsinghua.edu.cn\"\n            review=\"android-review.googlesource.com\" />\n   <remote  name=\"github\"\n```\n同时，修改 .repo/manifests.git/config，将\n``\nurl = https://android.googlesource.com/platform/manifest\n``\n更改为\n``\nurl = https://aosp.tuna.tsinghua.edu.cn/platform/manifest\n``\n","source":"_posts/Android/为Nexus编译LineageOS.md","raw":"---\ntitle: 'Build LineageOS for Nexus 5'\npermalink: 'Build-LineageOS-for-Nexus-5'\ndate: 2018-01-05 12:05:21\ncategories:\n- Android\ntags:\n- android\n- cm\n- lineageos\n---\n\n## dependences\nTo build LineageOS, you’ll need:\n\nFor Ubuntu 14.04:\n`\nbc bison build-essential ccache curl flex g++-multilib gcc-multilib git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev libesd0-dev liblz4-tool libncurses5-dev libsdl1.2-dev libssl-dev libwxgtk2.8-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev\n`\n\nFor Ubuntu 16.04 (xenial), substitute:\n`\nlibwxgtk3.0-dev → libwxgtk2.8-dev\n`\n**Java**\nDifferent versions of LineageOS require different JDK (Java Development Kit) versions.\n\nLineageOS 14.1: OpenJDK 1.8 (install openjdk-8-jdk)\nLineageOS 11.0-13.0: OpenJDK 1.7 (install openjdk-7-jdk)\n\n**Enter the following to download the repo binary and make it executable (runnable):**\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\nchmod a+x ~/bin/repo\n\n\n## Get source code\n```bash\n$ repo init -u https://github.com/LineageOS/android.git -b cm-14.1\n$ repo sync\n```\n\n**Prepare the device-specific code**\n```bash\n$ source build/envsetup.sh\n$ breakfast hammerhead\n```\n\n\n\n**Turn on caching to speed up build**\n\nMake use of ccache if you want to speed up subsequent builds by running:\n```bash\n$ export USE_CCACHE=1\n```\nand adding that line to your ~/.bashrc file. Then, specify the maximum amount of disk space you want ccache to use by typing this:\n```bash\n$ ccache -M 50G\n```\n\n## 添加私有库\nvim .repo/local_manifests/lge.xml\n\n```\n<!-- nexus5 -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<manifest>\n  <project name=\"TheMuppets/proprietary_vendor_lge.git\" path=\"vendor/lge\" remote=\"github\" />\n</manifest>\n```\n\n```\n<!-- nexus6p -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<manifest>\n  <project name=\"TheMuppets/proprietary_vendor_huawei.git\" path=\"vendor/huawei\" remote=\"github\" />\n</manifest>\n```\n之后再 repo sync 一次。\n\n## 编译\n```bash\nexport WITH_SU=true //打开root\nbrunch hammerhead\n```\n\n## 刷机\n```bash\nadb reboot bootloader\nsource build/envsetup.sh\n\n#fastboot oem ramdump enable //如果bootloader download 模式未打开\nbreakfast hammerhead\nfastboot -w flashall\n```\n\nPS:\n关于科学上网:\n1.将repo文件 https://android.googlesource.com/ 全部使用 https://aosp.tuna.tsinghua.edu.cn/ 代替。\n2.替换已有的 AOSP 源代码的 remote，将 .repo/manifest.xml 把其中的 aosp 这个 remote 的 fetch 从 https://android.googlesource.com 改为 https://aosp.tuna.tsinghua.edu.cn/。\n```\n<manifest>\n   <remote  name=\"aosp\"\n-           fetch=\"https://android.googlesource.com\"\n+           fetch=\"https://aosp.tuna.tsinghua.edu.cn\"\n            review=\"android-review.googlesource.com\" />\n   <remote  name=\"github\"\n```\n同时，修改 .repo/manifests.git/config，将\n``\nurl = https://android.googlesource.com/platform/manifest\n``\n更改为\n``\nurl = https://aosp.tuna.tsinghua.edu.cn/platform/manifest\n``\n","slug":"Build-LineageOS-for-Nexus-5","published":1,"updated":"2018-08-08T03:27:04.534Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjks8knde0001xwujzm236n4u","content":"<h2 id=\"dependences\"><a href=\"#dependences\" class=\"headerlink\" title=\"dependences\"></a>dependences</h2><p>To build LineageOS, you’ll need:</p>\n<p>For Ubuntu 14.04:<br><code>bc bison build-essential ccache curl flex g++-multilib gcc-multilib git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev libesd0-dev liblz4-tool libncurses5-dev libsdl1.2-dev libssl-dev libwxgtk2.8-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev</code></p>\n<p>For Ubuntu 16.04 (xenial), substitute:<br><code>libwxgtk3.0-dev → libwxgtk2.8-dev</code><br><strong>Java</strong><br>Different versions of LineageOS require different JDK (Java Development Kit) versions.</p>\n<p>LineageOS 14.1: OpenJDK 1.8 (install openjdk-8-jdk)<br>LineageOS 11.0-13.0: OpenJDK 1.7 (install openjdk-7-jdk)</p>\n<p><strong>Enter the following to download the repo binary and make it executable (runnable):</strong><br>curl <a href=\"https://storage.googleapis.com/git-repo-downloads/repo\" target=\"_blank\" rel=\"noopener\">https://storage.googleapis.com/git-repo-downloads/repo</a> &gt; ~/bin/repo<br>chmod a+x ~/bin/repo</p>\n<h2 id=\"Get-source-code\"><a href=\"#Get-source-code\" class=\"headerlink\" title=\"Get source code\"></a>Get source code</h2><pre><code class=\"bash\">$ repo init -u https://github.com/LineageOS/android.git -b cm-14.1\n$ repo sync\n</code></pre>\n<p><strong>Prepare the device-specific code</strong></p>\n<pre><code class=\"bash\">$ source build/envsetup.sh\n$ breakfast hammerhead\n</code></pre>\n<p><strong>Turn on caching to speed up build</strong></p>\n<p>Make use of ccache if you want to speed up subsequent builds by running:</p>\n<pre><code class=\"bash\">$ export USE_CCACHE=1\n</code></pre>\n<p>and adding that line to your ~/.bashrc file. Then, specify the maximum amount of disk space you want ccache to use by typing this:</p>\n<pre><code class=\"bash\">$ ccache -M 50G\n</code></pre>\n<h2 id=\"添加私有库\"><a href=\"#添加私有库\" class=\"headerlink\" title=\"添加私有库\"></a>添加私有库</h2><p>vim .repo/local_manifests/lge.xml</p>\n<pre><code>&lt;!-- nexus5 --&gt;\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;manifest&gt;\n  &lt;project name=&quot;TheMuppets/proprietary_vendor_lge.git&quot; path=&quot;vendor/lge&quot; remote=&quot;github&quot; /&gt;\n&lt;/manifest&gt;\n</code></pre><pre><code>&lt;!-- nexus6p --&gt;\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;manifest&gt;\n  &lt;project name=&quot;TheMuppets/proprietary_vendor_huawei.git&quot; path=&quot;vendor/huawei&quot; remote=&quot;github&quot; /&gt;\n&lt;/manifest&gt;\n</code></pre><p>之后再 repo sync 一次。</p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><pre><code class=\"bash\">export WITH_SU=true //打开root\nbrunch hammerhead\n</code></pre>\n<h2 id=\"刷机\"><a href=\"#刷机\" class=\"headerlink\" title=\"刷机\"></a>刷机</h2><pre><code class=\"bash\">adb reboot bootloader\nsource build/envsetup.sh\n\n#fastboot oem ramdump enable //如果bootloader download 模式未打开\nbreakfast hammerhead\nfastboot -w flashall\n</code></pre>\n<p>PS:<br>关于科学上网:<br>1.将repo文件 <a href=\"https://android.googlesource.com/\" target=\"_blank\" rel=\"noopener\">https://android.googlesource.com/</a> 全部使用 <a href=\"https://aosp.tuna.tsinghua.edu.cn/\" target=\"_blank\" rel=\"noopener\">https://aosp.tuna.tsinghua.edu.cn/</a> 代替。<br>2.替换已有的 AOSP 源代码的 remote，将 .repo/manifest.xml 把其中的 aosp 这个 remote 的 fetch 从 <a href=\"https://android.googlesource.com\" target=\"_blank\" rel=\"noopener\">https://android.googlesource.com</a> 改为 <a href=\"https://aosp.tuna.tsinghua.edu.cn/。\" target=\"_blank\" rel=\"noopener\">https://aosp.tuna.tsinghua.edu.cn/。</a></p>\n<pre><code>&lt;manifest&gt;\n   &lt;remote  name=&quot;aosp&quot;\n-           fetch=&quot;https://android.googlesource.com&quot;\n+           fetch=&quot;https://aosp.tuna.tsinghua.edu.cn&quot;\n            review=&quot;android-review.googlesource.com&quot; /&gt;\n   &lt;remote  name=&quot;github&quot;\n</code></pre><p>同时，修改 .repo/manifests.git/config，将<br><code>url = https://android.googlesource.com/platform/manifest</code><br>更改为<br><code>url = https://aosp.tuna.tsinghua.edu.cn/platform/manifest</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"dependences\"><a href=\"#dependences\" class=\"headerlink\" title=\"dependences\"></a>dependences</h2><p>To build LineageOS, you’ll need:</p>\n<p>For Ubuntu 14.04:<br><code>bc bison build-essential ccache curl flex g++-multilib gcc-multilib git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev libesd0-dev liblz4-tool libncurses5-dev libsdl1.2-dev libssl-dev libwxgtk2.8-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev</code></p>\n<p>For Ubuntu 16.04 (xenial), substitute:<br><code>libwxgtk3.0-dev → libwxgtk2.8-dev</code><br><strong>Java</strong><br>Different versions of LineageOS require different JDK (Java Development Kit) versions.</p>\n<p>LineageOS 14.1: OpenJDK 1.8 (install openjdk-8-jdk)<br>LineageOS 11.0-13.0: OpenJDK 1.7 (install openjdk-7-jdk)</p>\n<p><strong>Enter the following to download the repo binary and make it executable (runnable):</strong><br>curl <a href=\"https://storage.googleapis.com/git-repo-downloads/repo\" target=\"_blank\" rel=\"noopener\">https://storage.googleapis.com/git-repo-downloads/repo</a> &gt; ~/bin/repo<br>chmod a+x ~/bin/repo</p>\n<h2 id=\"Get-source-code\"><a href=\"#Get-source-code\" class=\"headerlink\" title=\"Get source code\"></a>Get source code</h2><pre><code class=\"bash\">$ repo init -u https://github.com/LineageOS/android.git -b cm-14.1\n$ repo sync\n</code></pre>\n<p><strong>Prepare the device-specific code</strong></p>\n<pre><code class=\"bash\">$ source build/envsetup.sh\n$ breakfast hammerhead\n</code></pre>\n<p><strong>Turn on caching to speed up build</strong></p>\n<p>Make use of ccache if you want to speed up subsequent builds by running:</p>\n<pre><code class=\"bash\">$ export USE_CCACHE=1\n</code></pre>\n<p>and adding that line to your ~/.bashrc file. Then, specify the maximum amount of disk space you want ccache to use by typing this:</p>\n<pre><code class=\"bash\">$ ccache -M 50G\n</code></pre>\n<h2 id=\"添加私有库\"><a href=\"#添加私有库\" class=\"headerlink\" title=\"添加私有库\"></a>添加私有库</h2><p>vim .repo/local_manifests/lge.xml</p>\n<pre><code>&lt;!-- nexus5 --&gt;\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;manifest&gt;\n  &lt;project name=&quot;TheMuppets/proprietary_vendor_lge.git&quot; path=&quot;vendor/lge&quot; remote=&quot;github&quot; /&gt;\n&lt;/manifest&gt;\n</code></pre><pre><code>&lt;!-- nexus6p --&gt;\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;manifest&gt;\n  &lt;project name=&quot;TheMuppets/proprietary_vendor_huawei.git&quot; path=&quot;vendor/huawei&quot; remote=&quot;github&quot; /&gt;\n&lt;/manifest&gt;\n</code></pre><p>之后再 repo sync 一次。</p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><pre><code class=\"bash\">export WITH_SU=true //打开root\nbrunch hammerhead\n</code></pre>\n<h2 id=\"刷机\"><a href=\"#刷机\" class=\"headerlink\" title=\"刷机\"></a>刷机</h2><pre><code class=\"bash\">adb reboot bootloader\nsource build/envsetup.sh\n\n#fastboot oem ramdump enable //如果bootloader download 模式未打开\nbreakfast hammerhead\nfastboot -w flashall\n</code></pre>\n<p>PS:<br>关于科学上网:<br>1.将repo文件 <a href=\"https://android.googlesource.com/\" target=\"_blank\" rel=\"noopener\">https://android.googlesource.com/</a> 全部使用 <a href=\"https://aosp.tuna.tsinghua.edu.cn/\" target=\"_blank\" rel=\"noopener\">https://aosp.tuna.tsinghua.edu.cn/</a> 代替。<br>2.替换已有的 AOSP 源代码的 remote，将 .repo/manifest.xml 把其中的 aosp 这个 remote 的 fetch 从 <a href=\"https://android.googlesource.com\" target=\"_blank\" rel=\"noopener\">https://android.googlesource.com</a> 改为 <a href=\"https://aosp.tuna.tsinghua.edu.cn/。\" target=\"_blank\" rel=\"noopener\">https://aosp.tuna.tsinghua.edu.cn/。</a></p>\n<pre><code>&lt;manifest&gt;\n   &lt;remote  name=&quot;aosp&quot;\n-           fetch=&quot;https://android.googlesource.com&quot;\n+           fetch=&quot;https://aosp.tuna.tsinghua.edu.cn&quot;\n            review=&quot;android-review.googlesource.com&quot; /&gt;\n   &lt;remote  name=&quot;github&quot;\n</code></pre><p>同时，修改 .repo/manifests.git/config，将<br><code>url = https://android.googlesource.com/platform/manifest</code><br>更改为<br><code>url = https://aosp.tuna.tsinghua.edu.cn/platform/manifest</code></p>\n"},{"title":"合并重复联系人","date":"2018-01-16T02:00:00.000Z","_content":"\n## 1.搜索重复联系人\n\n```java\n//SearchDupActivity.java\n    @Override\n    protected Dialog onCreateDialog(int id) {\n        switch (id) {\n            case R.id.search_dup_dialog: {\n                mProgressDialog = initSearchingDialog();\n                DuplicatesUtils.setDialog(mProgressDialog);\n                Thread thread = new SearchDuplicatedThread();\n                DuplicatesUtils.mSearchState = true;\n                thread.start();\n                return mProgressDialog;\n            }\n        }\n        return super.onCreateDialog(id);\n    }\n```\n\n### 初始化search 界面\n\n```java\n//SearchDupActivity.java\n    private ProgressDialog initSearchingDialog() {\n        ProgressDialog dialog = new MyProgressDialog(this);\n        dialog.setMessage(this.getString(R.string.searching_duplicated_contacts));\n        dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n        dialog.setCanceledOnTouchOutside(false);\n        Cursor cursor = null;\n        int allCount = 0;\n        String selection = RawContacts.DELETED + \"= 0\";\n        try {\n            //计算progress total size（通过rawcontacts表查询，去除DELETED）\n            cursor = getContentResolver()\n                    .query(RawContacts.CONTENT_URI, RAWCONTACTS_ID_PROJECTION,\n                    selection, null, null);\n        } finally {\n            if (cursor != null) {\n                allCount = cursor.getCount();\n                cursor.close();\n            }\n        }\n        dialog.setMax(allCount);\n        return dialog;\n    }\n```\n\n***\n1.获取 account list\n2.计算 duplicate contacts 用于显示MergeContactActivity的数据\n3.查询完后，handler通知启动MergeContactActivity界面。\n***\n\n```java\n//SearchDupActivity.java\n    private class SearchDuplicatedThread extends Thread {\n        @Override\n        public void run() {\n            List<AccountWithDataSet> list = AccountTypeManager\n                    .getInstance(SearchDupActivity.this).getAccounts(true);\n            ArrayList<Account> accountsList = new ArrayList<>();\n            for (int i = 0; i < list.size(); i++) {\n                accountsList.add(list.get(i).getAccountOrNull());\n            }\n\n            /* calculate the contacts which can be merged. */\n            boolean isComplete = DuplicatesUtils\n                    .calculateMergeRawContacts(SearchDupActivity.this, accountsList,\n                            getContentResolver());\n            Message msg = Message.obtain();\n            if (isComplete) {\n                ArrayList<DuplicatesUtils.MergeContacts> mergeRawContacts =\n                        DuplicatesUtils.getMergeRawContacts();\n                if (mergeRawContacts != null && mergeRawContacts.size() > 0) {\n                    msg.what = FIND_DUPLICATED;\n                } else {\n                    msg.what = NO_DUPLICATED;\n                }\n                handler.sendMessage(msg);\n            }\n        }\n    }\n```\n\n***\n1.根据account 先进行区分\n2.根据account 查询 rawcontacts, 获取HashMap &lt;name(ignore大小写), list(rawcontacts ids)&gt;\n3.判定是否有dup contacts(list size 是否大于2)\n 判定是否可merge：\na。根据id in RawContactsEntity进行查询\nb。根据mimeType 组建mergePhoneList、mergeEmailList、photoid等\nc。构建ArrayList&lt;ContactsInfo&gt;\nd。构建ArrayList&lt;MergeContacts&gt; 对于sim contacts 进行额外判定。（MergeContacts:ContactsInfo ～ 1：n）\n4.progress 进度的更新\n***\n\n```java\n//DuplicatesUtils.java\n    public static boolean calculateMergeRawContacts(Context context, List<Account> accounts,\n        ContentResolver resolver) {\n        SimContactsOperation simContactsOperation = new SimContactsOperation(context);\n        mMergeRawContacts = new ArrayList<>();\n        int count = 0;\n        // contacts in different accounts are separated.\n        for (int i = 0; i < accounts.size() && mSearchState; i++) {\n            Account account = accounts.get(i);\n            HashMap<String, List<Long>> map = DuplicatesUtils.getRawNameWithIds(resolver,\n                    new String[]{account.name, account.type});\n            if (map != null && map.size() > 0) {\n                ArrayList<ContactsInfo> lst1;\n                Iterator<String> iterator = map.keySet().iterator();\n                while (mSearchState && iterator.hasNext()) {\n                    List<String> mergePhoneList = new ArrayList();\n                    List<String> mergeEmailList = new ArrayList();\n                    long contactId = -1;\n                    lst1 = new ArrayList<>();\n                    String keyName = iterator.next();\n                    List<Long> lst = map.get(keyName);\n                    if (lst.size() >= 2) {\n                        EntityIterator entityIterator = DuplicatesUtils.getEntityByIds(resolver,\n                                lst);\n                        if (entityIterator == null) {\n                            continue;\n                        }\n                        try {\n                            while (entityIterator.hasNext()) {\n                                ArrayList<String> phoneList = new ArrayList<>();\n                                ArrayList<String> emailList = new ArrayList<>();\n                                long photoId = 0;\n                                Entity next1 = entityIterator.next();\n                                ContentValues values = next1.getEntityValues();\n                                Long rawId = values.getAsLong(RawContacts._ID);\n                                String id = values.getAsString(RawContacts.CONTACT_ID);\n                                if (!TextUtils.isEmpty(id)) {\n                                    contactId = Long.parseLong(id);\n                                }\n                                Iterator<Entity.NamedContentValues> namedContentValuesIterator =\n                                        next1.getSubValues().iterator();\n                                while (namedContentValuesIterator.hasNext()) {\n                                    ContentValues values1 = namedContentValuesIterator\n                                            .next().values;\n                                    String mimeType = values1.getAsString(Data.MIMETYPE);\n                                    if (CommonDataKinds.StructuredName\n                                            .CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                        continue;\n                                    }\n                                    if (CommonDataKinds.Photo.CONTENT_ITEM_TYPE\n                                            .equals(mimeType)) {\n                                        photoId = values1.getAsLong(CommonDataKinds.Photo._ID)\n                                                .longValue();\n                                        continue;\n                                    }\n                                    if (CommonDataKinds.Phone.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                        String data1 = values1\n                                                .getAsString(CommonDataKinds.Phone.DATA1);\n                                        phoneList.add(data1);\n                                        if (!TextUtils.isEmpty(data1)\n                                                && !mergePhoneList.contains(data1)) {\n                                            boolean contains = false;\n                                            for (int j = 0; j < mergePhoneList.size(); j++) {\n                                                if (PhoneNumberUtils.compare(data1,\n                                                        mergePhoneList.get(j))) {\n                                                    contains = true;\n                                                    break;\n                                                }\n                                            }\n                                            if (!contains) {\n                                                mergePhoneList.add(data1);\n                                            }\n                                            continue;\n                                        }\n                                    }\n                                    if (CommonDataKinds.Email.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                        String email = values1\n                                                .getAsString(CommonDataKinds.Email.DATA1);\n                                        emailList.add(email);\n                                        if (!mergeEmailList.contains(email)) {\n                                            mergeEmailList.add(email);\n                                        }\n                                        continue;\n                                    }\n                                }\n                                Cursor cursor = resolver.query(Contacts.CONTENT_URI,\n                                        CONTACTS_PROJECTION, Contacts._ID.concat(\" = ?\"),\n                                        new String[]{String.valueOf(contactId)}, null);\n\n                                if (cursor != null && cursor.moveToNext()) {\n                                    String lookUp = cursor.getString(cursor\n                                            .getColumnIndex(Contacts.LOOKUP_KEY));\n                                    String displayName = cursor.getString(cursor.getColumnIndex(\n                                            Contacts.DISPLAY_NAME_PRIMARY));\n                                    lst1.add(new ContactsInfo(contactId, lookUp, photoId,\n                                            displayName, phoneList, emailList, rawId));\n                                    cursor.close();\n                                }\n                            }\n                        } finally {\n                            if (entityIterator != null) {\n                                entityIterator.close();\n                            }\n                        }\n                        // for sim contacts, analyse if it can be merged.\n                        if (contactId != -1\n                                && account.type.equals(SimContactsConstants.ACCOUNT_TYPE_SIM)) {\n                            int subscription = simContactsOperation.getSimSubscription(contactId);\n                            int oneSimAnrCount = MoreContactUtils.getOneSimAnrCount(\n                                    context, subscription);\n                            int oneSimEmailCount = MoreContactUtils\n                                    .getOneSimEmailCount(context, subscription);\n                            if (mergePhoneList.size() > oneSimAnrCount + 1\n                                    || mergeEmailList.size() > oneSimEmailCount) {\n                                continue;\n                            }\n                        }\n                        if (mMergeRawContacts != null) {\n                            mMergeRawContacts.add(\n                                new MergeContacts(account.name, account.type, lst1));\n                        }\n                    }\n                    count += lst.size();\n                    mProgressDialog.setProgress(count);\n                }\n            }\n        }\n        if (mSearchState) {\n            // search ended, change the flag.\n            mSearchState = false;\n            return true;\n        }\n        return false;\n    }\n```\n\n## 2.显示重复联系人\n\n***\n根据ArrayList&lt;MergeContacts&gt; 显示UI e.g. 根据mSelectCount 控制merge enanble或disable等\n***\n\n```java\n//MergeContactActivity.java\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id) {\n        MergeContactAdapter adapter = (MergeContactAdapter) l.getAdapter();\n        DuplicatesUtils.MergeContacts item = (DuplicatesUtils.MergeContacts) adapter\n                .getItem(position);\n        CheckBox cb = (CheckBox) v.findViewById(R.id.row_box);\n        // mark the mergeContacts item, which will be merged later, if true.\n        // calculate the selected count.\n        if (cb.isChecked() && item.isChecked()) {\n            cb.setChecked(false);\n            item.setChecked(false);\n            mSelectCount--;\n        } else {\n            cb.setChecked(true);\n            item.setChecked(true);\n            mSelectCount++;\n        }\n        // if the selected count is '0', disable the menuItem.\n        if (mSelectCount == 0 && mergeItem != null && mergeItem.isEnabled()) {\n            mergeItem.setEnabled(false);\n        } else if (mSelectCount > 0 && mergeItem != null && !mergeItem.isEnabled()) {\n            mergeItem.setEnabled(true);\n        }\n    }\n```\n\n## 3.合并重复联系人\n\n```java\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.menu_merge: {\n                mProgressDialog = new MyProgressDialog(MergeContactActivity.this);\n                mProgressDialog.setMessage(this.getString(R.string.merging_contacts));\n                mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n                Iterator<DuplicatesUtils.MergeContacts> iterator = mMergeList.iterator();\n                while (iterator.hasNext()) {\n                    DuplicatesUtils.MergeContacts next = iterator.next();\n                    if (!next.isChecked()) {\n                        iterator.remove();\n                    }\n                }\n                mProgressDialog.setMax(mMergeList.size());\n                mProgressDialog.setCancelable(false);\n                mProgressDialog.setCanceledOnTouchOutside(false);\n                mProgressDialog.show();\n                Thread thread = new MergeDuplicatedThread();\n                DuplicatesUtils.mMergeState = true;\n                thread.start();\n            }\n        }\n        return true;\n    }\n```\n","source":"_posts/Android/合并重复联系人.md","raw":"---\ntitle: 合并重复联系人\npermalink: merge-contacts\ncategories:\n  - Android\ntags:\n  - android\n  - contacts\ndate: 2018-01-16 10:00:00\n---\n\n## 1.搜索重复联系人\n\n```java\n//SearchDupActivity.java\n    @Override\n    protected Dialog onCreateDialog(int id) {\n        switch (id) {\n            case R.id.search_dup_dialog: {\n                mProgressDialog = initSearchingDialog();\n                DuplicatesUtils.setDialog(mProgressDialog);\n                Thread thread = new SearchDuplicatedThread();\n                DuplicatesUtils.mSearchState = true;\n                thread.start();\n                return mProgressDialog;\n            }\n        }\n        return super.onCreateDialog(id);\n    }\n```\n\n### 初始化search 界面\n\n```java\n//SearchDupActivity.java\n    private ProgressDialog initSearchingDialog() {\n        ProgressDialog dialog = new MyProgressDialog(this);\n        dialog.setMessage(this.getString(R.string.searching_duplicated_contacts));\n        dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n        dialog.setCanceledOnTouchOutside(false);\n        Cursor cursor = null;\n        int allCount = 0;\n        String selection = RawContacts.DELETED + \"= 0\";\n        try {\n            //计算progress total size（通过rawcontacts表查询，去除DELETED）\n            cursor = getContentResolver()\n                    .query(RawContacts.CONTENT_URI, RAWCONTACTS_ID_PROJECTION,\n                    selection, null, null);\n        } finally {\n            if (cursor != null) {\n                allCount = cursor.getCount();\n                cursor.close();\n            }\n        }\n        dialog.setMax(allCount);\n        return dialog;\n    }\n```\n\n***\n1.获取 account list\n2.计算 duplicate contacts 用于显示MergeContactActivity的数据\n3.查询完后，handler通知启动MergeContactActivity界面。\n***\n\n```java\n//SearchDupActivity.java\n    private class SearchDuplicatedThread extends Thread {\n        @Override\n        public void run() {\n            List<AccountWithDataSet> list = AccountTypeManager\n                    .getInstance(SearchDupActivity.this).getAccounts(true);\n            ArrayList<Account> accountsList = new ArrayList<>();\n            for (int i = 0; i < list.size(); i++) {\n                accountsList.add(list.get(i).getAccountOrNull());\n            }\n\n            /* calculate the contacts which can be merged. */\n            boolean isComplete = DuplicatesUtils\n                    .calculateMergeRawContacts(SearchDupActivity.this, accountsList,\n                            getContentResolver());\n            Message msg = Message.obtain();\n            if (isComplete) {\n                ArrayList<DuplicatesUtils.MergeContacts> mergeRawContacts =\n                        DuplicatesUtils.getMergeRawContacts();\n                if (mergeRawContacts != null && mergeRawContacts.size() > 0) {\n                    msg.what = FIND_DUPLICATED;\n                } else {\n                    msg.what = NO_DUPLICATED;\n                }\n                handler.sendMessage(msg);\n            }\n        }\n    }\n```\n\n***\n1.根据account 先进行区分\n2.根据account 查询 rawcontacts, 获取HashMap &lt;name(ignore大小写), list(rawcontacts ids)&gt;\n3.判定是否有dup contacts(list size 是否大于2)\n 判定是否可merge：\na。根据id in RawContactsEntity进行查询\nb。根据mimeType 组建mergePhoneList、mergeEmailList、photoid等\nc。构建ArrayList&lt;ContactsInfo&gt;\nd。构建ArrayList&lt;MergeContacts&gt; 对于sim contacts 进行额外判定。（MergeContacts:ContactsInfo ～ 1：n）\n4.progress 进度的更新\n***\n\n```java\n//DuplicatesUtils.java\n    public static boolean calculateMergeRawContacts(Context context, List<Account> accounts,\n        ContentResolver resolver) {\n        SimContactsOperation simContactsOperation = new SimContactsOperation(context);\n        mMergeRawContacts = new ArrayList<>();\n        int count = 0;\n        // contacts in different accounts are separated.\n        for (int i = 0; i < accounts.size() && mSearchState; i++) {\n            Account account = accounts.get(i);\n            HashMap<String, List<Long>> map = DuplicatesUtils.getRawNameWithIds(resolver,\n                    new String[]{account.name, account.type});\n            if (map != null && map.size() > 0) {\n                ArrayList<ContactsInfo> lst1;\n                Iterator<String> iterator = map.keySet().iterator();\n                while (mSearchState && iterator.hasNext()) {\n                    List<String> mergePhoneList = new ArrayList();\n                    List<String> mergeEmailList = new ArrayList();\n                    long contactId = -1;\n                    lst1 = new ArrayList<>();\n                    String keyName = iterator.next();\n                    List<Long> lst = map.get(keyName);\n                    if (lst.size() >= 2) {\n                        EntityIterator entityIterator = DuplicatesUtils.getEntityByIds(resolver,\n                                lst);\n                        if (entityIterator == null) {\n                            continue;\n                        }\n                        try {\n                            while (entityIterator.hasNext()) {\n                                ArrayList<String> phoneList = new ArrayList<>();\n                                ArrayList<String> emailList = new ArrayList<>();\n                                long photoId = 0;\n                                Entity next1 = entityIterator.next();\n                                ContentValues values = next1.getEntityValues();\n                                Long rawId = values.getAsLong(RawContacts._ID);\n                                String id = values.getAsString(RawContacts.CONTACT_ID);\n                                if (!TextUtils.isEmpty(id)) {\n                                    contactId = Long.parseLong(id);\n                                }\n                                Iterator<Entity.NamedContentValues> namedContentValuesIterator =\n                                        next1.getSubValues().iterator();\n                                while (namedContentValuesIterator.hasNext()) {\n                                    ContentValues values1 = namedContentValuesIterator\n                                            .next().values;\n                                    String mimeType = values1.getAsString(Data.MIMETYPE);\n                                    if (CommonDataKinds.StructuredName\n                                            .CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                        continue;\n                                    }\n                                    if (CommonDataKinds.Photo.CONTENT_ITEM_TYPE\n                                            .equals(mimeType)) {\n                                        photoId = values1.getAsLong(CommonDataKinds.Photo._ID)\n                                                .longValue();\n                                        continue;\n                                    }\n                                    if (CommonDataKinds.Phone.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                        String data1 = values1\n                                                .getAsString(CommonDataKinds.Phone.DATA1);\n                                        phoneList.add(data1);\n                                        if (!TextUtils.isEmpty(data1)\n                                                && !mergePhoneList.contains(data1)) {\n                                            boolean contains = false;\n                                            for (int j = 0; j < mergePhoneList.size(); j++) {\n                                                if (PhoneNumberUtils.compare(data1,\n                                                        mergePhoneList.get(j))) {\n                                                    contains = true;\n                                                    break;\n                                                }\n                                            }\n                                            if (!contains) {\n                                                mergePhoneList.add(data1);\n                                            }\n                                            continue;\n                                        }\n                                    }\n                                    if (CommonDataKinds.Email.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                        String email = values1\n                                                .getAsString(CommonDataKinds.Email.DATA1);\n                                        emailList.add(email);\n                                        if (!mergeEmailList.contains(email)) {\n                                            mergeEmailList.add(email);\n                                        }\n                                        continue;\n                                    }\n                                }\n                                Cursor cursor = resolver.query(Contacts.CONTENT_URI,\n                                        CONTACTS_PROJECTION, Contacts._ID.concat(\" = ?\"),\n                                        new String[]{String.valueOf(contactId)}, null);\n\n                                if (cursor != null && cursor.moveToNext()) {\n                                    String lookUp = cursor.getString(cursor\n                                            .getColumnIndex(Contacts.LOOKUP_KEY));\n                                    String displayName = cursor.getString(cursor.getColumnIndex(\n                                            Contacts.DISPLAY_NAME_PRIMARY));\n                                    lst1.add(new ContactsInfo(contactId, lookUp, photoId,\n                                            displayName, phoneList, emailList, rawId));\n                                    cursor.close();\n                                }\n                            }\n                        } finally {\n                            if (entityIterator != null) {\n                                entityIterator.close();\n                            }\n                        }\n                        // for sim contacts, analyse if it can be merged.\n                        if (contactId != -1\n                                && account.type.equals(SimContactsConstants.ACCOUNT_TYPE_SIM)) {\n                            int subscription = simContactsOperation.getSimSubscription(contactId);\n                            int oneSimAnrCount = MoreContactUtils.getOneSimAnrCount(\n                                    context, subscription);\n                            int oneSimEmailCount = MoreContactUtils\n                                    .getOneSimEmailCount(context, subscription);\n                            if (mergePhoneList.size() > oneSimAnrCount + 1\n                                    || mergeEmailList.size() > oneSimEmailCount) {\n                                continue;\n                            }\n                        }\n                        if (mMergeRawContacts != null) {\n                            mMergeRawContacts.add(\n                                new MergeContacts(account.name, account.type, lst1));\n                        }\n                    }\n                    count += lst.size();\n                    mProgressDialog.setProgress(count);\n                }\n            }\n        }\n        if (mSearchState) {\n            // search ended, change the flag.\n            mSearchState = false;\n            return true;\n        }\n        return false;\n    }\n```\n\n## 2.显示重复联系人\n\n***\n根据ArrayList&lt;MergeContacts&gt; 显示UI e.g. 根据mSelectCount 控制merge enanble或disable等\n***\n\n```java\n//MergeContactActivity.java\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id) {\n        MergeContactAdapter adapter = (MergeContactAdapter) l.getAdapter();\n        DuplicatesUtils.MergeContacts item = (DuplicatesUtils.MergeContacts) adapter\n                .getItem(position);\n        CheckBox cb = (CheckBox) v.findViewById(R.id.row_box);\n        // mark the mergeContacts item, which will be merged later, if true.\n        // calculate the selected count.\n        if (cb.isChecked() && item.isChecked()) {\n            cb.setChecked(false);\n            item.setChecked(false);\n            mSelectCount--;\n        } else {\n            cb.setChecked(true);\n            item.setChecked(true);\n            mSelectCount++;\n        }\n        // if the selected count is '0', disable the menuItem.\n        if (mSelectCount == 0 && mergeItem != null && mergeItem.isEnabled()) {\n            mergeItem.setEnabled(false);\n        } else if (mSelectCount > 0 && mergeItem != null && !mergeItem.isEnabled()) {\n            mergeItem.setEnabled(true);\n        }\n    }\n```\n\n## 3.合并重复联系人\n\n```java\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.menu_merge: {\n                mProgressDialog = new MyProgressDialog(MergeContactActivity.this);\n                mProgressDialog.setMessage(this.getString(R.string.merging_contacts));\n                mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n                Iterator<DuplicatesUtils.MergeContacts> iterator = mMergeList.iterator();\n                while (iterator.hasNext()) {\n                    DuplicatesUtils.MergeContacts next = iterator.next();\n                    if (!next.isChecked()) {\n                        iterator.remove();\n                    }\n                }\n                mProgressDialog.setMax(mMergeList.size());\n                mProgressDialog.setCancelable(false);\n                mProgressDialog.setCanceledOnTouchOutside(false);\n                mProgressDialog.show();\n                Thread thread = new MergeDuplicatedThread();\n                DuplicatesUtils.mMergeState = true;\n                thread.start();\n            }\n        }\n        return true;\n    }\n```\n","slug":"merge-contacts","published":1,"updated":"2018-08-13T06:31:31.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjks8kndi0004xwuj1gwwi6uw","content":"<h2 id=\"1-搜索重复联系人\"><a href=\"#1-搜索重复联系人\" class=\"headerlink\" title=\"1.搜索重复联系人\"></a>1.搜索重复联系人</h2><pre><code class=\"java\">//SearchDupActivity.java\n    @Override\n    protected Dialog onCreateDialog(int id) {\n        switch (id) {\n            case R.id.search_dup_dialog: {\n                mProgressDialog = initSearchingDialog();\n                DuplicatesUtils.setDialog(mProgressDialog);\n                Thread thread = new SearchDuplicatedThread();\n                DuplicatesUtils.mSearchState = true;\n                thread.start();\n                return mProgressDialog;\n            }\n        }\n        return super.onCreateDialog(id);\n    }\n</code></pre>\n<h3 id=\"初始化search-界面\"><a href=\"#初始化search-界面\" class=\"headerlink\" title=\"初始化search 界面\"></a>初始化search 界面</h3><pre><code class=\"java\">//SearchDupActivity.java\n    private ProgressDialog initSearchingDialog() {\n        ProgressDialog dialog = new MyProgressDialog(this);\n        dialog.setMessage(this.getString(R.string.searching_duplicated_contacts));\n        dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n        dialog.setCanceledOnTouchOutside(false);\n        Cursor cursor = null;\n        int allCount = 0;\n        String selection = RawContacts.DELETED + &quot;= 0&quot;;\n        try {\n            //计算progress total size（通过rawcontacts表查询，去除DELETED）\n            cursor = getContentResolver()\n                    .query(RawContacts.CONTENT_URI, RAWCONTACTS_ID_PROJECTION,\n                    selection, null, null);\n        } finally {\n            if (cursor != null) {\n                allCount = cursor.getCount();\n                cursor.close();\n            }\n        }\n        dialog.setMax(allCount);\n        return dialog;\n    }\n</code></pre>\n<hr>\n<p>1.获取 account list<br>2.计算 duplicate contacts 用于显示MergeContactActivity的数据<br>3.查询完后，handler通知启动MergeContactActivity界面。</p>\n<hr>\n<pre><code class=\"java\">//SearchDupActivity.java\n    private class SearchDuplicatedThread extends Thread {\n        @Override\n        public void run() {\n            List&lt;AccountWithDataSet&gt; list = AccountTypeManager\n                    .getInstance(SearchDupActivity.this).getAccounts(true);\n            ArrayList&lt;Account&gt; accountsList = new ArrayList&lt;&gt;();\n            for (int i = 0; i &lt; list.size(); i++) {\n                accountsList.add(list.get(i).getAccountOrNull());\n            }\n\n            /* calculate the contacts which can be merged. */\n            boolean isComplete = DuplicatesUtils\n                    .calculateMergeRawContacts(SearchDupActivity.this, accountsList,\n                            getContentResolver());\n            Message msg = Message.obtain();\n            if (isComplete) {\n                ArrayList&lt;DuplicatesUtils.MergeContacts&gt; mergeRawContacts =\n                        DuplicatesUtils.getMergeRawContacts();\n                if (mergeRawContacts != null &amp;&amp; mergeRawContacts.size() &gt; 0) {\n                    msg.what = FIND_DUPLICATED;\n                } else {\n                    msg.what = NO_DUPLICATED;\n                }\n                handler.sendMessage(msg);\n            }\n        }\n    }\n</code></pre>\n<hr>\n<p>1.根据account 先进行区分<br>2.根据account 查询 rawcontacts, 获取HashMap &lt;name(ignore大小写), list(rawcontacts ids)&gt;<br>3.判定是否有dup contacts(list size 是否大于2)<br> 判定是否可merge：<br>a。根据id in RawContactsEntity进行查询<br>b。根据mimeType 组建mergePhoneList、mergeEmailList、photoid等<br>c。构建ArrayList&lt;ContactsInfo&gt;<br>d。构建ArrayList&lt;MergeContacts&gt; 对于sim contacts 进行额外判定。（MergeContacts:ContactsInfo ～ 1：n）<br>4.progress 进度的更新</p>\n<hr>\n<pre><code class=\"java\">//DuplicatesUtils.java\n    public static boolean calculateMergeRawContacts(Context context, List&lt;Account&gt; accounts,\n        ContentResolver resolver) {\n        SimContactsOperation simContactsOperation = new SimContactsOperation(context);\n        mMergeRawContacts = new ArrayList&lt;&gt;();\n        int count = 0;\n        // contacts in different accounts are separated.\n        for (int i = 0; i &lt; accounts.size() &amp;&amp; mSearchState; i++) {\n            Account account = accounts.get(i);\n            HashMap&lt;String, List&lt;Long&gt;&gt; map = DuplicatesUtils.getRawNameWithIds(resolver,\n                    new String[]{account.name, account.type});\n            if (map != null &amp;&amp; map.size() &gt; 0) {\n                ArrayList&lt;ContactsInfo&gt; lst1;\n                Iterator&lt;String&gt; iterator = map.keySet().iterator();\n                while (mSearchState &amp;&amp; iterator.hasNext()) {\n                    List&lt;String&gt; mergePhoneList = new ArrayList();\n                    List&lt;String&gt; mergeEmailList = new ArrayList();\n                    long contactId = -1;\n                    lst1 = new ArrayList&lt;&gt;();\n                    String keyName = iterator.next();\n                    List&lt;Long&gt; lst = map.get(keyName);\n                    if (lst.size() &gt;= 2) {\n                        EntityIterator entityIterator = DuplicatesUtils.getEntityByIds(resolver,\n                                lst);\n                        if (entityIterator == null) {\n                            continue;\n                        }\n                        try {\n                            while (entityIterator.hasNext()) {\n                                ArrayList&lt;String&gt; phoneList = new ArrayList&lt;&gt;();\n                                ArrayList&lt;String&gt; emailList = new ArrayList&lt;&gt;();\n                                long photoId = 0;\n                                Entity next1 = entityIterator.next();\n                                ContentValues values = next1.getEntityValues();\n                                Long rawId = values.getAsLong(RawContacts._ID);\n                                String id = values.getAsString(RawContacts.CONTACT_ID);\n                                if (!TextUtils.isEmpty(id)) {\n                                    contactId = Long.parseLong(id);\n                                }\n                                Iterator&lt;Entity.NamedContentValues&gt; namedContentValuesIterator =\n                                        next1.getSubValues().iterator();\n                                while (namedContentValuesIterator.hasNext()) {\n                                    ContentValues values1 = namedContentValuesIterator\n                                            .next().values;\n                                    String mimeType = values1.getAsString(Data.MIMETYPE);\n                                    if (CommonDataKinds.StructuredName\n                                            .CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                        continue;\n                                    }\n                                    if (CommonDataKinds.Photo.CONTENT_ITEM_TYPE\n                                            .equals(mimeType)) {\n                                        photoId = values1.getAsLong(CommonDataKinds.Photo._ID)\n                                                .longValue();\n                                        continue;\n                                    }\n                                    if (CommonDataKinds.Phone.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                        String data1 = values1\n                                                .getAsString(CommonDataKinds.Phone.DATA1);\n                                        phoneList.add(data1);\n                                        if (!TextUtils.isEmpty(data1)\n                                                &amp;&amp; !mergePhoneList.contains(data1)) {\n                                            boolean contains = false;\n                                            for (int j = 0; j &lt; mergePhoneList.size(); j++) {\n                                                if (PhoneNumberUtils.compare(data1,\n                                                        mergePhoneList.get(j))) {\n                                                    contains = true;\n                                                    break;\n                                                }\n                                            }\n                                            if (!contains) {\n                                                mergePhoneList.add(data1);\n                                            }\n                                            continue;\n                                        }\n                                    }\n                                    if (CommonDataKinds.Email.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                        String email = values1\n                                                .getAsString(CommonDataKinds.Email.DATA1);\n                                        emailList.add(email);\n                                        if (!mergeEmailList.contains(email)) {\n                                            mergeEmailList.add(email);\n                                        }\n                                        continue;\n                                    }\n                                }\n                                Cursor cursor = resolver.query(Contacts.CONTENT_URI,\n                                        CONTACTS_PROJECTION, Contacts._ID.concat(&quot; = ?&quot;),\n                                        new String[]{String.valueOf(contactId)}, null);\n\n                                if (cursor != null &amp;&amp; cursor.moveToNext()) {\n                                    String lookUp = cursor.getString(cursor\n                                            .getColumnIndex(Contacts.LOOKUP_KEY));\n                                    String displayName = cursor.getString(cursor.getColumnIndex(\n                                            Contacts.DISPLAY_NAME_PRIMARY));\n                                    lst1.add(new ContactsInfo(contactId, lookUp, photoId,\n                                            displayName, phoneList, emailList, rawId));\n                                    cursor.close();\n                                }\n                            }\n                        } finally {\n                            if (entityIterator != null) {\n                                entityIterator.close();\n                            }\n                        }\n                        // for sim contacts, analyse if it can be merged.\n                        if (contactId != -1\n                                &amp;&amp; account.type.equals(SimContactsConstants.ACCOUNT_TYPE_SIM)) {\n                            int subscription = simContactsOperation.getSimSubscription(contactId);\n                            int oneSimAnrCount = MoreContactUtils.getOneSimAnrCount(\n                                    context, subscription);\n                            int oneSimEmailCount = MoreContactUtils\n                                    .getOneSimEmailCount(context, subscription);\n                            if (mergePhoneList.size() &gt; oneSimAnrCount + 1\n                                    || mergeEmailList.size() &gt; oneSimEmailCount) {\n                                continue;\n                            }\n                        }\n                        if (mMergeRawContacts != null) {\n                            mMergeRawContacts.add(\n                                new MergeContacts(account.name, account.type, lst1));\n                        }\n                    }\n                    count += lst.size();\n                    mProgressDialog.setProgress(count);\n                }\n            }\n        }\n        if (mSearchState) {\n            // search ended, change the flag.\n            mSearchState = false;\n            return true;\n        }\n        return false;\n    }\n</code></pre>\n<h2 id=\"2-显示重复联系人\"><a href=\"#2-显示重复联系人\" class=\"headerlink\" title=\"2.显示重复联系人\"></a>2.显示重复联系人</h2><hr>\n<p>根据ArrayList&lt;MergeContacts&gt; 显示UI e.g. 根据mSelectCount 控制merge enanble或disable等</p>\n<hr>\n<pre><code class=\"java\">//MergeContactActivity.java\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id) {\n        MergeContactAdapter adapter = (MergeContactAdapter) l.getAdapter();\n        DuplicatesUtils.MergeContacts item = (DuplicatesUtils.MergeContacts) adapter\n                .getItem(position);\n        CheckBox cb = (CheckBox) v.findViewById(R.id.row_box);\n        // mark the mergeContacts item, which will be merged later, if true.\n        // calculate the selected count.\n        if (cb.isChecked() &amp;&amp; item.isChecked()) {\n            cb.setChecked(false);\n            item.setChecked(false);\n            mSelectCount--;\n        } else {\n            cb.setChecked(true);\n            item.setChecked(true);\n            mSelectCount++;\n        }\n        // if the selected count is &#39;0&#39;, disable the menuItem.\n        if (mSelectCount == 0 &amp;&amp; mergeItem != null &amp;&amp; mergeItem.isEnabled()) {\n            mergeItem.setEnabled(false);\n        } else if (mSelectCount &gt; 0 &amp;&amp; mergeItem != null &amp;&amp; !mergeItem.isEnabled()) {\n            mergeItem.setEnabled(true);\n        }\n    }\n</code></pre>\n<h2 id=\"3-合并重复联系人\"><a href=\"#3-合并重复联系人\" class=\"headerlink\" title=\"3.合并重复联系人\"></a>3.合并重复联系人</h2><pre><code class=\"java\">    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.menu_merge: {\n                mProgressDialog = new MyProgressDialog(MergeContactActivity.this);\n                mProgressDialog.setMessage(this.getString(R.string.merging_contacts));\n                mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n                Iterator&lt;DuplicatesUtils.MergeContacts&gt; iterator = mMergeList.iterator();\n                while (iterator.hasNext()) {\n                    DuplicatesUtils.MergeContacts next = iterator.next();\n                    if (!next.isChecked()) {\n                        iterator.remove();\n                    }\n                }\n                mProgressDialog.setMax(mMergeList.size());\n                mProgressDialog.setCancelable(false);\n                mProgressDialog.setCanceledOnTouchOutside(false);\n                mProgressDialog.show();\n                Thread thread = new MergeDuplicatedThread();\n                DuplicatesUtils.mMergeState = true;\n                thread.start();\n            }\n        }\n        return true;\n    }\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-搜索重复联系人\"><a href=\"#1-搜索重复联系人\" class=\"headerlink\" title=\"1.搜索重复联系人\"></a>1.搜索重复联系人</h2><pre><code class=\"java\">//SearchDupActivity.java\n    @Override\n    protected Dialog onCreateDialog(int id) {\n        switch (id) {\n            case R.id.search_dup_dialog: {\n                mProgressDialog = initSearchingDialog();\n                DuplicatesUtils.setDialog(mProgressDialog);\n                Thread thread = new SearchDuplicatedThread();\n                DuplicatesUtils.mSearchState = true;\n                thread.start();\n                return mProgressDialog;\n            }\n        }\n        return super.onCreateDialog(id);\n    }\n</code></pre>\n<h3 id=\"初始化search-界面\"><a href=\"#初始化search-界面\" class=\"headerlink\" title=\"初始化search 界面\"></a>初始化search 界面</h3><pre><code class=\"java\">//SearchDupActivity.java\n    private ProgressDialog initSearchingDialog() {\n        ProgressDialog dialog = new MyProgressDialog(this);\n        dialog.setMessage(this.getString(R.string.searching_duplicated_contacts));\n        dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n        dialog.setCanceledOnTouchOutside(false);\n        Cursor cursor = null;\n        int allCount = 0;\n        String selection = RawContacts.DELETED + &quot;= 0&quot;;\n        try {\n            //计算progress total size（通过rawcontacts表查询，去除DELETED）\n            cursor = getContentResolver()\n                    .query(RawContacts.CONTENT_URI, RAWCONTACTS_ID_PROJECTION,\n                    selection, null, null);\n        } finally {\n            if (cursor != null) {\n                allCount = cursor.getCount();\n                cursor.close();\n            }\n        }\n        dialog.setMax(allCount);\n        return dialog;\n    }\n</code></pre>\n<hr>\n<p>1.获取 account list<br>2.计算 duplicate contacts 用于显示MergeContactActivity的数据<br>3.查询完后，handler通知启动MergeContactActivity界面。</p>\n<hr>\n<pre><code class=\"java\">//SearchDupActivity.java\n    private class SearchDuplicatedThread extends Thread {\n        @Override\n        public void run() {\n            List&lt;AccountWithDataSet&gt; list = AccountTypeManager\n                    .getInstance(SearchDupActivity.this).getAccounts(true);\n            ArrayList&lt;Account&gt; accountsList = new ArrayList&lt;&gt;();\n            for (int i = 0; i &lt; list.size(); i++) {\n                accountsList.add(list.get(i).getAccountOrNull());\n            }\n\n            /* calculate the contacts which can be merged. */\n            boolean isComplete = DuplicatesUtils\n                    .calculateMergeRawContacts(SearchDupActivity.this, accountsList,\n                            getContentResolver());\n            Message msg = Message.obtain();\n            if (isComplete) {\n                ArrayList&lt;DuplicatesUtils.MergeContacts&gt; mergeRawContacts =\n                        DuplicatesUtils.getMergeRawContacts();\n                if (mergeRawContacts != null &amp;&amp; mergeRawContacts.size() &gt; 0) {\n                    msg.what = FIND_DUPLICATED;\n                } else {\n                    msg.what = NO_DUPLICATED;\n                }\n                handler.sendMessage(msg);\n            }\n        }\n    }\n</code></pre>\n<hr>\n<p>1.根据account 先进行区分<br>2.根据account 查询 rawcontacts, 获取HashMap &lt;name(ignore大小写), list(rawcontacts ids)&gt;<br>3.判定是否有dup contacts(list size 是否大于2)<br> 判定是否可merge：<br>a。根据id in RawContactsEntity进行查询<br>b。根据mimeType 组建mergePhoneList、mergeEmailList、photoid等<br>c。构建ArrayList&lt;ContactsInfo&gt;<br>d。构建ArrayList&lt;MergeContacts&gt; 对于sim contacts 进行额外判定。（MergeContacts:ContactsInfo ～ 1：n）<br>4.progress 进度的更新</p>\n<hr>\n<pre><code class=\"java\">//DuplicatesUtils.java\n    public static boolean calculateMergeRawContacts(Context context, List&lt;Account&gt; accounts,\n        ContentResolver resolver) {\n        SimContactsOperation simContactsOperation = new SimContactsOperation(context);\n        mMergeRawContacts = new ArrayList&lt;&gt;();\n        int count = 0;\n        // contacts in different accounts are separated.\n        for (int i = 0; i &lt; accounts.size() &amp;&amp; mSearchState; i++) {\n            Account account = accounts.get(i);\n            HashMap&lt;String, List&lt;Long&gt;&gt; map = DuplicatesUtils.getRawNameWithIds(resolver,\n                    new String[]{account.name, account.type});\n            if (map != null &amp;&amp; map.size() &gt; 0) {\n                ArrayList&lt;ContactsInfo&gt; lst1;\n                Iterator&lt;String&gt; iterator = map.keySet().iterator();\n                while (mSearchState &amp;&amp; iterator.hasNext()) {\n                    List&lt;String&gt; mergePhoneList = new ArrayList();\n                    List&lt;String&gt; mergeEmailList = new ArrayList();\n                    long contactId = -1;\n                    lst1 = new ArrayList&lt;&gt;();\n                    String keyName = iterator.next();\n                    List&lt;Long&gt; lst = map.get(keyName);\n                    if (lst.size() &gt;= 2) {\n                        EntityIterator entityIterator = DuplicatesUtils.getEntityByIds(resolver,\n                                lst);\n                        if (entityIterator == null) {\n                            continue;\n                        }\n                        try {\n                            while (entityIterator.hasNext()) {\n                                ArrayList&lt;String&gt; phoneList = new ArrayList&lt;&gt;();\n                                ArrayList&lt;String&gt; emailList = new ArrayList&lt;&gt;();\n                                long photoId = 0;\n                                Entity next1 = entityIterator.next();\n                                ContentValues values = next1.getEntityValues();\n                                Long rawId = values.getAsLong(RawContacts._ID);\n                                String id = values.getAsString(RawContacts.CONTACT_ID);\n                                if (!TextUtils.isEmpty(id)) {\n                                    contactId = Long.parseLong(id);\n                                }\n                                Iterator&lt;Entity.NamedContentValues&gt; namedContentValuesIterator =\n                                        next1.getSubValues().iterator();\n                                while (namedContentValuesIterator.hasNext()) {\n                                    ContentValues values1 = namedContentValuesIterator\n                                            .next().values;\n                                    String mimeType = values1.getAsString(Data.MIMETYPE);\n                                    if (CommonDataKinds.StructuredName\n                                            .CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                        continue;\n                                    }\n                                    if (CommonDataKinds.Photo.CONTENT_ITEM_TYPE\n                                            .equals(mimeType)) {\n                                        photoId = values1.getAsLong(CommonDataKinds.Photo._ID)\n                                                .longValue();\n                                        continue;\n                                    }\n                                    if (CommonDataKinds.Phone.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                        String data1 = values1\n                                                .getAsString(CommonDataKinds.Phone.DATA1);\n                                        phoneList.add(data1);\n                                        if (!TextUtils.isEmpty(data1)\n                                                &amp;&amp; !mergePhoneList.contains(data1)) {\n                                            boolean contains = false;\n                                            for (int j = 0; j &lt; mergePhoneList.size(); j++) {\n                                                if (PhoneNumberUtils.compare(data1,\n                                                        mergePhoneList.get(j))) {\n                                                    contains = true;\n                                                    break;\n                                                }\n                                            }\n                                            if (!contains) {\n                                                mergePhoneList.add(data1);\n                                            }\n                                            continue;\n                                        }\n                                    }\n                                    if (CommonDataKinds.Email.CONTENT_ITEM_TYPE.equals(mimeType)) {\n                                        String email = values1\n                                                .getAsString(CommonDataKinds.Email.DATA1);\n                                        emailList.add(email);\n                                        if (!mergeEmailList.contains(email)) {\n                                            mergeEmailList.add(email);\n                                        }\n                                        continue;\n                                    }\n                                }\n                                Cursor cursor = resolver.query(Contacts.CONTENT_URI,\n                                        CONTACTS_PROJECTION, Contacts._ID.concat(&quot; = ?&quot;),\n                                        new String[]{String.valueOf(contactId)}, null);\n\n                                if (cursor != null &amp;&amp; cursor.moveToNext()) {\n                                    String lookUp = cursor.getString(cursor\n                                            .getColumnIndex(Contacts.LOOKUP_KEY));\n                                    String displayName = cursor.getString(cursor.getColumnIndex(\n                                            Contacts.DISPLAY_NAME_PRIMARY));\n                                    lst1.add(new ContactsInfo(contactId, lookUp, photoId,\n                                            displayName, phoneList, emailList, rawId));\n                                    cursor.close();\n                                }\n                            }\n                        } finally {\n                            if (entityIterator != null) {\n                                entityIterator.close();\n                            }\n                        }\n                        // for sim contacts, analyse if it can be merged.\n                        if (contactId != -1\n                                &amp;&amp; account.type.equals(SimContactsConstants.ACCOUNT_TYPE_SIM)) {\n                            int subscription = simContactsOperation.getSimSubscription(contactId);\n                            int oneSimAnrCount = MoreContactUtils.getOneSimAnrCount(\n                                    context, subscription);\n                            int oneSimEmailCount = MoreContactUtils\n                                    .getOneSimEmailCount(context, subscription);\n                            if (mergePhoneList.size() &gt; oneSimAnrCount + 1\n                                    || mergeEmailList.size() &gt; oneSimEmailCount) {\n                                continue;\n                            }\n                        }\n                        if (mMergeRawContacts != null) {\n                            mMergeRawContacts.add(\n                                new MergeContacts(account.name, account.type, lst1));\n                        }\n                    }\n                    count += lst.size();\n                    mProgressDialog.setProgress(count);\n                }\n            }\n        }\n        if (mSearchState) {\n            // search ended, change the flag.\n            mSearchState = false;\n            return true;\n        }\n        return false;\n    }\n</code></pre>\n<h2 id=\"2-显示重复联系人\"><a href=\"#2-显示重复联系人\" class=\"headerlink\" title=\"2.显示重复联系人\"></a>2.显示重复联系人</h2><hr>\n<p>根据ArrayList&lt;MergeContacts&gt; 显示UI e.g. 根据mSelectCount 控制merge enanble或disable等</p>\n<hr>\n<pre><code class=\"java\">//MergeContactActivity.java\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id) {\n        MergeContactAdapter adapter = (MergeContactAdapter) l.getAdapter();\n        DuplicatesUtils.MergeContacts item = (DuplicatesUtils.MergeContacts) adapter\n                .getItem(position);\n        CheckBox cb = (CheckBox) v.findViewById(R.id.row_box);\n        // mark the mergeContacts item, which will be merged later, if true.\n        // calculate the selected count.\n        if (cb.isChecked() &amp;&amp; item.isChecked()) {\n            cb.setChecked(false);\n            item.setChecked(false);\n            mSelectCount--;\n        } else {\n            cb.setChecked(true);\n            item.setChecked(true);\n            mSelectCount++;\n        }\n        // if the selected count is &#39;0&#39;, disable the menuItem.\n        if (mSelectCount == 0 &amp;&amp; mergeItem != null &amp;&amp; mergeItem.isEnabled()) {\n            mergeItem.setEnabled(false);\n        } else if (mSelectCount &gt; 0 &amp;&amp; mergeItem != null &amp;&amp; !mergeItem.isEnabled()) {\n            mergeItem.setEnabled(true);\n        }\n    }\n</code></pre>\n<h2 id=\"3-合并重复联系人\"><a href=\"#3-合并重复联系人\" class=\"headerlink\" title=\"3.合并重复联系人\"></a>3.合并重复联系人</h2><pre><code class=\"java\">    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.menu_merge: {\n                mProgressDialog = new MyProgressDialog(MergeContactActivity.this);\n                mProgressDialog.setMessage(this.getString(R.string.merging_contacts));\n                mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n                Iterator&lt;DuplicatesUtils.MergeContacts&gt; iterator = mMergeList.iterator();\n                while (iterator.hasNext()) {\n                    DuplicatesUtils.MergeContacts next = iterator.next();\n                    if (!next.isChecked()) {\n                        iterator.remove();\n                    }\n                }\n                mProgressDialog.setMax(mMergeList.size());\n                mProgressDialog.setCancelable(false);\n                mProgressDialog.setCanceledOnTouchOutside(false);\n                mProgressDialog.show();\n                Thread thread = new MergeDuplicatedThread();\n                DuplicatesUtils.mMergeState = true;\n                thread.start();\n            }\n        }\n        return true;\n    }\n</code></pre>\n"},{"title":"多语言下，String子串可点击并实现跳转","date":"2018-01-22T09:53:49.000Z","_content":"\n## 总结\n通过Spannable实现色彩效果，ClickableSpan实现点击。\n\n对于resource string，通过添加标签位，来计算不同语言下，可点击的substring的index\n\n## 工具类\n\n```java\n//LinkifyUtils.java\npublic class LinkifyUtils {\n    private static final String PLACE_HOLDER_LINK_BEGIN = \"LINK_BEGIN\";\n    private static final String PLACE_HOLDER_LINK_END = \"LINK_END\";\n\n    private LinkifyUtils() {\n    }\n\n    /** Interface that handles the click event of the link */\n    public interface OnClickListener {\n        void onClick();\n    }\n\n    /**\n     * Applies the text into the {@link TextView} and part of it a clickable link.\n     * The text surrounded with \"LINK_BEGIN\" and \"LINK_END\" will become a clickable link. Only\n     * supports at most one link.\n     * @return true if the link has been successfully applied, or false if the original text\n     *         contains no link place holders.\n     */\n    public static boolean linkify(TextView textView, StringBuilder text,\n                                  final OnClickListener listener) {\n        // Remove place-holders from the string and record their positions\n        final int beginIndex = text.indexOf(PLACE_HOLDER_LINK_BEGIN);\n        if (beginIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(beginIndex, beginIndex + PLACE_HOLDER_LINK_BEGIN.length());\n        final int endIndex = text.indexOf(PLACE_HOLDER_LINK_END);\n        if (endIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(endIndex, endIndex + PLACE_HOLDER_LINK_END.length());\n\n        textView.setText(text.toString(), TextView.BufferType.SPANNABLE);\n        textView.setMovementMethod(LinkMovementMethod.getInstance());\n        Spannable spannableContent = (Spannable) textView.getText();\n        ClickableSpan spannableLink = new ClickableSpan() {\n            @Override\n            public void onClick(View widget) {\n                listener.onClick();\n            }\n\n            @Override\n            public void updateDrawState(TextPaint ds) {\n                super.updateDrawState(ds);\n                ds.setUnderlineText(false);\n            }\n        };\n        spannableContent.setSpan(spannableLink, beginIndex, endIndex,\n                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        return true;\n    }\n}\n```\n\n## UI界面\n\n```java\n//XXXActivity.java\n        StringBuilder contentBuilder = new StringBuilder();\n        contentBuilder.append(getText(R.string.no_internet));\n        LinkifyUtils.linkify(tvEmpty, contentBuilder, new LinkifyUtils.OnClickListener() {\n            @Override\n            public void onClick() {\n                Intent intent = new Intent();\n                intent.setClassName(\"com.android.settings\", \"com.android.settings.wifi.WifiSettings\");\n                startActivity(intent);\n            }\n        });\n```\n\n```xml\n<string name=\"no_internet\">No internet connection. Make sure  <xliff:g id=\"link_begin\">LINK_BEGIN</xliff:g>Wi-Fi<xliff:g id=\"link_end\">LINK_END</xliff:g> is turned on, then try again.</string>\n\n<string name=\"no_internet\">未连接到互联网。请确保  <xliff:g id=\"link_begin\">LINK_BEGIN</xliff:g>Wi-Fi<xliff:g id=\"link_end\">LINK_END</xliff:g> 网路已开启，然后重试。</string>\n\n```\n","source":"_posts/Android/多语言下，String子串可点击并实现跳转.md","raw":"---\ntitle: 多语言下，String子串可点击并实现跳转\npermalink: substring-jump\ncategories:\n  - Android\ntags:\n  - android\ndate: 2018-01-22 17:53:49\n---\n\n## 总结\n通过Spannable实现色彩效果，ClickableSpan实现点击。\n\n对于resource string，通过添加标签位，来计算不同语言下，可点击的substring的index\n\n## 工具类\n\n```java\n//LinkifyUtils.java\npublic class LinkifyUtils {\n    private static final String PLACE_HOLDER_LINK_BEGIN = \"LINK_BEGIN\";\n    private static final String PLACE_HOLDER_LINK_END = \"LINK_END\";\n\n    private LinkifyUtils() {\n    }\n\n    /** Interface that handles the click event of the link */\n    public interface OnClickListener {\n        void onClick();\n    }\n\n    /**\n     * Applies the text into the {@link TextView} and part of it a clickable link.\n     * The text surrounded with \"LINK_BEGIN\" and \"LINK_END\" will become a clickable link. Only\n     * supports at most one link.\n     * @return true if the link has been successfully applied, or false if the original text\n     *         contains no link place holders.\n     */\n    public static boolean linkify(TextView textView, StringBuilder text,\n                                  final OnClickListener listener) {\n        // Remove place-holders from the string and record their positions\n        final int beginIndex = text.indexOf(PLACE_HOLDER_LINK_BEGIN);\n        if (beginIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(beginIndex, beginIndex + PLACE_HOLDER_LINK_BEGIN.length());\n        final int endIndex = text.indexOf(PLACE_HOLDER_LINK_END);\n        if (endIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(endIndex, endIndex + PLACE_HOLDER_LINK_END.length());\n\n        textView.setText(text.toString(), TextView.BufferType.SPANNABLE);\n        textView.setMovementMethod(LinkMovementMethod.getInstance());\n        Spannable spannableContent = (Spannable) textView.getText();\n        ClickableSpan spannableLink = new ClickableSpan() {\n            @Override\n            public void onClick(View widget) {\n                listener.onClick();\n            }\n\n            @Override\n            public void updateDrawState(TextPaint ds) {\n                super.updateDrawState(ds);\n                ds.setUnderlineText(false);\n            }\n        };\n        spannableContent.setSpan(spannableLink, beginIndex, endIndex,\n                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        return true;\n    }\n}\n```\n\n## UI界面\n\n```java\n//XXXActivity.java\n        StringBuilder contentBuilder = new StringBuilder();\n        contentBuilder.append(getText(R.string.no_internet));\n        LinkifyUtils.linkify(tvEmpty, contentBuilder, new LinkifyUtils.OnClickListener() {\n            @Override\n            public void onClick() {\n                Intent intent = new Intent();\n                intent.setClassName(\"com.android.settings\", \"com.android.settings.wifi.WifiSettings\");\n                startActivity(intent);\n            }\n        });\n```\n\n```xml\n<string name=\"no_internet\">No internet connection. Make sure  <xliff:g id=\"link_begin\">LINK_BEGIN</xliff:g>Wi-Fi<xliff:g id=\"link_end\">LINK_END</xliff:g> is turned on, then try again.</string>\n\n<string name=\"no_internet\">未连接到互联网。请确保  <xliff:g id=\"link_begin\">LINK_BEGIN</xliff:g>Wi-Fi<xliff:g id=\"link_end\">LINK_END</xliff:g> 网路已开启，然后重试。</string>\n\n```\n","slug":"substring-jump","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjks8kndj0005xwujoppoyldp","content":"<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过Spannable实现色彩效果，ClickableSpan实现点击。</p>\n<p>对于resource string，通过添加标签位，来计算不同语言下，可点击的substring的index</p>\n<h2 id=\"工具类\"><a href=\"#工具类\" class=\"headerlink\" title=\"工具类\"></a>工具类</h2><pre><code class=\"java\">//LinkifyUtils.java\npublic class LinkifyUtils {\n    private static final String PLACE_HOLDER_LINK_BEGIN = &quot;LINK_BEGIN&quot;;\n    private static final String PLACE_HOLDER_LINK_END = &quot;LINK_END&quot;;\n\n    private LinkifyUtils() {\n    }\n\n    /** Interface that handles the click event of the link */\n    public interface OnClickListener {\n        void onClick();\n    }\n\n    /**\n     * Applies the text into the {@link TextView} and part of it a clickable link.\n     * The text surrounded with &quot;LINK_BEGIN&quot; and &quot;LINK_END&quot; will become a clickable link. Only\n     * supports at most one link.\n     * @return true if the link has been successfully applied, or false if the original text\n     *         contains no link place holders.\n     */\n    public static boolean linkify(TextView textView, StringBuilder text,\n                                  final OnClickListener listener) {\n        // Remove place-holders from the string and record their positions\n        final int beginIndex = text.indexOf(PLACE_HOLDER_LINK_BEGIN);\n        if (beginIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(beginIndex, beginIndex + PLACE_HOLDER_LINK_BEGIN.length());\n        final int endIndex = text.indexOf(PLACE_HOLDER_LINK_END);\n        if (endIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(endIndex, endIndex + PLACE_HOLDER_LINK_END.length());\n\n        textView.setText(text.toString(), TextView.BufferType.SPANNABLE);\n        textView.setMovementMethod(LinkMovementMethod.getInstance());\n        Spannable spannableContent = (Spannable) textView.getText();\n        ClickableSpan spannableLink = new ClickableSpan() {\n            @Override\n            public void onClick(View widget) {\n                listener.onClick();\n            }\n\n            @Override\n            public void updateDrawState(TextPaint ds) {\n                super.updateDrawState(ds);\n                ds.setUnderlineText(false);\n            }\n        };\n        spannableContent.setSpan(spannableLink, beginIndex, endIndex,\n                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        return true;\n    }\n}\n</code></pre>\n<h2 id=\"UI界面\"><a href=\"#UI界面\" class=\"headerlink\" title=\"UI界面\"></a>UI界面</h2><pre><code class=\"java\">//XXXActivity.java\n        StringBuilder contentBuilder = new StringBuilder();\n        contentBuilder.append(getText(R.string.no_internet));\n        LinkifyUtils.linkify(tvEmpty, contentBuilder, new LinkifyUtils.OnClickListener() {\n            @Override\n            public void onClick() {\n                Intent intent = new Intent();\n                intent.setClassName(&quot;com.android.settings&quot;, &quot;com.android.settings.wifi.WifiSettings&quot;);\n                startActivity(intent);\n            }\n        });\n</code></pre>\n<pre><code class=\"xml\">&lt;string name=&quot;no_internet&quot;&gt;No internet connection. Make sure  &lt;xliff:g id=&quot;link_begin&quot;&gt;LINK_BEGIN&lt;/xliff:g&gt;Wi-Fi&lt;xliff:g id=&quot;link_end&quot;&gt;LINK_END&lt;/xliff:g&gt; is turned on, then try again.&lt;/string&gt;\n\n&lt;string name=&quot;no_internet&quot;&gt;未连接到互联网。请确保  &lt;xliff:g id=&quot;link_begin&quot;&gt;LINK_BEGIN&lt;/xliff:g&gt;Wi-Fi&lt;xliff:g id=&quot;link_end&quot;&gt;LINK_END&lt;/xliff:g&gt; 网路已开启，然后重试。&lt;/string&gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过Spannable实现色彩效果，ClickableSpan实现点击。</p>\n<p>对于resource string，通过添加标签位，来计算不同语言下，可点击的substring的index</p>\n<h2 id=\"工具类\"><a href=\"#工具类\" class=\"headerlink\" title=\"工具类\"></a>工具类</h2><pre><code class=\"java\">//LinkifyUtils.java\npublic class LinkifyUtils {\n    private static final String PLACE_HOLDER_LINK_BEGIN = &quot;LINK_BEGIN&quot;;\n    private static final String PLACE_HOLDER_LINK_END = &quot;LINK_END&quot;;\n\n    private LinkifyUtils() {\n    }\n\n    /** Interface that handles the click event of the link */\n    public interface OnClickListener {\n        void onClick();\n    }\n\n    /**\n     * Applies the text into the {@link TextView} and part of it a clickable link.\n     * The text surrounded with &quot;LINK_BEGIN&quot; and &quot;LINK_END&quot; will become a clickable link. Only\n     * supports at most one link.\n     * @return true if the link has been successfully applied, or false if the original text\n     *         contains no link place holders.\n     */\n    public static boolean linkify(TextView textView, StringBuilder text,\n                                  final OnClickListener listener) {\n        // Remove place-holders from the string and record their positions\n        final int beginIndex = text.indexOf(PLACE_HOLDER_LINK_BEGIN);\n        if (beginIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(beginIndex, beginIndex + PLACE_HOLDER_LINK_BEGIN.length());\n        final int endIndex = text.indexOf(PLACE_HOLDER_LINK_END);\n        if (endIndex == -1) {\n            textView.setText(text);\n            return false;\n        }\n        text.delete(endIndex, endIndex + PLACE_HOLDER_LINK_END.length());\n\n        textView.setText(text.toString(), TextView.BufferType.SPANNABLE);\n        textView.setMovementMethod(LinkMovementMethod.getInstance());\n        Spannable spannableContent = (Spannable) textView.getText();\n        ClickableSpan spannableLink = new ClickableSpan() {\n            @Override\n            public void onClick(View widget) {\n                listener.onClick();\n            }\n\n            @Override\n            public void updateDrawState(TextPaint ds) {\n                super.updateDrawState(ds);\n                ds.setUnderlineText(false);\n            }\n        };\n        spannableContent.setSpan(spannableLink, beginIndex, endIndex,\n                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        return true;\n    }\n}\n</code></pre>\n<h2 id=\"UI界面\"><a href=\"#UI界面\" class=\"headerlink\" title=\"UI界面\"></a>UI界面</h2><pre><code class=\"java\">//XXXActivity.java\n        StringBuilder contentBuilder = new StringBuilder();\n        contentBuilder.append(getText(R.string.no_internet));\n        LinkifyUtils.linkify(tvEmpty, contentBuilder, new LinkifyUtils.OnClickListener() {\n            @Override\n            public void onClick() {\n                Intent intent = new Intent();\n                intent.setClassName(&quot;com.android.settings&quot;, &quot;com.android.settings.wifi.WifiSettings&quot;);\n                startActivity(intent);\n            }\n        });\n</code></pre>\n<pre><code class=\"xml\">&lt;string name=&quot;no_internet&quot;&gt;No internet connection. Make sure  &lt;xliff:g id=&quot;link_begin&quot;&gt;LINK_BEGIN&lt;/xliff:g&gt;Wi-Fi&lt;xliff:g id=&quot;link_end&quot;&gt;LINK_END&lt;/xliff:g&gt; is turned on, then try again.&lt;/string&gt;\n\n&lt;string name=&quot;no_internet&quot;&gt;未连接到互联网。请确保  &lt;xliff:g id=&quot;link_begin&quot;&gt;LINK_BEGIN&lt;/xliff:g&gt;Wi-Fi&lt;xliff:g id=&quot;link_end&quot;&gt;LINK_END&lt;/xliff:g&gt; 网路已开启，然后重试。&lt;/string&gt;\n</code></pre>\n"},{"title":"开机导入Sim卡联系人","date":"2018-01-15T14:54:34.000Z","_content":"\n## ContactsProvider\n１.ContactsProvider.apk会启动一个广播接收器SystemStartReceiver来接收BOOT_COMPLETED的广播。\n\n２.ContactsProvider收到该广播后，将raw_contacts表里所有非本地联系人的数据都删除掉。\n然后读取当前是否存在Sim卡，若存在，则发SYNC_ICC_CARD_CONTACTS广播。\n\n3.SystemStartReceiver收到广播后启动一个thread来执行读取sim卡联系人，并发送MSG_NOTIFY_ICC_LOADING的message给主线程，主线程收到后发loadicccontacts广播。\n\n4.开始读取ICC数据库的内容，IccProvider中会执行loadFromEf()，获得IIccPhoneBook接口，通过AIDL调用getAdnRecordsInEf()方法，获取sim卡上的全部联系人数据，返回cursor并装载成ArrayList。\n\n5.子线程给主线程发送MSG_NOTIFY_ICC_CHECKFINISHING的message，表示ICC读取完毕。主线程会发loadicccontacts广播。\n\n6.子线程发送消息MSG_INSERT_NEW_CONTACTS给主线程，进行数据库批量处理的操作，即把几个ContentProviderOperation打包在一起，Transaction事务机制，通过applyBatch()方法，主线程将这些sim卡联系人逐个的添加到raw_contacts表和data表中.\n\n## Contacts\nContacts 收到loadicccontacts的广播，设置当前sim卡联系人已经开始读取，LOADICC_START\nContacts 收到loadicccontacts的广播，设置当前sim卡联系人已经读取完毕，LOADICC_FINISH\n","source":"_posts/Android/开机导入Sim卡联系人.md","raw":"---\ntitle: 开机导入Sim卡联系人\npermalink: import-Sim-card-contacts-when-boot\ncategories:\n  - Android\ntags:\n  - android\n  - 面试\n  - contacts\ndate: 2018-01-15 22:54:34\n---\n\n## ContactsProvider\n１.ContactsProvider.apk会启动一个广播接收器SystemStartReceiver来接收BOOT_COMPLETED的广播。\n\n２.ContactsProvider收到该广播后，将raw_contacts表里所有非本地联系人的数据都删除掉。\n然后读取当前是否存在Sim卡，若存在，则发SYNC_ICC_CARD_CONTACTS广播。\n\n3.SystemStartReceiver收到广播后启动一个thread来执行读取sim卡联系人，并发送MSG_NOTIFY_ICC_LOADING的message给主线程，主线程收到后发loadicccontacts广播。\n\n4.开始读取ICC数据库的内容，IccProvider中会执行loadFromEf()，获得IIccPhoneBook接口，通过AIDL调用getAdnRecordsInEf()方法，获取sim卡上的全部联系人数据，返回cursor并装载成ArrayList。\n\n5.子线程给主线程发送MSG_NOTIFY_ICC_CHECKFINISHING的message，表示ICC读取完毕。主线程会发loadicccontacts广播。\n\n6.子线程发送消息MSG_INSERT_NEW_CONTACTS给主线程，进行数据库批量处理的操作，即把几个ContentProviderOperation打包在一起，Transaction事务机制，通过applyBatch()方法，主线程将这些sim卡联系人逐个的添加到raw_contacts表和data表中.\n\n## Contacts\nContacts 收到loadicccontacts的广播，设置当前sim卡联系人已经开始读取，LOADICC_START\nContacts 收到loadicccontacts的广播，设置当前sim卡联系人已经读取完毕，LOADICC_FINISH\n","slug":"import-Sim-card-contacts-when-boot","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjks8kndj0006xwujyaf8l5u6","content":"<h2 id=\"ContactsProvider\"><a href=\"#ContactsProvider\" class=\"headerlink\" title=\"ContactsProvider\"></a>ContactsProvider</h2><p>１.ContactsProvider.apk会启动一个广播接收器SystemStartReceiver来接收BOOT_COMPLETED的广播。</p>\n<p>２.ContactsProvider收到该广播后，将raw_contacts表里所有非本地联系人的数据都删除掉。<br>然后读取当前是否存在Sim卡，若存在，则发SYNC_ICC_CARD_CONTACTS广播。</p>\n<p>3.SystemStartReceiver收到广播后启动一个thread来执行读取sim卡联系人，并发送MSG_NOTIFY_ICC_LOADING的message给主线程，主线程收到后发loadicccontacts广播。</p>\n<p>4.开始读取ICC数据库的内容，IccProvider中会执行loadFromEf()，获得IIccPhoneBook接口，通过AIDL调用getAdnRecordsInEf()方法，获取sim卡上的全部联系人数据，返回cursor并装载成ArrayList。</p>\n<p>5.子线程给主线程发送MSG_NOTIFY_ICC_CHECKFINISHING的message，表示ICC读取完毕。主线程会发loadicccontacts广播。</p>\n<p>6.子线程发送消息MSG_INSERT_NEW_CONTACTS给主线程，进行数据库批量处理的操作，即把几个ContentProviderOperation打包在一起，Transaction事务机制，通过applyBatch()方法，主线程将这些sim卡联系人逐个的添加到raw_contacts表和data表中.</p>\n<h2 id=\"Contacts\"><a href=\"#Contacts\" class=\"headerlink\" title=\"Contacts\"></a>Contacts</h2><p>Contacts 收到loadicccontacts的广播，设置当前sim卡联系人已经开始读取，LOADICC_START<br>Contacts 收到loadicccontacts的广播，设置当前sim卡联系人已经读取完毕，LOADICC_FINISH</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ContactsProvider\"><a href=\"#ContactsProvider\" class=\"headerlink\" title=\"ContactsProvider\"></a>ContactsProvider</h2><p>１.ContactsProvider.apk会启动一个广播接收器SystemStartReceiver来接收BOOT_COMPLETED的广播。</p>\n<p>２.ContactsProvider收到该广播后，将raw_contacts表里所有非本地联系人的数据都删除掉。<br>然后读取当前是否存在Sim卡，若存在，则发SYNC_ICC_CARD_CONTACTS广播。</p>\n<p>3.SystemStartReceiver收到广播后启动一个thread来执行读取sim卡联系人，并发送MSG_NOTIFY_ICC_LOADING的message给主线程，主线程收到后发loadicccontacts广播。</p>\n<p>4.开始读取ICC数据库的内容，IccProvider中会执行loadFromEf()，获得IIccPhoneBook接口，通过AIDL调用getAdnRecordsInEf()方法，获取sim卡上的全部联系人数据，返回cursor并装载成ArrayList。</p>\n<p>5.子线程给主线程发送MSG_NOTIFY_ICC_CHECKFINISHING的message，表示ICC读取完毕。主线程会发loadicccontacts广播。</p>\n<p>6.子线程发送消息MSG_INSERT_NEW_CONTACTS给主线程，进行数据库批量处理的操作，即把几个ContentProviderOperation打包在一起，Transaction事务机制，通过applyBatch()方法，主线程将这些sim卡联系人逐个的添加到raw_contacts表和data表中.</p>\n<h2 id=\"Contacts\"><a href=\"#Contacts\" class=\"headerlink\" title=\"Contacts\"></a>Contacts</h2><p>Contacts 收到loadicccontacts的广播，设置当前sim卡联系人已经开始读取，LOADICC_START<br>Contacts 收到loadicccontacts的广播，设置当前sim卡联系人已经读取完毕，LOADICC_FINISH</p>\n"},{"title":"跨进程通讯的4种方式","date":"2015-08-10T14:45:19.000Z","_content":"\n## 方式一：访问其他应用程序的Activity\n\n在android系统中有很多应用程序提供了可以跨进程访问的Activity，例如，下面的代码可以直接调用拨打电话的Activity。\nIntent callIntent = new Intent(Intent.ACTION_CALL, Uri.parse(\"tel:12345678\" );\nstartActivity(callIntent);\n\nandroid:exported：\n\ndefault value的值是根据是否有<intent-filter>来决定的，有的话，默认值就是true，没有的话默认值就是false；\n\n如果被设置为了false，那么这个Activity将只会被当前Application或者拥有同样user ID的Application的组件调用。\n\n## 方式二：Content Provider\n使用文件或数据库SqlLite来存储数据\n\n## 方式三：广播（Broadcast）\n## 方式四：AIDL服务\nAIDL 并不需要权限\n","source":"_posts/Android/跨进程通讯的4种方式.md","raw":"---\ntitle: 跨进程通讯的4种方式\npermalink: access-across-processes\ncategories:\n  - Android\ntags:\n  - android\n  - 面试\ndate: 2015-08-10 22:45:19\n---\n\n## 方式一：访问其他应用程序的Activity\n\n在android系统中有很多应用程序提供了可以跨进程访问的Activity，例如，下面的代码可以直接调用拨打电话的Activity。\nIntent callIntent = new Intent(Intent.ACTION_CALL, Uri.parse(\"tel:12345678\" );\nstartActivity(callIntent);\n\nandroid:exported：\n\ndefault value的值是根据是否有<intent-filter>来决定的，有的话，默认值就是true，没有的话默认值就是false；\n\n如果被设置为了false，那么这个Activity将只会被当前Application或者拥有同样user ID的Application的组件调用。\n\n## 方式二：Content Provider\n使用文件或数据库SqlLite来存储数据\n\n## 方式三：广播（Broadcast）\n## 方式四：AIDL服务\nAIDL 并不需要权限\n","slug":"access-across-processes","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjks8kndm000axwujad4077zu","content":"<h2 id=\"方式一：访问其他应用程序的Activity\"><a href=\"#方式一：访问其他应用程序的Activity\" class=\"headerlink\" title=\"方式一：访问其他应用程序的Activity\"></a>方式一：访问其他应用程序的Activity</h2><p>在android系统中有很多应用程序提供了可以跨进程访问的Activity，例如，下面的代码可以直接调用拨打电话的Activity。<br>Intent callIntent = new Intent(Intent.ACTION_CALL, Uri.parse(“tel:12345678” );<br>startActivity(callIntent);</p>\n<p>android:exported：</p>\n<p>default value的值是根据是否有<intent-filter>来决定的，有的话，默认值就是true，没有的话默认值就是false；</intent-filter></p>\n<p>如果被设置为了false，那么这个Activity将只会被当前Application或者拥有同样user ID的Application的组件调用。</p>\n<h2 id=\"方式二：Content-Provider\"><a href=\"#方式二：Content-Provider\" class=\"headerlink\" title=\"方式二：Content Provider\"></a>方式二：Content Provider</h2><p>使用文件或数据库SqlLite来存储数据</p>\n<h2 id=\"方式三：广播（Broadcast）\"><a href=\"#方式三：广播（Broadcast）\" class=\"headerlink\" title=\"方式三：广播（Broadcast）\"></a>方式三：广播（Broadcast）</h2><h2 id=\"方式四：AIDL服务\"><a href=\"#方式四：AIDL服务\" class=\"headerlink\" title=\"方式四：AIDL服务\"></a>方式四：AIDL服务</h2><p>AIDL 并不需要权限</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"方式一：访问其他应用程序的Activity\"><a href=\"#方式一：访问其他应用程序的Activity\" class=\"headerlink\" title=\"方式一：访问其他应用程序的Activity\"></a>方式一：访问其他应用程序的Activity</h2><p>在android系统中有很多应用程序提供了可以跨进程访问的Activity，例如，下面的代码可以直接调用拨打电话的Activity。<br>Intent callIntent = new Intent(Intent.ACTION_CALL, Uri.parse(“tel:12345678” );<br>startActivity(callIntent);</p>\n<p>android:exported：</p>\n<p>default value的值是根据是否有<intent-filter>来决定的，有的话，默认值就是true，没有的话默认值就是false；</intent-filter></p>\n<p>如果被设置为了false，那么这个Activity将只会被当前Application或者拥有同样user ID的Application的组件调用。</p>\n<h2 id=\"方式二：Content-Provider\"><a href=\"#方式二：Content-Provider\" class=\"headerlink\" title=\"方式二：Content Provider\"></a>方式二：Content Provider</h2><p>使用文件或数据库SqlLite来存储数据</p>\n<h2 id=\"方式三：广播（Broadcast）\"><a href=\"#方式三：广播（Broadcast）\" class=\"headerlink\" title=\"方式三：广播（Broadcast）\"></a>方式三：广播（Broadcast）</h2><h2 id=\"方式四：AIDL服务\"><a href=\"#方式四：AIDL服务\" class=\"headerlink\" title=\"方式四：AIDL服务\"></a>方式四：AIDL服务</h2><p>AIDL 并不需要权限</p>\n"},{"title":"联系人号码模糊查询","date":"2018-01-01T03:37:02.000Z","_content":"\nAOSP的联系人查询,匹配的号码是从头开始匹配,不支持任意子串的匹配.eg.1234567, 123能匹配, 456不能匹配。\n\n首先由于这是个运营商的定制feature,加入的相应的overlay的flag.只有是该运营商才会进行模糊查询。\n\n具体的流程就是修改ContactsProvider中的query流程. 原本的是match完全匹配。\n\n主体部分：\n先是进行判断,如果是该运营商,就修改查询的条件, 把字串前后加上通配符'%', 通过like关键字来进行模糊匹配.并返回结果。\n如果不是该运营商, 就执行之前的默认的操作,并返回结果。\n\n这样就实现了联系人号码模糊查询。\n","source":"_posts/Android/联系人号码模糊查询.md","raw":"---\ntitle: 联系人号码模糊查询\npermalink: contacts-phone-number-fuzzy-search\ncategories:\n  - Android\ntags:\n  - android\n  - contacts\ndate: 2018-01-01 11:37:02\n---\n\nAOSP的联系人查询,匹配的号码是从头开始匹配,不支持任意子串的匹配.eg.1234567, 123能匹配, 456不能匹配。\n\n首先由于这是个运营商的定制feature,加入的相应的overlay的flag.只有是该运营商才会进行模糊查询。\n\n具体的流程就是修改ContactsProvider中的query流程. 原本的是match完全匹配。\n\n主体部分：\n先是进行判断,如果是该运营商,就修改查询的条件, 把字串前后加上通配符'%', 通过like关键字来进行模糊匹配.并返回结果。\n如果不是该运营商, 就执行之前的默认的操作,并返回结果。\n\n这样就实现了联系人号码模糊查询。\n","slug":"contacts-phone-number-fuzzy-search","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjks8kndn000bxwujhl6n1gri","content":"<p>AOSP的联系人查询,匹配的号码是从头开始匹配,不支持任意子串的匹配.eg.1234567, 123能匹配, 456不能匹配。</p>\n<p>首先由于这是个运营商的定制feature,加入的相应的overlay的flag.只有是该运营商才会进行模糊查询。</p>\n<p>具体的流程就是修改ContactsProvider中的query流程. 原本的是match完全匹配。</p>\n<p>主体部分：<br>先是进行判断,如果是该运营商,就修改查询的条件, 把字串前后加上通配符’%’, 通过like关键字来进行模糊匹配.并返回结果。<br>如果不是该运营商, 就执行之前的默认的操作,并返回结果。</p>\n<p>这样就实现了联系人号码模糊查询。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>AOSP的联系人查询,匹配的号码是从头开始匹配,不支持任意子串的匹配.eg.1234567, 123能匹配, 456不能匹配。</p>\n<p>首先由于这是个运营商的定制feature,加入的相应的overlay的flag.只有是该运营商才会进行模糊查询。</p>\n<p>具体的流程就是修改ContactsProvider中的query流程. 原本的是match完全匹配。</p>\n<p>主体部分：<br>先是进行判断,如果是该运营商,就修改查询的条件, 把字串前后加上通配符’%’, 通过like关键字来进行模糊匹配.并返回结果。<br>如果不是该运营商, 就执行之前的默认的操作,并返回结果。</p>\n<p>这样就实现了联系人号码模糊查询。</p>\n"},{"title":"blog init","date":"2017-12-23T06:53:20.000Z","_content":"\n```bash\n#!/bin/\nmkdir ~/hexo\ncd ~/hexo\ngit clone https://github.com/steinswang/blog.git\ngit clone https://github.com/steinswang/steinswang.github.io.git\n```\n","source":"_posts/init/blog-init.md","raw":"---\n\ntitle: blog init\npermalink: blog-init\ncategories:\n  - init\ntags:\n  - tools\ndate: 2017-12-23 14:53:20\n---\n\n```bash\n#!/bin/\nmkdir ~/hexo\ncd ~/hexo\ngit clone https://github.com/steinswang/blog.git\ngit clone https://github.com/steinswang/steinswang.github.io.git\n```\n","slug":"blog-init","published":1,"updated":"2018-08-12T13:59:32.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjks8kndp000fxwujbeisqezs","content":"<pre><code class=\"bash\">#!/bin/\nmkdir ~/hexo\ncd ~/hexo\ngit clone https://github.com/steinswang/blog.git\ngit clone https://github.com/steinswang/steinswang.github.io.git\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<pre><code class=\"bash\">#!/bin/\nmkdir ~/hexo\ncd ~/hexo\ngit clone https://github.com/steinswang/blog.git\ngit clone https://github.com/steinswang/steinswang.github.io.git\n</code></pre>\n"},{"title":"Hexo+GitHub Pages搭建属于自己的blog","date":"2018-01-03T12:34:01.000Z","_content":"\nHexo是一个快速，简单，功能强大的开源博客框架-》[官网](https://hexo.io/)\nGitHub Pages 是一个不受限的网站空间。\n两者相得益彰。给那些喜欢自己折腾的人提供一些借鉴。\n<!--more -->\n## 搭建过程\n### 环境介绍\n博主使用系统：Ubuntu 14.04\n安装 node与npm\n### 安装Hexo\n```bash\nnpm install hexo-cli -g\n```\n### 初始化blog\n```bash\nhexo init blog\n```\n至此，本地blog已经创建完成，是不是很简单，简单到没朋友\n### 选择主题\n可以在[hexo官网](https://hexo.io/themes/)查看自己喜欢的主题\n通过git clone [url] themes/xxx 将主题克隆到本地，\n修改 `_config.yml` 中的theme：xxx\n### 常用命令\n```bash\n#创建一个新的文章\n$ hexo new \"文章名\"\n\n#生成静态文件\n$ hexo generate\n\n#将一个草稿发布出去\n$ hexo publish [layout] <filename>\n\n#启动一个本地服务器\n$ hexo server\n```\n更多命令移步[官方文档](https://hexo.io/docs/commands.html)\n### 搭建github pages\n本地blog已经搭建完成，现在可以发布到github pages上\n#### 注册github账户\n到[github官网](https://github.com/)注册一个github账户\n#### 配置登录免密码\n移步 {% post_link 一个客户端设置多个github账号 %}\n#### 创建github远程仓库\n在github上创建一个仓库 `xxx.github.io` xxx为自己的github用户名\n#### 安装插件\n```bash\n$ npm install hexo-deployer-git --save\n```\n#### 配置Hexo\n修改 `_comfig.yml`,xxx为你的用户名\n```xml\ndeploy:\n   type: git\n   repo: git@github.com:xxx/xxx.github.io.git\n   branch: master\n```\n#### 推送服务器\n```bash\n$ hexo deploy\n```\n>若出现`ERROR Deployer not found: git`报错，请执行上面安装插件步骤\n\n#### 测试\n打开 `xxx.github.io` ，就能看到你的blog了\n","source":"_posts/工具/Hexo-GitHub-Pages搭建属于自己的blog.md","raw":"---\ntitle: Hexo+GitHub Pages搭建属于自己的blog\npermalink: Hexo-GitHub-Pages-Establish-blog\ncategories:\n- 工具\ntags:\n- hexo\n- blog\ndate: 2018-01-03 20:34:01\n---\n\nHexo是一个快速，简单，功能强大的开源博客框架-》[官网](https://hexo.io/)\nGitHub Pages 是一个不受限的网站空间。\n两者相得益彰。给那些喜欢自己折腾的人提供一些借鉴。\n<!--more -->\n## 搭建过程\n### 环境介绍\n博主使用系统：Ubuntu 14.04\n安装 node与npm\n### 安装Hexo\n```bash\nnpm install hexo-cli -g\n```\n### 初始化blog\n```bash\nhexo init blog\n```\n至此，本地blog已经创建完成，是不是很简单，简单到没朋友\n### 选择主题\n可以在[hexo官网](https://hexo.io/themes/)查看自己喜欢的主题\n通过git clone [url] themes/xxx 将主题克隆到本地，\n修改 `_config.yml` 中的theme：xxx\n### 常用命令\n```bash\n#创建一个新的文章\n$ hexo new \"文章名\"\n\n#生成静态文件\n$ hexo generate\n\n#将一个草稿发布出去\n$ hexo publish [layout] <filename>\n\n#启动一个本地服务器\n$ hexo server\n```\n更多命令移步[官方文档](https://hexo.io/docs/commands.html)\n### 搭建github pages\n本地blog已经搭建完成，现在可以发布到github pages上\n#### 注册github账户\n到[github官网](https://github.com/)注册一个github账户\n#### 配置登录免密码\n移步 {% post_link 一个客户端设置多个github账号 %}\n#### 创建github远程仓库\n在github上创建一个仓库 `xxx.github.io` xxx为自己的github用户名\n#### 安装插件\n```bash\n$ npm install hexo-deployer-git --save\n```\n#### 配置Hexo\n修改 `_comfig.yml`,xxx为你的用户名\n```xml\ndeploy:\n   type: git\n   repo: git@github.com:xxx/xxx.github.io.git\n   branch: master\n```\n#### 推送服务器\n```bash\n$ hexo deploy\n```\n>若出现`ERROR Deployer not found: git`报错，请执行上面安装插件步骤\n\n#### 测试\n打开 `xxx.github.io` ，就能看到你的blog了\n","slug":"Hexo-GitHub-Pages-Establish-blog","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjks8kndq000ixwuje84kxut9","content":"<p>Hexo是一个快速，简单，功能强大的开源博客框架-》<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">官网</a><br>GitHub Pages 是一个不受限的网站空间。<br>两者相得益彰。给那些喜欢自己折腾的人提供一些借鉴。<br><a id=\"more\"></a></p>\n<h2 id=\"搭建过程\"><a href=\"#搭建过程\" class=\"headerlink\" title=\"搭建过程\"></a>搭建过程</h2><h3 id=\"环境介绍\"><a href=\"#环境介绍\" class=\"headerlink\" title=\"环境介绍\"></a>环境介绍</h3><p>博主使用系统：Ubuntu 14.04<br>安装 node与npm</p>\n<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><pre><code class=\"bash\">npm install hexo-cli -g\n</code></pre>\n<h3 id=\"初始化blog\"><a href=\"#初始化blog\" class=\"headerlink\" title=\"初始化blog\"></a>初始化blog</h3><pre><code class=\"bash\">hexo init blog\n</code></pre>\n<p>至此，本地blog已经创建完成，是不是很简单，简单到没朋友</p>\n<h3 id=\"选择主题\"><a href=\"#选择主题\" class=\"headerlink\" title=\"选择主题\"></a>选择主题</h3><p>可以在<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">hexo官网</a>查看自己喜欢的主题<br>通过git clone [url] themes/xxx 将主题克隆到本地，<br>修改 <code>_config.yml</code> 中的theme：xxx</p>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><pre><code class=\"bash\">#创建一个新的文章\n$ hexo new &quot;文章名&quot;\n\n#生成静态文件\n$ hexo generate\n\n#将一个草稿发布出去\n$ hexo publish [layout] &lt;filename&gt;\n\n#启动一个本地服务器\n$ hexo server\n</code></pre>\n<p>更多命令移步<a href=\"https://hexo.io/docs/commands.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h3 id=\"搭建github-pages\"><a href=\"#搭建github-pages\" class=\"headerlink\" title=\"搭建github pages\"></a>搭建github pages</h3><p>本地blog已经搭建完成，现在可以发布到github pages上</p>\n<h4 id=\"注册github账户\"><a href=\"#注册github账户\" class=\"headerlink\" title=\"注册github账户\"></a>注册github账户</h4><p>到<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">github官网</a>注册一个github账户</p>\n<h4 id=\"配置登录免密码\"><a href=\"#配置登录免密码\" class=\"headerlink\" title=\"配置登录免密码\"></a>配置登录免密码</h4><p>移步 </p>\n<h4 id=\"创建github远程仓库\"><a href=\"#创建github远程仓库\" class=\"headerlink\" title=\"创建github远程仓库\"></a>创建github远程仓库</h4><p>在github上创建一个仓库 <code>xxx.github.io</code> xxx为自己的github用户名</p>\n<h4 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h4><pre><code class=\"bash\">$ npm install hexo-deployer-git --save\n</code></pre>\n<h4 id=\"配置Hexo\"><a href=\"#配置Hexo\" class=\"headerlink\" title=\"配置Hexo\"></a>配置Hexo</h4><p>修改 <code>_comfig.yml</code>,xxx为你的用户名</p>\n<pre><code class=\"xml\">deploy:\n   type: git\n   repo: git@github.com:xxx/xxx.github.io.git\n   branch: master\n</code></pre>\n<h4 id=\"推送服务器\"><a href=\"#推送服务器\" class=\"headerlink\" title=\"推送服务器\"></a>推送服务器</h4><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<blockquote>\n<p>若出现<code>ERROR Deployer not found: git</code>报错，请执行上面安装插件步骤</p>\n</blockquote>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><p>打开 <code>xxx.github.io</code> ，就能看到你的blog了</p>\n","site":{"data":{}},"excerpt":"<p>Hexo是一个快速，简单，功能强大的开源博客框架-》<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">官网</a><br>GitHub Pages 是一个不受限的网站空间。<br>两者相得益彰。给那些喜欢自己折腾的人提供一些借鉴。<br>","more":"</p>\n<h2 id=\"搭建过程\"><a href=\"#搭建过程\" class=\"headerlink\" title=\"搭建过程\"></a>搭建过程</h2><h3 id=\"环境介绍\"><a href=\"#环境介绍\" class=\"headerlink\" title=\"环境介绍\"></a>环境介绍</h3><p>博主使用系统：Ubuntu 14.04<br>安装 node与npm</p>\n<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><pre><code class=\"bash\">npm install hexo-cli -g\n</code></pre>\n<h3 id=\"初始化blog\"><a href=\"#初始化blog\" class=\"headerlink\" title=\"初始化blog\"></a>初始化blog</h3><pre><code class=\"bash\">hexo init blog\n</code></pre>\n<p>至此，本地blog已经创建完成，是不是很简单，简单到没朋友</p>\n<h3 id=\"选择主题\"><a href=\"#选择主题\" class=\"headerlink\" title=\"选择主题\"></a>选择主题</h3><p>可以在<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">hexo官网</a>查看自己喜欢的主题<br>通过git clone [url] themes/xxx 将主题克隆到本地，<br>修改 <code>_config.yml</code> 中的theme：xxx</p>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><pre><code class=\"bash\">#创建一个新的文章\n$ hexo new &quot;文章名&quot;\n\n#生成静态文件\n$ hexo generate\n\n#将一个草稿发布出去\n$ hexo publish [layout] &lt;filename&gt;\n\n#启动一个本地服务器\n$ hexo server\n</code></pre>\n<p>更多命令移步<a href=\"https://hexo.io/docs/commands.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h3 id=\"搭建github-pages\"><a href=\"#搭建github-pages\" class=\"headerlink\" title=\"搭建github pages\"></a>搭建github pages</h3><p>本地blog已经搭建完成，现在可以发布到github pages上</p>\n<h4 id=\"注册github账户\"><a href=\"#注册github账户\" class=\"headerlink\" title=\"注册github账户\"></a>注册github账户</h4><p>到<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">github官网</a>注册一个github账户</p>\n<h4 id=\"配置登录免密码\"><a href=\"#配置登录免密码\" class=\"headerlink\" title=\"配置登录免密码\"></a>配置登录免密码</h4><p>移步 </p>\n<h4 id=\"创建github远程仓库\"><a href=\"#创建github远程仓库\" class=\"headerlink\" title=\"创建github远程仓库\"></a>创建github远程仓库</h4><p>在github上创建一个仓库 <code>xxx.github.io</code> xxx为自己的github用户名</p>\n<h4 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h4><pre><code class=\"bash\">$ npm install hexo-deployer-git --save\n</code></pre>\n<h4 id=\"配置Hexo\"><a href=\"#配置Hexo\" class=\"headerlink\" title=\"配置Hexo\"></a>配置Hexo</h4><p>修改 <code>_comfig.yml</code>,xxx为你的用户名</p>\n<pre><code class=\"xml\">deploy:\n   type: git\n   repo: git@github.com:xxx/xxx.github.io.git\n   branch: master\n</code></pre>\n<h4 id=\"推送服务器\"><a href=\"#推送服务器\" class=\"headerlink\" title=\"推送服务器\"></a>推送服务器</h4><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<blockquote>\n<p>若出现<code>ERROR Deployer not found: git</code>报错，请执行上面安装插件步骤</p>\n</blockquote>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><p>打开 <code>xxx.github.io</code> ，就能看到你的blog了</p>"},{"title":"工具软件&插件","date":"2018-01-23T06:53:20.000Z","_content":"\n## sublime\n\n### package control\nSublime Text 3\n```javascript\nimport urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n```\n\nSublime Text 2\n```javascript\nimport urllib2,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), 'wb' ).write(by) if dh == h else None; print('Error validating download (got %s instead of %s), please try manual install' % (dh, h) if dh != h else 'Please restart Sublime Text to finish installation')\n```\n### Ubuntu下Sublime Text 3输入中文issue\n\n\n```bash\ngit clone https://github.com/lyfeyaj/sublime-text-imfix.git\ncd ~/sublime-text-imfix\n./sublime-imfix\n```\n","source":"_posts/工具/工具软件-插件.md","raw":"---\ntitle: 工具软件&插件\npermalink: tool-softwares-and-plugins\ncategories:\n  - 工具\ntags:\n  - tools\ndate: 2018-01-23 14:53:20\n---\n\n## sublime\n\n### package control\nSublime Text 3\n```javascript\nimport urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n```\n\nSublime Text 2\n```javascript\nimport urllib2,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), 'wb' ).write(by) if dh == h else None; print('Error validating download (got %s instead of %s), please try manual install' % (dh, h) if dh != h else 'Please restart Sublime Text to finish installation')\n```\n### Ubuntu下Sublime Text 3输入中文issue\n\n\n```bash\ngit clone https://github.com/lyfeyaj/sublime-text-imfix.git\ncd ~/sublime-text-imfix\n./sublime-imfix\n```\n","slug":"tool-softwares-and-plugins","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjks8knds000nxwujtw3gql37","content":"<h2 id=\"sublime\"><a href=\"#sublime\" class=\"headerlink\" title=\"sublime\"></a>sublime</h2><h3 id=\"package-control\"><a href=\"#package-control\" class=\"headerlink\" title=\"package control\"></a>package control</h3><p>Sublime Text 3</p>\n<pre><code class=\"javascript\">import urllib.request,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)\n</code></pre>\n<p>Sublime Text 2</p>\n<pre><code class=\"javascript\">import urllib2,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &#39;wb&#39; ).write(by) if dh == h else None; print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h) if dh != h else &#39;Please restart Sublime Text to finish installation&#39;)\n</code></pre>\n<h3 id=\"Ubuntu下Sublime-Text-3输入中文issue\"><a href=\"#Ubuntu下Sublime-Text-3输入中文issue\" class=\"headerlink\" title=\"Ubuntu下Sublime Text 3输入中文issue\"></a>Ubuntu下Sublime Text 3输入中文issue</h3><pre><code class=\"bash\">git clone https://github.com/lyfeyaj/sublime-text-imfix.git\ncd ~/sublime-text-imfix\n./sublime-imfix\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"sublime\"><a href=\"#sublime\" class=\"headerlink\" title=\"sublime\"></a>sublime</h2><h3 id=\"package-control\"><a href=\"#package-control\" class=\"headerlink\" title=\"package control\"></a>package control</h3><p>Sublime Text 3</p>\n<pre><code class=\"javascript\">import urllib.request,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)\n</code></pre>\n<p>Sublime Text 2</p>\n<pre><code class=\"javascript\">import urllib2,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &#39;wb&#39; ).write(by) if dh == h else None; print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h) if dh != h else &#39;Please restart Sublime Text to finish installation&#39;)\n</code></pre>\n<h3 id=\"Ubuntu下Sublime-Text-3输入中文issue\"><a href=\"#Ubuntu下Sublime-Text-3输入中文issue\" class=\"headerlink\" title=\"Ubuntu下Sublime Text 3输入中文issue\"></a>Ubuntu下Sublime Text 3输入中文issue</h3><pre><code class=\"bash\">git clone https://github.com/lyfeyaj/sublime-text-imfix.git\ncd ~/sublime-text-imfix\n./sublime-imfix\n</code></pre>\n"},{"title":"快捷键说明","date":"2017-12-30T08:45:31.000Z","_content":"\n## 说明\n### 搜索框\n| Key | Descption |\n| :- | :- |\n| ESC | 1.如果输入框有内容，清除内容<br>2.如果输入框无内容，失去焦点 |\n| i/I | 获取焦点 |\n| 下 | 向下选择文章 |\n| 上 | 向上选择文章 |\n| 回车 | 打开当前选中的文章，若没有，则默认打开第一个 |\n\n### 全局\n| Key | Descption |\n| :- | :- |\n| s/S | 全屏/取消全屏 |\n| w/W | 打开/关闭文章目录 |\n| j/J | 向下滑动 |\n| k/K | 向上滑动 |\n| gg/GG | 到最顶端 |\n| shift+G/g | 到最下端 |\n\n","source":"_posts/工具/快捷键.md","raw":"---\ntitle: 快捷键说明\ndate: 2017-12-30 16:45:31\npermalink: 3-hexo-shortcuts\ncategories:\n- 工具\ntags:\n- hexo\n- 3-hexo\n---\n\n## 说明\n### 搜索框\n| Key | Descption |\n| :- | :- |\n| ESC | 1.如果输入框有内容，清除内容<br>2.如果输入框无内容，失去焦点 |\n| i/I | 获取焦点 |\n| 下 | 向下选择文章 |\n| 上 | 向上选择文章 |\n| 回车 | 打开当前选中的文章，若没有，则默认打开第一个 |\n\n### 全局\n| Key | Descption |\n| :- | :- |\n| s/S | 全屏/取消全屏 |\n| w/W | 打开/关闭文章目录 |\n| j/J | 向下滑动 |\n| k/K | 向上滑动 |\n| gg/GG | 到最顶端 |\n| shift+G/g | 到最下端 |\n\n","slug":"3-hexo-shortcuts","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjks8kndt000qxwujnuc5dfoq","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><h3 id=\"搜索框\"><a href=\"#搜索框\" class=\"headerlink\" title=\"搜索框\"></a>搜索框</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Key</th>\n<th style=\"text-align:left\">Descption</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ESC</td>\n<td style=\"text-align:left\">1.如果输入框有内容，清除内容<br>2.如果输入框无内容，失去焦点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">i/I</td>\n<td style=\"text-align:left\">获取焦点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">下</td>\n<td style=\"text-align:left\">向下选择文章</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">上</td>\n<td style=\"text-align:left\">向上选择文章</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">回车</td>\n<td style=\"text-align:left\">打开当前选中的文章，若没有，则默认打开第一个</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"全局\"><a href=\"#全局\" class=\"headerlink\" title=\"全局\"></a>全局</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Key</th>\n<th style=\"text-align:left\">Descption</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">s/S</td>\n<td style=\"text-align:left\">全屏/取消全屏</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">w/W</td>\n<td style=\"text-align:left\">打开/关闭文章目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">j/J</td>\n<td style=\"text-align:left\">向下滑动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">k/K</td>\n<td style=\"text-align:left\">向上滑动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">gg/GG</td>\n<td style=\"text-align:left\">到最顶端</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">shift+G/g</td>\n<td style=\"text-align:left\">到最下端</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><h3 id=\"搜索框\"><a href=\"#搜索框\" class=\"headerlink\" title=\"搜索框\"></a>搜索框</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Key</th>\n<th style=\"text-align:left\">Descption</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ESC</td>\n<td style=\"text-align:left\">1.如果输入框有内容，清除内容<br>2.如果输入框无内容，失去焦点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">i/I</td>\n<td style=\"text-align:left\">获取焦点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">下</td>\n<td style=\"text-align:left\">向下选择文章</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">上</td>\n<td style=\"text-align:left\">向上选择文章</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">回车</td>\n<td style=\"text-align:left\">打开当前选中的文章，若没有，则默认打开第一个</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"全局\"><a href=\"#全局\" class=\"headerlink\" title=\"全局\"></a>全局</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Key</th>\n<th style=\"text-align:left\">Descption</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">s/S</td>\n<td style=\"text-align:left\">全屏/取消全屏</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">w/W</td>\n<td style=\"text-align:left\">打开/关闭文章目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">j/J</td>\n<td style=\"text-align:left\">向下滑动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">k/K</td>\n<td style=\"text-align:left\">向上滑动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">gg/GG</td>\n<td style=\"text-align:left\">到最顶端</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">shift+G/g</td>\n<td style=\"text-align:left\">到最下端</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"工具软件keys","date":"2018-01-23T06:35:48.000Z","_content":"\n## markdownpad pro:\n\n邮箱：\n```xml\nSoar360@live.com\n```\n\n授权秘钥：\n```xml\nGBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==\n```\n\n## sublime text3:\n\n```xml\n----- BEGIN LICENSE -----\neldon\nSingle User License\nEA7E-1122628\nC0360740 20724B8A 30420C09 6D7E046F\n3F5D5FBB 17EF95DA 2BA7BB27 CCB14947\n27A316BE 8BCF4BC0 252FB8FF FD97DF71\nB11A1DA9 F7119CA0 31984BB9 7D71700C\n2C728BF8 B952E5F5 B941FF64 6D7979DA\nB8EB32F8 8D415F8E F16FE657 A35381CC\n290E2905 96E81236 63D2B06D E5F01A69\n84174B79 7C467714 641A9013 94CA7162\n------ END LICENSE ------\n```\n","source":"_posts/工具/工具软件keys.md","raw":"---\ntitle: 工具软件keys\npermalink: tool-software-keys\ncategories:\n  - 工具\ntags:\n  - tools\n  - keys\ndate: 2018-01-23 14:35:48\n---\n\n## markdownpad pro:\n\n邮箱：\n```xml\nSoar360@live.com\n```\n\n授权秘钥：\n```xml\nGBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==\n```\n\n## sublime text3:\n\n```xml\n----- BEGIN LICENSE -----\neldon\nSingle User License\nEA7E-1122628\nC0360740 20724B8A 30420C09 6D7E046F\n3F5D5FBB 17EF95DA 2BA7BB27 CCB14947\n27A316BE 8BCF4BC0 252FB8FF FD97DF71\nB11A1DA9 F7119CA0 31984BB9 7D71700C\n2C728BF8 B952E5F5 B941FF64 6D7979DA\nB8EB32F8 8D415F8E F16FE657 A35381CC\n290E2905 96E81236 63D2B06D E5F01A69\n84174B79 7C467714 641A9013 94CA7162\n------ END LICENSE ------\n```\n","slug":"tool-software-keys","published":1,"updated":"2018-08-01T02:07:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjks8kndu000uxwujtltjty2j","content":"<h2 id=\"markdownpad-pro\"><a href=\"#markdownpad-pro\" class=\"headerlink\" title=\"markdownpad pro:\"></a>markdownpad pro:</h2><p>邮箱：</p>\n<pre><code class=\"xml\">Soar360@live.com\n</code></pre>\n<p>授权秘钥：</p>\n<pre><code class=\"xml\">GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==\n</code></pre>\n<h2 id=\"sublime-text3\"><a href=\"#sublime-text3\" class=\"headerlink\" title=\"sublime text3:\"></a>sublime text3:</h2><pre><code class=\"xml\">----- BEGIN LICENSE -----\neldon\nSingle User License\nEA7E-1122628\nC0360740 20724B8A 30420C09 6D7E046F\n3F5D5FBB 17EF95DA 2BA7BB27 CCB14947\n27A316BE 8BCF4BC0 252FB8FF FD97DF71\nB11A1DA9 F7119CA0 31984BB9 7D71700C\n2C728BF8 B952E5F5 B941FF64 6D7979DA\nB8EB32F8 8D415F8E F16FE657 A35381CC\n290E2905 96E81236 63D2B06D E5F01A69\n84174B79 7C467714 641A9013 94CA7162\n------ END LICENSE ------\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"markdownpad-pro\"><a href=\"#markdownpad-pro\" class=\"headerlink\" title=\"markdownpad pro:\"></a>markdownpad pro:</h2><p>邮箱：</p>\n<pre><code class=\"xml\">Soar360@live.com\n</code></pre>\n<p>授权秘钥：</p>\n<pre><code class=\"xml\">GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==\n</code></pre>\n<h2 id=\"sublime-text3\"><a href=\"#sublime-text3\" class=\"headerlink\" title=\"sublime text3:\"></a>sublime text3:</h2><pre><code class=\"xml\">----- BEGIN LICENSE -----\neldon\nSingle User License\nEA7E-1122628\nC0360740 20724B8A 30420C09 6D7E046F\n3F5D5FBB 17EF95DA 2BA7BB27 CCB14947\n27A316BE 8BCF4BC0 252FB8FF FD97DF71\nB11A1DA9 F7119CA0 31984BB9 7D71700C\n2C728BF8 B952E5F5 B941FF64 6D7979DA\nB8EB32F8 8D415F8E F16FE657 A35381CC\n290E2905 96E81236 63D2B06D E5F01A69\n84174B79 7C467714 641A9013 94CA7162\n------ END LICENSE ------\n</code></pre>\n"},{"title":"001-Food politics in America","date":"2018-01-22T13:14:37.000Z","_content":"\n# 美国的食品政策\n\n## How to wage war against “Big Soda”\n## 如何发动对“软饮料”的战争\n\nSoda Politics: Taking on Big Soda (and Winning). By Marion Nestle. Oxford University Press; 508 pages; $29.95 and £19.99.\n\n软饮料策略：对付软饮料（然后取得胜利）。作者马里昂•奈斯特。牛津大学出版社。508页。29.95美元，19.99英镑。\n\n&ensp;&ensp;&ensp;&ensp;MARION NESTLE’S heavyweight polemic against Coca-Cola and PepsiCo comes at an odd moment for the industry. Americans are drinking fewer sugary sodas—in 2012 production was 23% below what it had been a decade earlier. Even sales of diet drinks are losing their fizz, as consumers question the merits of artificial sweeteners. From one angle, it would seem that health advocates such as Ms Nestle have won. Yet in America companies still produce 30 gallons of regular (not diet) fizzy drinks per person per year. In many countries, particularly developing ones, consumption is on the rise.\n\n&ensp;&ensp;&ensp;&ensp;软饮料工业正处不尴不尬之际，马里昂•奈斯特对口可口可乐以及百事可乐的抨击颇具影响力。越来越少的美国人选择饮用含糖碳酸饮料----与十年前相比，2012年含糖碳酸饮料的生产减少了23%。人们甚至也失去了对膳食饮料的亲睐，因为消费者们对饮料中是否添加人工甜味剂提出了质疑。从某个角度来看，像奈斯特女士这样的健康倡导者似乎赢得了胜利。然而，美国软饮料公司每年生产的常规碳酸饮料（而非膳食饮料）人均多达30加仑。在许多国家，尤其是发展中国家，常规碳酸饮料的消费仍呈上涨趋势。\n\n\n&ensp;&ensp;&ensp;&ensp;Ms Nestle, a professor at New York University, is both heartened by recent progress and dissatisfied with it. That is no surprise. Her first book, “Food Politics” (2002), remains a bible for those who bewail the power of food companies. In her new book she attacks the industry’s most widely consumed, least healthy product. “Soda Politics”, she says, is a book “to inspire readers to action”. As a rallying cry, it is verbose. When readers learn on page 238 that she will pick up a particular subject in chapter 25, it is with no little dismay that they realise they are only on chapter 17. But what the author wants most is to craft a meticulous guide to the producers’ alleged transgressions, and how to stop them.\n\n&ensp;&ensp;&ensp;&ensp;对于最近取得的进展，奈斯特女士，这位纽约大学的教授颇受鼓舞，但并不满足于此。这也不足为奇。她的第一本书“粮食政策”依旧被那些哀叹食品企业权势的人们奉为经典。在新书中，奈斯特女士对软饮料行业消费最广，最有害健康的产品进行了抨击。《软饮料策略》这本书旨在激励人们采取行动，奈斯特说到。然而作为战斗口号，却显得颇为繁冗。读者们在第238页了解到奈斯特将在第25章讲述一个特别的主题，却意识到自己才看到第17章，但他们并没有因此而沮丧。作者最想做的是拟定一份详细的指南，指出生产商曾经的过失，并想方设法阻止他们的这种行为。\n\n\n&ensp;&ensp;&ensp;&ensp;Ms Nestle says she would have no quibbles with sweet fizzy drinks if they were sipped occasionally, as a treat. However, for millions of people in many countries, they are not. In Mexico companies sold 372 cans of fizzy drinks per person in 2012. About half of Americans do not drink them regularly, but those who do are disproportionately poor, less educated, male, Hispanic or black. Ten per cent of Americans down more than four cans a day.\n\n&ensp;&ensp;&ensp;&ensp;奈斯特说如果人们只是在吃饭招待的时候偶尔饮用加了甜味剂的碳酸饮料，她不会提出异议。但实际上许多国家，成千上万的人们都在喝这种饮料。2012年，仅墨西哥人均消费的碳酸饮料就高达372罐。大约一半的美国人不会经常性地饮用碳酸饮料，但是那些选择碳酸饮料的人多半是些穷困潦倒，未接受良好教育的西班牙或者黑人男性。百分之十的美国人平均每天要喝掉至少4罐碳酸饮料。\n\n\n&ensp;&ensp;&ensp;&ensp;Drinking a lot of sweet fizzy drinks is plainly unhealthy. Unlike a Big Mac, they have no nutritional value; nor do their calories satisfy hunger. One large study found that for each can added to a person’s daily diet, the risk of diabetes jumped by 22%. There are also links between sugar and heart disease, stroke and cancer. Drinking lots of sodas imposes clear costs on individuals, Ms Nestle argues, but it has a broader cost, too. American taxpayers subsidise corn production (and thereby corn syrup) and let the poor use government food vouchers to buy fizzy drinks. More important, taxpayers foot the health bill for those who develop chronic disease.\n\n&ensp;&ensp;&ensp;&ensp;很显然，过度饮用碳酸饮料对身体健康是有害的。与巨无霸不同的是，这些碳酸饮料毫无营养价值，它们产生的热量也无法抵抗饥饿。一项大型研究表明，如果在日常饮食中加入碳酸饮料，那么人们罹患糖尿病的风险就会增加22%。心脏病，中风以及癌症与过多的糖分摄入不无关系。奈斯特说，大量饮用碳酸饮料会增加个人开支，但实际上个人花费要远大于此。美国的纳税人为玉米生产做出了贡献（也就是为玉米糖浆的生产做出了贡献），同时，他们让穷人用政府提供的食品券来购买碳酸饮料。更重要的是，纳税人为那些罹患慢性疾病的人支付医疗帐单。\n\n\n&ensp;&ensp;&ensp;&ensp;Encouraging people to drink fewer fizzy drinks, however, is fiendishly difficult. Soda companies spend billions on marketing; it is a tribute to the admen that Coca-Cola is one of the world’s best-loved brands, despite selling what is essentially fattening sugar-water. (Think of Coca-Cola’s encouragements to “open happiness” and PepsiCo’s exuberant spokeswoman, Beyoncé Knowles.) Once people get used to consuming sugary drinks, they are loth to give them up. There is evidence suggesting that sugar is addictive—some laboratory animals prefer sugar to cocaine.\n\n&ensp;&ensp;&ensp;&ensp;然而，鼓励人们尽量少喝碳酸饮料却出奇的难。碳酸饮料企业在营销上花费巨资。尽管可口可乐售卖的实际上是令人增肥的糖水饮料，但可口可乐无疑是世界上最受消费者青睐的品牌之一。而这对于广告人而言，是件可喜可贺的事情。（想想可口可乐颇具鼓动性的广告语“开启幸福”，百事可乐活力四射的代言人碧昂丝•诺利斯。）人们一旦习惯了消费含糖饮料，便很难戒掉。有证据表明食糖是会上瘾的----与可卡因相比，实验室的动物们更喜欢食糖。\n\n\n&ensp;&ensp;&ensp;&ensp;Most interesting, fizzy-drink companies are skilled at swatting away attempts at regulation. Ms Nestle describes an extraordinarily broad team of allies. That includes obvious friends, such as employees, bottlers and distributors, as well as the restaurants, cinemas, shops and sports stadiums that sell their products. But the companies are also astute philanthropists. When Michael Bloomberg, then mayor of New York, tried to block the use of government vouchers to buy sodas in 2010, the congressional black caucus was among those to lobby against it. The caucus’s foundation has received money from both Coke and Pepsi. In 2011 Philadelphia was considering a soda tax. After the soda lobby offered a big donation to the city’s children’s hospital, the idea fizzled out.\n\n&ensp;&ensp;&ensp;&ensp;更有趣的是，碳酸饮料企业对规避规范化的尝试颇有一套。奈斯特将其描述为一个非比寻常的庞大联盟。很显然，这个联盟包括了这些企业的盟友们，比如雇员，瓶装工，经销商，那些出售他们商品的饭店，电影院，商店以及体育场。但这些碳酸饮料企业同时也是非常精明的慈善家。2010年，当时的纽约市市长迈克尔•布隆伯格试图阻止人们用政府代金券购买碳酸饮料，但却遭到了包括美国国会黑人同盟在内的多数人的反对。2011年，费城考虑是否要征收碳酸饮料税，但在碳酸饮料游说集团出资捐助了一家当地的儿童医院之后，这项提议未能实施。\n\n\n&ensp;&ensp;&ensp;&ensp;Coca-Cola and PepsiCo do have a few notable adversaries. Mr Bloomberg, a billionaire, remains their single biggest foe. It is telling that in two rare instances when a soda tax has been passed—in Berkeley, California and in Mexico—it was with the help of cash from Mr Bloomberg. Drinks companies must also reckon with a small army of health advocates, among which Ms Nestle is a major-general.\n\n&ensp;&ensp;&ensp;&ensp;可口可乐和百事可乐确实有一些颇为出名的对手。布隆伯格，这位亿万富翁是他们最大的对手。据说在两个颇为罕见的通过征收碳酸饮料税的例子中----一个是加利福尼亚的伯克利市，另一个是墨西哥----都是在布隆伯格的资金帮助下通过了碳酸饮料税法案。饮料公司还得去对付那些以奈斯特为首的健康军团。\n\n\n&ensp;&ensp;&ensp;&ensp;With the slow decline of soda in America, she and her allies are advancing. Coca-Cola and PepsiCo are peddling healthier drinks, such as bottled water. However, as they try to face down a long-term threat while maintaining near-term profits, they are still pushing their syrupy fare.\n\n&ensp;&ensp;&ensp;&ensp;随着美国人慢慢地拒绝碳酸饮料，奈斯特和她的盟友们正向成功一步步迈进。可口可乐和百事可乐正忙于推销更健康的饮料，如瓶装水。然而，他们仍旧努力推动碳酸饮料事业的发展，试图在维持短期利润的同时，努力克服长期以来的威胁。\n\n\n&ensp;&ensp;&ensp;&ensp;Ms Nestle is impatient. To the casual reader, her suggestions can seem extreme. She writes enthusiastically about adorning soda cans with warning labels, such as pictures of a diabetic’s foot ulcer. She suggests that parents should teach their children about fizzy drinks by gently boiling down a Coke or a Pepsi into sludge, which sounds rather fun, and asking them to calculate the precise length of grocery shelves bearing sodas, which sounds less so. This zeal threatens to overshadow her stronger points: fizzy drinks offer no nutritional benefit and impose clear costs—on individuals’ health and on society.\n\n&ensp;&ensp;&ensp;&ensp;奈斯特女士可没那么好的耐心。对于一般的读者，她给的建议似乎很极端。在书中她强烈建议碳酸饮料瓶上面必须贴有糖尿病患者脚部溃烂诸如此类的警示标志。她建议父母们在向孩子们介绍碳酸饮料时，将可口可乐和百事可乐说成是垃圾，这看上去颇为有趣，并要求孩子们去算算杂货店摆满碳酸饮料的货架究竟有多长，这听上去似乎没那么好笑了。这份热情让斯耐特关于碳酸饮料的观点显得不那么重要了：碳酸饮料没有任何营养价值，对个人的健康没有好处，而且还增加了社会的负担。\n","source":"_posts/英语/Food-politics-in-America.md","raw":"---\ntitle: 001-Food politics in America\npermalink: food-politics-in-America\ncategories:\n  - 英语\ntags:\n  - english\ndate: 2018-01-22 21:14:37\n---\n\n# 美国的食品政策\n\n## How to wage war against “Big Soda”\n## 如何发动对“软饮料”的战争\n\nSoda Politics: Taking on Big Soda (and Winning). By Marion Nestle. Oxford University Press; 508 pages; $29.95 and £19.99.\n\n软饮料策略：对付软饮料（然后取得胜利）。作者马里昂•奈斯特。牛津大学出版社。508页。29.95美元，19.99英镑。\n\n&ensp;&ensp;&ensp;&ensp;MARION NESTLE’S heavyweight polemic against Coca-Cola and PepsiCo comes at an odd moment for the industry. Americans are drinking fewer sugary sodas—in 2012 production was 23% below what it had been a decade earlier. Even sales of diet drinks are losing their fizz, as consumers question the merits of artificial sweeteners. From one angle, it would seem that health advocates such as Ms Nestle have won. Yet in America companies still produce 30 gallons of regular (not diet) fizzy drinks per person per year. In many countries, particularly developing ones, consumption is on the rise.\n\n&ensp;&ensp;&ensp;&ensp;软饮料工业正处不尴不尬之际，马里昂•奈斯特对口可口可乐以及百事可乐的抨击颇具影响力。越来越少的美国人选择饮用含糖碳酸饮料----与十年前相比，2012年含糖碳酸饮料的生产减少了23%。人们甚至也失去了对膳食饮料的亲睐，因为消费者们对饮料中是否添加人工甜味剂提出了质疑。从某个角度来看，像奈斯特女士这样的健康倡导者似乎赢得了胜利。然而，美国软饮料公司每年生产的常规碳酸饮料（而非膳食饮料）人均多达30加仑。在许多国家，尤其是发展中国家，常规碳酸饮料的消费仍呈上涨趋势。\n\n\n&ensp;&ensp;&ensp;&ensp;Ms Nestle, a professor at New York University, is both heartened by recent progress and dissatisfied with it. That is no surprise. Her first book, “Food Politics” (2002), remains a bible for those who bewail the power of food companies. In her new book she attacks the industry’s most widely consumed, least healthy product. “Soda Politics”, she says, is a book “to inspire readers to action”. As a rallying cry, it is verbose. When readers learn on page 238 that she will pick up a particular subject in chapter 25, it is with no little dismay that they realise they are only on chapter 17. But what the author wants most is to craft a meticulous guide to the producers’ alleged transgressions, and how to stop them.\n\n&ensp;&ensp;&ensp;&ensp;对于最近取得的进展，奈斯特女士，这位纽约大学的教授颇受鼓舞，但并不满足于此。这也不足为奇。她的第一本书“粮食政策”依旧被那些哀叹食品企业权势的人们奉为经典。在新书中，奈斯特女士对软饮料行业消费最广，最有害健康的产品进行了抨击。《软饮料策略》这本书旨在激励人们采取行动，奈斯特说到。然而作为战斗口号，却显得颇为繁冗。读者们在第238页了解到奈斯特将在第25章讲述一个特别的主题，却意识到自己才看到第17章，但他们并没有因此而沮丧。作者最想做的是拟定一份详细的指南，指出生产商曾经的过失，并想方设法阻止他们的这种行为。\n\n\n&ensp;&ensp;&ensp;&ensp;Ms Nestle says she would have no quibbles with sweet fizzy drinks if they were sipped occasionally, as a treat. However, for millions of people in many countries, they are not. In Mexico companies sold 372 cans of fizzy drinks per person in 2012. About half of Americans do not drink them regularly, but those who do are disproportionately poor, less educated, male, Hispanic or black. Ten per cent of Americans down more than four cans a day.\n\n&ensp;&ensp;&ensp;&ensp;奈斯特说如果人们只是在吃饭招待的时候偶尔饮用加了甜味剂的碳酸饮料，她不会提出异议。但实际上许多国家，成千上万的人们都在喝这种饮料。2012年，仅墨西哥人均消费的碳酸饮料就高达372罐。大约一半的美国人不会经常性地饮用碳酸饮料，但是那些选择碳酸饮料的人多半是些穷困潦倒，未接受良好教育的西班牙或者黑人男性。百分之十的美国人平均每天要喝掉至少4罐碳酸饮料。\n\n\n&ensp;&ensp;&ensp;&ensp;Drinking a lot of sweet fizzy drinks is plainly unhealthy. Unlike a Big Mac, they have no nutritional value; nor do their calories satisfy hunger. One large study found that for each can added to a person’s daily diet, the risk of diabetes jumped by 22%. There are also links between sugar and heart disease, stroke and cancer. Drinking lots of sodas imposes clear costs on individuals, Ms Nestle argues, but it has a broader cost, too. American taxpayers subsidise corn production (and thereby corn syrup) and let the poor use government food vouchers to buy fizzy drinks. More important, taxpayers foot the health bill for those who develop chronic disease.\n\n&ensp;&ensp;&ensp;&ensp;很显然，过度饮用碳酸饮料对身体健康是有害的。与巨无霸不同的是，这些碳酸饮料毫无营养价值，它们产生的热量也无法抵抗饥饿。一项大型研究表明，如果在日常饮食中加入碳酸饮料，那么人们罹患糖尿病的风险就会增加22%。心脏病，中风以及癌症与过多的糖分摄入不无关系。奈斯特说，大量饮用碳酸饮料会增加个人开支，但实际上个人花费要远大于此。美国的纳税人为玉米生产做出了贡献（也就是为玉米糖浆的生产做出了贡献），同时，他们让穷人用政府提供的食品券来购买碳酸饮料。更重要的是，纳税人为那些罹患慢性疾病的人支付医疗帐单。\n\n\n&ensp;&ensp;&ensp;&ensp;Encouraging people to drink fewer fizzy drinks, however, is fiendishly difficult. Soda companies spend billions on marketing; it is a tribute to the admen that Coca-Cola is one of the world’s best-loved brands, despite selling what is essentially fattening sugar-water. (Think of Coca-Cola’s encouragements to “open happiness” and PepsiCo’s exuberant spokeswoman, Beyoncé Knowles.) Once people get used to consuming sugary drinks, they are loth to give them up. There is evidence suggesting that sugar is addictive—some laboratory animals prefer sugar to cocaine.\n\n&ensp;&ensp;&ensp;&ensp;然而，鼓励人们尽量少喝碳酸饮料却出奇的难。碳酸饮料企业在营销上花费巨资。尽管可口可乐售卖的实际上是令人增肥的糖水饮料，但可口可乐无疑是世界上最受消费者青睐的品牌之一。而这对于广告人而言，是件可喜可贺的事情。（想想可口可乐颇具鼓动性的广告语“开启幸福”，百事可乐活力四射的代言人碧昂丝•诺利斯。）人们一旦习惯了消费含糖饮料，便很难戒掉。有证据表明食糖是会上瘾的----与可卡因相比，实验室的动物们更喜欢食糖。\n\n\n&ensp;&ensp;&ensp;&ensp;Most interesting, fizzy-drink companies are skilled at swatting away attempts at regulation. Ms Nestle describes an extraordinarily broad team of allies. That includes obvious friends, such as employees, bottlers and distributors, as well as the restaurants, cinemas, shops and sports stadiums that sell their products. But the companies are also astute philanthropists. When Michael Bloomberg, then mayor of New York, tried to block the use of government vouchers to buy sodas in 2010, the congressional black caucus was among those to lobby against it. The caucus’s foundation has received money from both Coke and Pepsi. In 2011 Philadelphia was considering a soda tax. After the soda lobby offered a big donation to the city’s children’s hospital, the idea fizzled out.\n\n&ensp;&ensp;&ensp;&ensp;更有趣的是，碳酸饮料企业对规避规范化的尝试颇有一套。奈斯特将其描述为一个非比寻常的庞大联盟。很显然，这个联盟包括了这些企业的盟友们，比如雇员，瓶装工，经销商，那些出售他们商品的饭店，电影院，商店以及体育场。但这些碳酸饮料企业同时也是非常精明的慈善家。2010年，当时的纽约市市长迈克尔•布隆伯格试图阻止人们用政府代金券购买碳酸饮料，但却遭到了包括美国国会黑人同盟在内的多数人的反对。2011年，费城考虑是否要征收碳酸饮料税，但在碳酸饮料游说集团出资捐助了一家当地的儿童医院之后，这项提议未能实施。\n\n\n&ensp;&ensp;&ensp;&ensp;Coca-Cola and PepsiCo do have a few notable adversaries. Mr Bloomberg, a billionaire, remains their single biggest foe. It is telling that in two rare instances when a soda tax has been passed—in Berkeley, California and in Mexico—it was with the help of cash from Mr Bloomberg. Drinks companies must also reckon with a small army of health advocates, among which Ms Nestle is a major-general.\n\n&ensp;&ensp;&ensp;&ensp;可口可乐和百事可乐确实有一些颇为出名的对手。布隆伯格，这位亿万富翁是他们最大的对手。据说在两个颇为罕见的通过征收碳酸饮料税的例子中----一个是加利福尼亚的伯克利市，另一个是墨西哥----都是在布隆伯格的资金帮助下通过了碳酸饮料税法案。饮料公司还得去对付那些以奈斯特为首的健康军团。\n\n\n&ensp;&ensp;&ensp;&ensp;With the slow decline of soda in America, she and her allies are advancing. Coca-Cola and PepsiCo are peddling healthier drinks, such as bottled water. However, as they try to face down a long-term threat while maintaining near-term profits, they are still pushing their syrupy fare.\n\n&ensp;&ensp;&ensp;&ensp;随着美国人慢慢地拒绝碳酸饮料，奈斯特和她的盟友们正向成功一步步迈进。可口可乐和百事可乐正忙于推销更健康的饮料，如瓶装水。然而，他们仍旧努力推动碳酸饮料事业的发展，试图在维持短期利润的同时，努力克服长期以来的威胁。\n\n\n&ensp;&ensp;&ensp;&ensp;Ms Nestle is impatient. To the casual reader, her suggestions can seem extreme. She writes enthusiastically about adorning soda cans with warning labels, such as pictures of a diabetic’s foot ulcer. She suggests that parents should teach their children about fizzy drinks by gently boiling down a Coke or a Pepsi into sludge, which sounds rather fun, and asking them to calculate the precise length of grocery shelves bearing sodas, which sounds less so. This zeal threatens to overshadow her stronger points: fizzy drinks offer no nutritional benefit and impose clear costs—on individuals’ health and on society.\n\n&ensp;&ensp;&ensp;&ensp;奈斯特女士可没那么好的耐心。对于一般的读者，她给的建议似乎很极端。在书中她强烈建议碳酸饮料瓶上面必须贴有糖尿病患者脚部溃烂诸如此类的警示标志。她建议父母们在向孩子们介绍碳酸饮料时，将可口可乐和百事可乐说成是垃圾，这看上去颇为有趣，并要求孩子们去算算杂货店摆满碳酸饮料的货架究竟有多长，这听上去似乎没那么好笑了。这份热情让斯耐特关于碳酸饮料的观点显得不那么重要了：碳酸饮料没有任何营养价值，对个人的健康没有好处，而且还增加了社会的负担。\n","slug":"food-politics-in-America","published":1,"updated":"2018-08-13T06:23:24.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjks8kndv000xxwuj0hhsigo3","content":"<h1 id=\"美国的食品政策\"><a href=\"#美国的食品政策\" class=\"headerlink\" title=\"美国的食品政策\"></a>美国的食品政策</h1><h2 id=\"How-to-wage-war-against-“Big-Soda”\"><a href=\"#How-to-wage-war-against-“Big-Soda”\" class=\"headerlink\" title=\"How to wage war against “Big Soda”\"></a>How to wage war against “Big Soda”</h2><h2 id=\"如何发动对“软饮料”的战争\"><a href=\"#如何发动对“软饮料”的战争\" class=\"headerlink\" title=\"如何发动对“软饮料”的战争\"></a>如何发动对“软饮料”的战争</h2><p>Soda Politics: Taking on Big Soda (and Winning). By Marion Nestle. Oxford University Press; 508 pages; $29.95 and £19.99.</p>\n<p>软饮料策略：对付软饮料（然后取得胜利）。作者马里昂•奈斯特。牛津大学出版社。508页。29.95美元，19.99英镑。</p>\n<p>&ensp;&ensp;&ensp;&ensp;MARION NESTLE’S heavyweight polemic against Coca-Cola and PepsiCo comes at an odd moment for the industry. Americans are drinking fewer sugary sodas—in 2012 production was 23% below what it had been a decade earlier. Even sales of diet drinks are losing their fizz, as consumers question the merits of artificial sweeteners. From one angle, it would seem that health advocates such as Ms Nestle have won. Yet in America companies still produce 30 gallons of regular (not diet) fizzy drinks per person per year. In many countries, particularly developing ones, consumption is on the rise.</p>\n<p>&ensp;&ensp;&ensp;&ensp;软饮料工业正处不尴不尬之际，马里昂•奈斯特对口可口可乐以及百事可乐的抨击颇具影响力。越来越少的美国人选择饮用含糖碳酸饮料—-与十年前相比，2012年含糖碳酸饮料的生产减少了23%。人们甚至也失去了对膳食饮料的亲睐，因为消费者们对饮料中是否添加人工甜味剂提出了质疑。从某个角度来看，像奈斯特女士这样的健康倡导者似乎赢得了胜利。然而，美国软饮料公司每年生产的常规碳酸饮料（而非膳食饮料）人均多达30加仑。在许多国家，尤其是发展中国家，常规碳酸饮料的消费仍呈上涨趋势。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Ms Nestle, a professor at New York University, is both heartened by recent progress and dissatisfied with it. That is no surprise. Her first book, “Food Politics” (2002), remains a bible for those who bewail the power of food companies. In her new book she attacks the industry’s most widely consumed, least healthy product. “Soda Politics”, she says, is a book “to inspire readers to action”. As a rallying cry, it is verbose. When readers learn on page 238 that she will pick up a particular subject in chapter 25, it is with no little dismay that they realise they are only on chapter 17. But what the author wants most is to craft a meticulous guide to the producers’ alleged transgressions, and how to stop them.</p>\n<p>&ensp;&ensp;&ensp;&ensp;对于最近取得的进展，奈斯特女士，这位纽约大学的教授颇受鼓舞，但并不满足于此。这也不足为奇。她的第一本书“粮食政策”依旧被那些哀叹食品企业权势的人们奉为经典。在新书中，奈斯特女士对软饮料行业消费最广，最有害健康的产品进行了抨击。《软饮料策略》这本书旨在激励人们采取行动，奈斯特说到。然而作为战斗口号，却显得颇为繁冗。读者们在第238页了解到奈斯特将在第25章讲述一个特别的主题，却意识到自己才看到第17章，但他们并没有因此而沮丧。作者最想做的是拟定一份详细的指南，指出生产商曾经的过失，并想方设法阻止他们的这种行为。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Ms Nestle says she would have no quibbles with sweet fizzy drinks if they were sipped occasionally, as a treat. However, for millions of people in many countries, they are not. In Mexico companies sold 372 cans of fizzy drinks per person in 2012. About half of Americans do not drink them regularly, but those who do are disproportionately poor, less educated, male, Hispanic or black. Ten per cent of Americans down more than four cans a day.</p>\n<p>&ensp;&ensp;&ensp;&ensp;奈斯特说如果人们只是在吃饭招待的时候偶尔饮用加了甜味剂的碳酸饮料，她不会提出异议。但实际上许多国家，成千上万的人们都在喝这种饮料。2012年，仅墨西哥人均消费的碳酸饮料就高达372罐。大约一半的美国人不会经常性地饮用碳酸饮料，但是那些选择碳酸饮料的人多半是些穷困潦倒，未接受良好教育的西班牙或者黑人男性。百分之十的美国人平均每天要喝掉至少4罐碳酸饮料。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Drinking a lot of sweet fizzy drinks is plainly unhealthy. Unlike a Big Mac, they have no nutritional value; nor do their calories satisfy hunger. One large study found that for each can added to a person’s daily diet, the risk of diabetes jumped by 22%. There are also links between sugar and heart disease, stroke and cancer. Drinking lots of sodas imposes clear costs on individuals, Ms Nestle argues, but it has a broader cost, too. American taxpayers subsidise corn production (and thereby corn syrup) and let the poor use government food vouchers to buy fizzy drinks. More important, taxpayers foot the health bill for those who develop chronic disease.</p>\n<p>&ensp;&ensp;&ensp;&ensp;很显然，过度饮用碳酸饮料对身体健康是有害的。与巨无霸不同的是，这些碳酸饮料毫无营养价值，它们产生的热量也无法抵抗饥饿。一项大型研究表明，如果在日常饮食中加入碳酸饮料，那么人们罹患糖尿病的风险就会增加22%。心脏病，中风以及癌症与过多的糖分摄入不无关系。奈斯特说，大量饮用碳酸饮料会增加个人开支，但实际上个人花费要远大于此。美国的纳税人为玉米生产做出了贡献（也就是为玉米糖浆的生产做出了贡献），同时，他们让穷人用政府提供的食品券来购买碳酸饮料。更重要的是，纳税人为那些罹患慢性疾病的人支付医疗帐单。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Encouraging people to drink fewer fizzy drinks, however, is fiendishly difficult. Soda companies spend billions on marketing; it is a tribute to the admen that Coca-Cola is one of the world’s best-loved brands, despite selling what is essentially fattening sugar-water. (Think of Coca-Cola’s encouragements to “open happiness” and PepsiCo’s exuberant spokeswoman, Beyoncé Knowles.) Once people get used to consuming sugary drinks, they are loth to give them up. There is evidence suggesting that sugar is addictive—some laboratory animals prefer sugar to cocaine.</p>\n<p>&ensp;&ensp;&ensp;&ensp;然而，鼓励人们尽量少喝碳酸饮料却出奇的难。碳酸饮料企业在营销上花费巨资。尽管可口可乐售卖的实际上是令人增肥的糖水饮料，但可口可乐无疑是世界上最受消费者青睐的品牌之一。而这对于广告人而言，是件可喜可贺的事情。（想想可口可乐颇具鼓动性的广告语“开启幸福”，百事可乐活力四射的代言人碧昂丝•诺利斯。）人们一旦习惯了消费含糖饮料，便很难戒掉。有证据表明食糖是会上瘾的—-与可卡因相比，实验室的动物们更喜欢食糖。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Most interesting, fizzy-drink companies are skilled at swatting away attempts at regulation. Ms Nestle describes an extraordinarily broad team of allies. That includes obvious friends, such as employees, bottlers and distributors, as well as the restaurants, cinemas, shops and sports stadiums that sell their products. But the companies are also astute philanthropists. When Michael Bloomberg, then mayor of New York, tried to block the use of government vouchers to buy sodas in 2010, the congressional black caucus was among those to lobby against it. The caucus’s foundation has received money from both Coke and Pepsi. In 2011 Philadelphia was considering a soda tax. After the soda lobby offered a big donation to the city’s children’s hospital, the idea fizzled out.</p>\n<p>&ensp;&ensp;&ensp;&ensp;更有趣的是，碳酸饮料企业对规避规范化的尝试颇有一套。奈斯特将其描述为一个非比寻常的庞大联盟。很显然，这个联盟包括了这些企业的盟友们，比如雇员，瓶装工，经销商，那些出售他们商品的饭店，电影院，商店以及体育场。但这些碳酸饮料企业同时也是非常精明的慈善家。2010年，当时的纽约市市长迈克尔•布隆伯格试图阻止人们用政府代金券购买碳酸饮料，但却遭到了包括美国国会黑人同盟在内的多数人的反对。2011年，费城考虑是否要征收碳酸饮料税，但在碳酸饮料游说集团出资捐助了一家当地的儿童医院之后，这项提议未能实施。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Coca-Cola and PepsiCo do have a few notable adversaries. Mr Bloomberg, a billionaire, remains their single biggest foe. It is telling that in two rare instances when a soda tax has been passed—in Berkeley, California and in Mexico—it was with the help of cash from Mr Bloomberg. Drinks companies must also reckon with a small army of health advocates, among which Ms Nestle is a major-general.</p>\n<p>&ensp;&ensp;&ensp;&ensp;可口可乐和百事可乐确实有一些颇为出名的对手。布隆伯格，这位亿万富翁是他们最大的对手。据说在两个颇为罕见的通过征收碳酸饮料税的例子中—-一个是加利福尼亚的伯克利市，另一个是墨西哥—-都是在布隆伯格的资金帮助下通过了碳酸饮料税法案。饮料公司还得去对付那些以奈斯特为首的健康军团。</p>\n<p>&ensp;&ensp;&ensp;&ensp;With the slow decline of soda in America, she and her allies are advancing. Coca-Cola and PepsiCo are peddling healthier drinks, such as bottled water. However, as they try to face down a long-term threat while maintaining near-term profits, they are still pushing their syrupy fare.</p>\n<p>&ensp;&ensp;&ensp;&ensp;随着美国人慢慢地拒绝碳酸饮料，奈斯特和她的盟友们正向成功一步步迈进。可口可乐和百事可乐正忙于推销更健康的饮料，如瓶装水。然而，他们仍旧努力推动碳酸饮料事业的发展，试图在维持短期利润的同时，努力克服长期以来的威胁。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Ms Nestle is impatient. To the casual reader, her suggestions can seem extreme. She writes enthusiastically about adorning soda cans with warning labels, such as pictures of a diabetic’s foot ulcer. She suggests that parents should teach their children about fizzy drinks by gently boiling down a Coke or a Pepsi into sludge, which sounds rather fun, and asking them to calculate the precise length of grocery shelves bearing sodas, which sounds less so. This zeal threatens to overshadow her stronger points: fizzy drinks offer no nutritional benefit and impose clear costs—on individuals’ health and on society.</p>\n<p>&ensp;&ensp;&ensp;&ensp;奈斯特女士可没那么好的耐心。对于一般的读者，她给的建议似乎很极端。在书中她强烈建议碳酸饮料瓶上面必须贴有糖尿病患者脚部溃烂诸如此类的警示标志。她建议父母们在向孩子们介绍碳酸饮料时，将可口可乐和百事可乐说成是垃圾，这看上去颇为有趣，并要求孩子们去算算杂货店摆满碳酸饮料的货架究竟有多长，这听上去似乎没那么好笑了。这份热情让斯耐特关于碳酸饮料的观点显得不那么重要了：碳酸饮料没有任何营养价值，对个人的健康没有好处，而且还增加了社会的负担。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"美国的食品政策\"><a href=\"#美国的食品政策\" class=\"headerlink\" title=\"美国的食品政策\"></a>美国的食品政策</h1><h2 id=\"How-to-wage-war-against-“Big-Soda”\"><a href=\"#How-to-wage-war-against-“Big-Soda”\" class=\"headerlink\" title=\"How to wage war against “Big Soda”\"></a>How to wage war against “Big Soda”</h2><h2 id=\"如何发动对“软饮料”的战争\"><a href=\"#如何发动对“软饮料”的战争\" class=\"headerlink\" title=\"如何发动对“软饮料”的战争\"></a>如何发动对“软饮料”的战争</h2><p>Soda Politics: Taking on Big Soda (and Winning). By Marion Nestle. Oxford University Press; 508 pages; $29.95 and £19.99.</p>\n<p>软饮料策略：对付软饮料（然后取得胜利）。作者马里昂•奈斯特。牛津大学出版社。508页。29.95美元，19.99英镑。</p>\n<p>&ensp;&ensp;&ensp;&ensp;MARION NESTLE’S heavyweight polemic against Coca-Cola and PepsiCo comes at an odd moment for the industry. Americans are drinking fewer sugary sodas—in 2012 production was 23% below what it had been a decade earlier. Even sales of diet drinks are losing their fizz, as consumers question the merits of artificial sweeteners. From one angle, it would seem that health advocates such as Ms Nestle have won. Yet in America companies still produce 30 gallons of regular (not diet) fizzy drinks per person per year. In many countries, particularly developing ones, consumption is on the rise.</p>\n<p>&ensp;&ensp;&ensp;&ensp;软饮料工业正处不尴不尬之际，马里昂•奈斯特对口可口可乐以及百事可乐的抨击颇具影响力。越来越少的美国人选择饮用含糖碳酸饮料—-与十年前相比，2012年含糖碳酸饮料的生产减少了23%。人们甚至也失去了对膳食饮料的亲睐，因为消费者们对饮料中是否添加人工甜味剂提出了质疑。从某个角度来看，像奈斯特女士这样的健康倡导者似乎赢得了胜利。然而，美国软饮料公司每年生产的常规碳酸饮料（而非膳食饮料）人均多达30加仑。在许多国家，尤其是发展中国家，常规碳酸饮料的消费仍呈上涨趋势。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Ms Nestle, a professor at New York University, is both heartened by recent progress and dissatisfied with it. That is no surprise. Her first book, “Food Politics” (2002), remains a bible for those who bewail the power of food companies. In her new book she attacks the industry’s most widely consumed, least healthy product. “Soda Politics”, she says, is a book “to inspire readers to action”. As a rallying cry, it is verbose. When readers learn on page 238 that she will pick up a particular subject in chapter 25, it is with no little dismay that they realise they are only on chapter 17. But what the author wants most is to craft a meticulous guide to the producers’ alleged transgressions, and how to stop them.</p>\n<p>&ensp;&ensp;&ensp;&ensp;对于最近取得的进展，奈斯特女士，这位纽约大学的教授颇受鼓舞，但并不满足于此。这也不足为奇。她的第一本书“粮食政策”依旧被那些哀叹食品企业权势的人们奉为经典。在新书中，奈斯特女士对软饮料行业消费最广，最有害健康的产品进行了抨击。《软饮料策略》这本书旨在激励人们采取行动，奈斯特说到。然而作为战斗口号，却显得颇为繁冗。读者们在第238页了解到奈斯特将在第25章讲述一个特别的主题，却意识到自己才看到第17章，但他们并没有因此而沮丧。作者最想做的是拟定一份详细的指南，指出生产商曾经的过失，并想方设法阻止他们的这种行为。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Ms Nestle says she would have no quibbles with sweet fizzy drinks if they were sipped occasionally, as a treat. However, for millions of people in many countries, they are not. In Mexico companies sold 372 cans of fizzy drinks per person in 2012. About half of Americans do not drink them regularly, but those who do are disproportionately poor, less educated, male, Hispanic or black. Ten per cent of Americans down more than four cans a day.</p>\n<p>&ensp;&ensp;&ensp;&ensp;奈斯特说如果人们只是在吃饭招待的时候偶尔饮用加了甜味剂的碳酸饮料，她不会提出异议。但实际上许多国家，成千上万的人们都在喝这种饮料。2012年，仅墨西哥人均消费的碳酸饮料就高达372罐。大约一半的美国人不会经常性地饮用碳酸饮料，但是那些选择碳酸饮料的人多半是些穷困潦倒，未接受良好教育的西班牙或者黑人男性。百分之十的美国人平均每天要喝掉至少4罐碳酸饮料。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Drinking a lot of sweet fizzy drinks is plainly unhealthy. Unlike a Big Mac, they have no nutritional value; nor do their calories satisfy hunger. One large study found that for each can added to a person’s daily diet, the risk of diabetes jumped by 22%. There are also links between sugar and heart disease, stroke and cancer. Drinking lots of sodas imposes clear costs on individuals, Ms Nestle argues, but it has a broader cost, too. American taxpayers subsidise corn production (and thereby corn syrup) and let the poor use government food vouchers to buy fizzy drinks. More important, taxpayers foot the health bill for those who develop chronic disease.</p>\n<p>&ensp;&ensp;&ensp;&ensp;很显然，过度饮用碳酸饮料对身体健康是有害的。与巨无霸不同的是，这些碳酸饮料毫无营养价值，它们产生的热量也无法抵抗饥饿。一项大型研究表明，如果在日常饮食中加入碳酸饮料，那么人们罹患糖尿病的风险就会增加22%。心脏病，中风以及癌症与过多的糖分摄入不无关系。奈斯特说，大量饮用碳酸饮料会增加个人开支，但实际上个人花费要远大于此。美国的纳税人为玉米生产做出了贡献（也就是为玉米糖浆的生产做出了贡献），同时，他们让穷人用政府提供的食品券来购买碳酸饮料。更重要的是，纳税人为那些罹患慢性疾病的人支付医疗帐单。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Encouraging people to drink fewer fizzy drinks, however, is fiendishly difficult. Soda companies spend billions on marketing; it is a tribute to the admen that Coca-Cola is one of the world’s best-loved brands, despite selling what is essentially fattening sugar-water. (Think of Coca-Cola’s encouragements to “open happiness” and PepsiCo’s exuberant spokeswoman, Beyoncé Knowles.) Once people get used to consuming sugary drinks, they are loth to give them up. There is evidence suggesting that sugar is addictive—some laboratory animals prefer sugar to cocaine.</p>\n<p>&ensp;&ensp;&ensp;&ensp;然而，鼓励人们尽量少喝碳酸饮料却出奇的难。碳酸饮料企业在营销上花费巨资。尽管可口可乐售卖的实际上是令人增肥的糖水饮料，但可口可乐无疑是世界上最受消费者青睐的品牌之一。而这对于广告人而言，是件可喜可贺的事情。（想想可口可乐颇具鼓动性的广告语“开启幸福”，百事可乐活力四射的代言人碧昂丝•诺利斯。）人们一旦习惯了消费含糖饮料，便很难戒掉。有证据表明食糖是会上瘾的—-与可卡因相比，实验室的动物们更喜欢食糖。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Most interesting, fizzy-drink companies are skilled at swatting away attempts at regulation. Ms Nestle describes an extraordinarily broad team of allies. That includes obvious friends, such as employees, bottlers and distributors, as well as the restaurants, cinemas, shops and sports stadiums that sell their products. But the companies are also astute philanthropists. When Michael Bloomberg, then mayor of New York, tried to block the use of government vouchers to buy sodas in 2010, the congressional black caucus was among those to lobby against it. The caucus’s foundation has received money from both Coke and Pepsi. In 2011 Philadelphia was considering a soda tax. After the soda lobby offered a big donation to the city’s children’s hospital, the idea fizzled out.</p>\n<p>&ensp;&ensp;&ensp;&ensp;更有趣的是，碳酸饮料企业对规避规范化的尝试颇有一套。奈斯特将其描述为一个非比寻常的庞大联盟。很显然，这个联盟包括了这些企业的盟友们，比如雇员，瓶装工，经销商，那些出售他们商品的饭店，电影院，商店以及体育场。但这些碳酸饮料企业同时也是非常精明的慈善家。2010年，当时的纽约市市长迈克尔•布隆伯格试图阻止人们用政府代金券购买碳酸饮料，但却遭到了包括美国国会黑人同盟在内的多数人的反对。2011年，费城考虑是否要征收碳酸饮料税，但在碳酸饮料游说集团出资捐助了一家当地的儿童医院之后，这项提议未能实施。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Coca-Cola and PepsiCo do have a few notable adversaries. Mr Bloomberg, a billionaire, remains their single biggest foe. It is telling that in two rare instances when a soda tax has been passed—in Berkeley, California and in Mexico—it was with the help of cash from Mr Bloomberg. Drinks companies must also reckon with a small army of health advocates, among which Ms Nestle is a major-general.</p>\n<p>&ensp;&ensp;&ensp;&ensp;可口可乐和百事可乐确实有一些颇为出名的对手。布隆伯格，这位亿万富翁是他们最大的对手。据说在两个颇为罕见的通过征收碳酸饮料税的例子中—-一个是加利福尼亚的伯克利市，另一个是墨西哥—-都是在布隆伯格的资金帮助下通过了碳酸饮料税法案。饮料公司还得去对付那些以奈斯特为首的健康军团。</p>\n<p>&ensp;&ensp;&ensp;&ensp;With the slow decline of soda in America, she and her allies are advancing. Coca-Cola and PepsiCo are peddling healthier drinks, such as bottled water. However, as they try to face down a long-term threat while maintaining near-term profits, they are still pushing their syrupy fare.</p>\n<p>&ensp;&ensp;&ensp;&ensp;随着美国人慢慢地拒绝碳酸饮料，奈斯特和她的盟友们正向成功一步步迈进。可口可乐和百事可乐正忙于推销更健康的饮料，如瓶装水。然而，他们仍旧努力推动碳酸饮料事业的发展，试图在维持短期利润的同时，努力克服长期以来的威胁。</p>\n<p>&ensp;&ensp;&ensp;&ensp;Ms Nestle is impatient. To the casual reader, her suggestions can seem extreme. She writes enthusiastically about adorning soda cans with warning labels, such as pictures of a diabetic’s foot ulcer. She suggests that parents should teach their children about fizzy drinks by gently boiling down a Coke or a Pepsi into sludge, which sounds rather fun, and asking them to calculate the precise length of grocery shelves bearing sodas, which sounds less so. This zeal threatens to overshadow her stronger points: fizzy drinks offer no nutritional benefit and impose clear costs—on individuals’ health and on society.</p>\n<p>&ensp;&ensp;&ensp;&ensp;奈斯特女士可没那么好的耐心。对于一般的读者，她给的建议似乎很极端。在书中她强烈建议碳酸饮料瓶上面必须贴有糖尿病患者脚部溃烂诸如此类的警示标志。她建议父母们在向孩子们介绍碳酸饮料时，将可口可乐和百事可乐说成是垃圾，这看上去颇为有趣，并要求孩子们去算算杂货店摆满碳酸饮料的货架究竟有多长，这听上去似乎没那么好笑了。这份热情让斯耐特关于碳酸饮料的观点显得不那么重要了：碳酸饮料没有任何营养价值，对个人的健康没有好处，而且还增加了社会的负担。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjks8kndj0005xwujoppoyldp","category_id":"cjks8kndg0002xwuj9pmmis7p","_id":"cjks8kndo000cxwujguah8o2o"},{"post_id":"cjks8kndb0000xwujrh0tfo5g","category_id":"cjks8kndg0002xwuj9pmmis7p","_id":"cjks8kndp000gxwujam5lzu52"},{"post_id":"cjks8kndj0006xwujyaf8l5u6","category_id":"cjks8kndg0002xwuj9pmmis7p","_id":"cjks8kndr000jxwujtko42wfq"},{"post_id":"cjks8kndm000axwujad4077zu","category_id":"cjks8kndg0002xwuj9pmmis7p","_id":"cjks8knds000oxwuj45ex9klf"},{"post_id":"cjks8knde0001xwujzm236n4u","category_id":"cjks8kndg0002xwuj9pmmis7p","_id":"cjks8kndu000rxwujlxit0kka"},{"post_id":"cjks8kndn000bxwujhl6n1gri","category_id":"cjks8kndg0002xwuj9pmmis7p","_id":"cjks8kndv000wxwujbnsac5fc"},{"post_id":"cjks8kndi0004xwuj1gwwi6uw","category_id":"cjks8kndg0002xwuj9pmmis7p","_id":"cjks8kndv000yxwujazzz88hv"},{"post_id":"cjks8kndp000fxwujbeisqezs","category_id":"cjks8knds000mxwujlgsvwejy","_id":"cjks8kndw0010xwujo6rifbqg"},{"post_id":"cjks8kndq000ixwuje84kxut9","category_id":"cjks8kndu000vxwujg2faxepe","_id":"cjks8kndy0016xwujeninjl4x"},{"post_id":"cjks8knds000nxwujtw3gql37","category_id":"cjks8kndu000vxwujg2faxepe","_id":"cjks8kndy001axwuj88lki064"},{"post_id":"cjks8kndt000qxwujnuc5dfoq","category_id":"cjks8kndu000vxwujg2faxepe","_id":"cjks8kndz001fxwujbcnlz2ow"},{"post_id":"cjks8kndu000uxwujtltjty2j","category_id":"cjks8kndu000vxwujg2faxepe","_id":"cjks8kndz001hxwuje0bf8134"},{"post_id":"cjks8kndv000xxwuj0hhsigo3","category_id":"cjks8kndz001exwujleez1snq","_id":"cjks8kne0001lxwujgx5bcy8s"}],"PostTag":[{"post_id":"cjks8kndj0005xwujoppoyldp","tag_id":"cjks8kndh0003xwujil9tf77h","_id":"cjks8kndm0009xwuj1ic2wm9y"},{"post_id":"cjks8kndb0000xwujrh0tfo5g","tag_id":"cjks8kndh0003xwujil9tf77h","_id":"cjks8kndq000hxwujvqwazi7a"},{"post_id":"cjks8kndb0000xwujrh0tfo5g","tag_id":"cjks8kndk0008xwujuaco7aud","_id":"cjks8kndr000kxwujrrxw2m4f"},{"post_id":"cjks8kndn000bxwujhl6n1gri","tag_id":"cjks8kndh0003xwujil9tf77h","_id":"cjks8kndt000pxwujpybexczo"},{"post_id":"cjks8kndn000bxwujhl6n1gri","tag_id":"cjks8kndk0008xwujuaco7aud","_id":"cjks8kndu000sxwujl4jtfgew"},{"post_id":"cjks8knde0001xwujzm236n4u","tag_id":"cjks8kndh0003xwujil9tf77h","_id":"cjks8kndx0012xwuj3o7ndk6o"},{"post_id":"cjks8knde0001xwujzm236n4u","tag_id":"cjks8kndr000lxwujpeutif5z","_id":"cjks8kndx0013xwujr7bt4kxr"},{"post_id":"cjks8knde0001xwujzm236n4u","tag_id":"cjks8kndu000txwujzfzg06fd","_id":"cjks8kndy0017xwuj7nlb6ef4"},{"post_id":"cjks8kndi0004xwuj1gwwi6uw","tag_id":"cjks8kndh0003xwujil9tf77h","_id":"cjks8kndy001bxwujq0ts2j70"},{"post_id":"cjks8kndi0004xwuj1gwwi6uw","tag_id":"cjks8kndk0008xwujuaco7aud","_id":"cjks8kndz001cxwuju6nwgqab"},{"post_id":"cjks8kndj0006xwujyaf8l5u6","tag_id":"cjks8kndh0003xwujil9tf77h","_id":"cjks8kne0001ixwujqkvixpn5"},{"post_id":"cjks8kndj0006xwujyaf8l5u6","tag_id":"cjks8kndy0018xwujdn4bga7z","_id":"cjks8kne0001jxwuj5jmjexel"},{"post_id":"cjks8kndj0006xwujyaf8l5u6","tag_id":"cjks8kndk0008xwujuaco7aud","_id":"cjks8kne0001mxwujevsl209r"},{"post_id":"cjks8kndm000axwujad4077zu","tag_id":"cjks8kndh0003xwujil9tf77h","_id":"cjks8kne0001nxwujp4e7j9f8"},{"post_id":"cjks8kndm000axwujad4077zu","tag_id":"cjks8kndy0018xwujdn4bga7z","_id":"cjks8kne0001pxwujnkenxx37"},{"post_id":"cjks8kndp000fxwujbeisqezs","tag_id":"cjks8kne0001kxwujy2iubsrw","_id":"cjks8kne0001qxwujf50dk16z"},{"post_id":"cjks8kndq000ixwuje84kxut9","tag_id":"cjks8kne0001oxwujnw31jap2","_id":"cjks8kne1001txwuj5uf9gcwn"},{"post_id":"cjks8kndq000ixwuje84kxut9","tag_id":"cjks8kne1001rxwujx6kweyrr","_id":"cjks8kne1001uxwuj5n4wd07g"},{"post_id":"cjks8knds000nxwujtw3gql37","tag_id":"cjks8kne0001kxwujy2iubsrw","_id":"cjks8kne2001wxwujqu9orn33"},{"post_id":"cjks8kndt000qxwujnuc5dfoq","tag_id":"cjks8kne0001oxwujnw31jap2","_id":"cjks8kne3001zxwujgb1yt8q9"},{"post_id":"cjks8kndt000qxwujnuc5dfoq","tag_id":"cjks8kne2001xxwujmynbuw9q","_id":"cjks8kne30020xwujlnb7s3g9"},{"post_id":"cjks8kndu000uxwujtltjty2j","tag_id":"cjks8kne0001kxwujy2iubsrw","_id":"cjks8kne30023xwuj0xo6q11k"},{"post_id":"cjks8kndu000uxwujtltjty2j","tag_id":"cjks8kne30021xwujj91tn4pz","_id":"cjks8kne30024xwuj0ubqs69y"},{"post_id":"cjks8kndv000xxwuj0hhsigo3","tag_id":"cjks8kne30022xwujzfeci7j2","_id":"cjks8kne30025xwujgqtjtg7p"}],"Tag":[{"name":"android","_id":"cjks8kndh0003xwujil9tf77h"},{"name":"contacts","_id":"cjks8kndk0008xwujuaco7aud"},{"name":"cm","_id":"cjks8kndr000lxwujpeutif5z"},{"name":"lineageos","_id":"cjks8kndu000txwujzfzg06fd"},{"name":"面试","_id":"cjks8kndy0018xwujdn4bga7z"},{"name":"tools","_id":"cjks8kne0001kxwujy2iubsrw"},{"name":"hexo","_id":"cjks8kne0001oxwujnw31jap2"},{"name":"blog","_id":"cjks8kne1001rxwujx6kweyrr"},{"name":"3-hexo","_id":"cjks8kne2001xxwujmynbuw9q"},{"name":"keys","_id":"cjks8kne30021xwujj91tn4pz"},{"name":"english","_id":"cjks8kne30022xwujzfeci7j2"}]}}